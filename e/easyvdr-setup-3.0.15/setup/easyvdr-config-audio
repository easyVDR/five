#!/bin/bash

#--------------------------------------------
# Dieses Skript aktiviert und konfiguriert die Soundausgabe
#---------------------------------------------
# Version:      0.0.1 fuer easyVDR 0.8
# Version:      0.0.2 fuer easyVDR 0.9
#               0.0.3 mit Soundcheck
#               0.0.4 vom 02.09.2011: Automatik fuer mehrere Karten
#               0.0.5 vom 06.09.2011: Ausgabe ueber mehrere Devices gleichzeitig (asound.conf)
#               0.0.6 vom 08.09.2011: Aufgeraumt und ohne Umlaute
#               0.0.7 vom 14.09.2011: Sound-Check ohne Positiv-Meldung auch OK
#               0.0.9 vom 21.10.2011: ati -> Config_Sound_X
#               0.0.10vom 13.11.2011: erst easy-alsa, dann device-auswahl,
#                                     asound.conf nur 2 kanalig und Rechte auf 755
#               0.0.11vom 30.01.2012: Komplette Ueberarbeitung der Auswahl-Dialoge
#                                     generelle Umstellung auf Ausgabe ueber asound.conf und default-device
#                                     explizite Angabe von Karte und Device statt Zaehler im Script und in asound.conf
#               0.0.12vom 07.02.2012: Line defaultmaessig gemuted wegen Lirc-on-alsa
#               0.0.13vom 08.02.2012: Erkennung der Kanalzahl bei HDMI automatisiert
#               0.0.14vom 20.02.2012: Inaktive HDMI-Devices ausblenden
#                                     PassThrough mit Kartenkennung
#               0.0.15vom 24.02.2012: Stellt jetzt auch das Boxenlayout ein
#               0.0.16vom 26.03.2012: Kann auch mit Luecken bei den Soundkarten
#               0.0.16a vom 31.03.2012: easyvdr-openbox -> easyvdr-desktop  - C.B. 
#               0.0.17a vom 02.04.2012: Bugfix bei PassThrough ueber HDMI und Integration von unstable-fork .16a
#               0.0.18 vom 10.05.2012:  asound.conf.multi auch fuer mehrere user
#               0.0.19 vom 15.11.2012:  /var/lib/alsa/asound.state zu Begin immer loeschen und Soundmodul neu laden
#                                       asound.conf mit downmix von 6ch, /tmp/asound nach Gebrauch loeschen
#               0.0.20 vom 08.12.2012:  /var/lib/alsa/asound.state.easyvdr zusaetzlich loeschen und erstellen
#                                       inaktive codecs ein- und ausblenden im Wechsel, Logfile bereinigen
#               0.0.21 vom 21.12.2012:  Plugin und AddOn Einstellungen in separate Scripte auslagern
#               0.0.22 vom 15.01.2013:  cleanup $VDR => $CFG_DIR wg. config-loader  C.B.
#               0.0.23 vom 26.01.2013:  X-Start ueber separates script eldvalid-checker
#               0.0.24 vom 02.02.2013:  Korrektur da eldvalid-checker nun unter .../tools/
#               0.0.25 vom 05.05.2013:  small cleanup C.B.
#               0.0.26 vom 11.11.2013:  Sound-Check bei laufender X-Infobox
#               0.0.27 vom 22.12.2013:  Fehler "..keine Berechtigung.." ausgeblendet
#                                       Scriptaufruf fur Pulseaudio-Handling
#                                       DolbyDigital verwenden immer auf ja
#               0.0.28 vom 03.01.2014:  Standard-X-Metapaket hinzugefuegt
#                                       Neuer Anzeigebildschirm ueber x-functions
#               0.0.29 vom 16.02.2014:  Alsa-Konfiguration auch parallelen Desktop
#               0.2.0  vom 23.02.2014:  Erkennung der HDMI-Audio-Eigenschaften von Intel-HD-Grafik
#               0.2.1  vom 10.11.2014:  Pulseaudio-config  besser integriert
#               0.2.2  vom 16.03.2015:  modprobe beim Codec-Einblenden nur dann wenn erforderlich
#               0.2.3  vom 04.06.2015:  PhysStreamID fuer intel automatisch erkannt
#
#  Offenes:  	6ch hdmi-patch testen
#		sound-check mit entladen anderer module die den Ton blocken
#		eHD und analogton
#		forcen von Kanalzahl oder AC3-exist
#
#---------------------------------------------
# Autor:        michel8 for easyvdr
#---------------------------------------------
#
#
########################################################

. /usr/lib/vdr/easyvdr-config-loader
. /usr/lib/vdr/functions/easyvdr-functions-lib
. /usr/share/easyvdr/setup/easyvdr-setup-defines
. /usr/share/easyvdr/setup/easyvdr-setup-functions
. $CFG_DIR/sysconfig
. $SETUP_STATUS                                     # Statusfile auslesen

TITLE=" Setup fuer easyVDR $EASYVDR_VERSION - Audio "
BACKTITLE=" Audio Konfiguration fuer easyVDR"

FILENAME="easyvdr-config-audio"
FILEVERSION="V 0.2.3 vom 04.06.2015"
SNDLOG="$EASYVDR_LOGDIR/easyvdr-config-audio.log"

unset SndDevice
declare -A SndDevice


######################### functions ####################################################
#####
Usage()
{
    echo ""
    echo "easyvdr-config-audio $FILEVERSION"
    echo ""
    echo "Options: (z.B. --config --quiet --debug )"
    echo "   -c   --config      Konfigurieren der Soundausgabe"
    echo "   -s   --status      Status der Konfiguration anzeigen und loggen"
    echo "   -h   --help        Hilfe Anzeigen"
    echo ""
    echo "        --quiet       (2.Option) Wenige Dialoge anzeigen (sonst --all)"
    echo "        --debug       (3.Option) Schreibt weitere Statusinformationen"
    echo ""
}

#############################################################################
# Aktuellen Status anzeigen und ins Log schreiben
Log_Status()
{
#echo "--Aktuellen Status anzeigen und viele weitere Informationen ins Log schreiben"
echo "`date` Info: Option_1 --status: Aktuellen Status anzeigen und viele weitere Informationen ins Log schreiben" >> $SNDLOG
if [ $log_debuginfo != "true" ]; then
    echo "=====> Mehr Informationen beim Aufruf mit easyvdr-config-audio --status --all --debug"
    echo "------------------------------ "
    echo "=====> Mehr Informationen beim Aufruf mit easyvdr-config-audio --status --all --debug" >> $SNDLOG
    echo "------------------------------ " 		>> $SNDLOG
fi

############# aplay -l #############################
if [ $show_dialogs == "all" ]; then
    echo "aplay -l:"
    aplay -l
fi
aplay --version                        			>> $SNDLOG
echo "`date` Status: 'aplay -l'" 			>> $SNDLOG
aplay -l 2> /dev/null | sed 's/^/\t/'			>> $SNDLOG
echo "------------------------------ " 			>> $SNDLOG

############# aplay -L #############################
if [ $log_debuginfo == "true" ]; then
    echo "`date` Status: 'aplay -L'" 			>> $SNDLOG
    aplay -L 2> /dev/null | sed 's/^/\t/'		>> $SNDLOG
    echo "------------------------------ " 		>> $SNDLOG
fi


############# amixer #############################
if [ $log_debuginfo == "true" ]
  then
    echo "`date` Status: 'amixer'" 			>> $SNDLOG
    amixer 						>> $SNDLOG
    echo "------------------------------ " 		>> $SNDLOG
  else
    echo "`date` Status: 'amixer scontrols'" 		>> $SNDLOG
    amixer scontrols 					>> $SNDLOG
    echo "------------------------------ " 		>> $SNDLOG
fi

############# asound.conf sichern #############################
if [ $log_debuginfo == "true" ]; then
    DATE=`date +"%Y%m%d_%H%M%S"` 
    echo "`date` Info: /etc/asound.conf sichern nach $logdir/asound.conf_$DATE" >> $SNDLOG
    cp /etc/asound.conf $EASYVDR_LOGDIR/asound.conf_$DATE
    echo "------------------------------ " 		>> $SNDLOG
fi

############# Audio-Parameter zusammenfassen #############################
if [ $log_debuginfo == "true" ]; then
    echo "`date` Status: Hier folgen die Audio-Parameter in der $CFG_DIR/setup.conf:" >> $SNDLOG
    # Alle Zeilen beginnen mit: xineliboutput.Audio
    grep -w -e "xineliboutput.Audio" $CFG_DIR/setup.conf 	>> $SNDLOG
    echo "------------------------------ " 		>> $SNDLOG
    echo "`date` Status: Hier folgen die Audio-Parameter in der $PLUGIN_CFG_DIR/xineliboutput/config:" >> $SNDLOG
    # Alle Zeilen beginnen mit: audio. oder audio_
    egrep -B 2 "audio_|audio\." $PLUGIN_CFG_DIR/xineliboutput/config >> $SNDLOG
    echo "------------------------------ " 		>> $SNDLOG
fi

############# ausgabedevice ########################
    grep "easyvdr-config-audio" $SETUP_STATUS	>> $SNDLOG
    grep "Audio_configured_for" $SETUP_STATUS	>> $SNDLOG
    echo "------------------------------ " 	>> $SNDLOG
}

#############################################################################
#  Ausblenden nicht aktiver HDMI-Sounddevices bei z.B. der GT210
DeActivateCodec()
{
    if [[ "$1" == "Einblenden" ]]; then
	echo "---> Alte /var/lib/alsa/asound.state sicherheitshalber loeschen.."  >> $SNDLOG
	rm -f /var/lib/alsa/asound.state
	rm -f /var/lib/alsa/asound.state.easyvdr
	if [ $( ps -C pulseaudio | grep -c pulseaudio ) != 0 ]; then
           pulseaudio -k > /dev/null 2>&1
           killall pulseaudio > /dev/null 2>&1
	fi
	#sudo rmmod snd-hda-intel
	if [[ -f /etc/modprobe.d/snd-hda-intel.conf ]]; then
	    sudo modprobe -r snd-hda-intel
	    echo "---> Ausgeblendete inaktive HDMI-codecs wieder einblenden.."  >> $SNDLOG
	    rm /etc/modprobe.d/snd-hda-intel.conf
	    sudo modprobe snd-hda-intel probe_mask=-1,-1,-1
	#else
	#    sudo modprobe snd-hda-intel
	fi

    else # Ausblenden
      if [ $(grep -c "snd_hda_intel" /proc/asound/modules) == $AnzKarten ]; then	#Ausblenden nur wenn alle Karten das snd_hda_intel-modul nutzen
	TCard=0
	TDevID=0
	SetMask=0
	CMask=0
	UnusedDev=0
	InactivDev=""
	ChangedDev=""
	PhysStreamID[0]=3
	PhysStreamID[1]=7
	PhysStreamID[2]=8
	PhysStreamID[3]=9
	for ((k=0;k<$AnzahlSndDev;k++)); do
	  if [[ "$(echo "${SndDevice["$k 0"]}" | cut -d":" -f 2 | cut -d"," -f 1)" != "$TCard" ]]; then # wenn aktuelles Device schon eine Karten-Nr. weiter:
	    (( ! $SetMask )) &&  CMask="-1"								# Leere Maske mit -1
	    [[ "$ProbeMask" == "" ]] && ProbeMask="$CMask" || ProbeMask="$ProbeMask,$CMask"		# Maske richtig zusammenbauen
	     SetMask=0											# Merker wieder ruecksetzen und Karten-Nr +1
	     CMask=0
	     TDevID=0
	     UnusedDev=0
	     ((TCard++))
	  fi
	    if [[ "${SndDevice["$k 9"]}" == "0" || "${SndDevice["$k 6"]}" == "OK" || \
		   $(echo $SndDeviceSelection | grep -c $k) != 0 ]]; then			# wenn aktiv, hoerbar oder ausgewaehlt
	      let addM=2**$TDevID								# entsprechendes Bit in der Maske setzen
	      let CMask=$CMask+$addM
	      if (( SetMask )); then
	        let ID=$TDevID-$UnusedDev							# ID verschieben
		SndDevice["$k 10"]="$(echo ${SndDevice["$k 0"]} | cut -d"," -f 1),${PhysStreamID[${ID}]}"
		ChangedDev="$ChangedDev $k"
	      fi
	    else										# andere codecs ausblenden
	      SetMask=1
	      ((UnusedDev++))
	      InactivDev="$InactivDev $k"
	      SndDevice["$k 10"]="$(echo ${SndDevice["$k 0"]} | cut -d"," -f 1),x"		# Dummy-ID
	    fi
	    ((TDevID++))
	done											# Zuletzt nochmal die Maske aktualisieren
	
	(( ! $SetMask ))         && CMask="-1"
	[[ "$ProbeMask" == "" ]] && ProbeMask="$CMask" || ProbeMask="$ProbeMask,$CMask"

	# Texte fuer Dialog und Log
	DevAltNeu=""
	DevUnused=""
	for k in $ChangedDev; do
	  DevAltNeu="$DevAltNeu ${SndDevice["$k 0"]} -> ${SndDevice["$k 10"]};"
	done
	for k in $InactivDev; do
	  DevUnused="$DevUnused ${SndDevice["$k 0"]}" #"
	done

	dialog --backtitle "$BACKTITLE"\
            --title "$TITLE"\
            --timeout $TIMEOUT2\
            --defaultno\
            --no-label " Nein, nicht Ausblenden "\
            --yes-label " Ja, Ausblenden "\
            --yesno "\n\n\
    Die inaktiven HDMI-Codecs [$DevUnused ] werden \n\
    durch erstellen der /etc/modprobe.d/snd-hda-intel.conf \n\
    dauerhaft ausgeblendet. \n\n\
    Damit aendert sich die Stream-ID der Schnittstellen:\n\
    [$DevAltNeu ] " $DIA_BOX2_SIZE
	OK_CANCEL=$?
	if (( $OK_CANCEL )); then
	  echo "  => Inaktive HDMI-codecs nicht ausblenden"          >> $SNDLOG
	else
          echo "  => Inaktive HDMI-codecs ausblenden:"               >> $SNDLOG
          echo "  -> Erstelle /etc/modprobe.d/snd-hda-intel.conf"    >> $SNDLOG
          echo "     Diese ist zu loeschen um alle HDMI-codecs wieder einzublenden"    >> $SNDLOG
	  echo "# ProbeMask zum ausmaskieren inaktiver HDMI-codecs " >  /etc/modprobe.d/snd-hda-intel.conf
	  echo "# autom. erstellt aus easyvdr-config-audio "         >> /etc/modprobe.d/snd-hda-intel.conf
	  echo " "                                                   >> /etc/modprobe.d/snd-hda-intel.conf
	  echo "options snd-hda-intel probe_mask=$ProbeMask "        >> /etc/modprobe.d/snd-hda-intel.conf

          echo "  -> Soundmodul entsprechend neu laden"              >> $SNDLOG
	  sudo rmmod snd-hda-intel
	  sudo modprobe snd-hda-intel probe_mask=$ProbeMask

          echo "  -> Stream IDs anpassen [$DevAltNeu ]"              >> $SNDLOG
	  for ((k=0;k<$AnzahlSndDev;k++)); do
	    SndDevice["$k 0"]="${SndDevice["$k 10"]}" #"
	  done
        fi
      fi
    fi
}
# Ende Ausblenden nicht aktiver HDMI-Sounddevices
#############################################################################

#############################################################################
# Liste der Sound-Devices erstellen
List_Sound_Device()
{
    Ausgabe_Karten=""
    i=0; k=0
    while [ $i != 10 ]; do
     if [ $(aplay -l 2> /dev/null | grep -c "$S_KARTE $i") != 0 ]; then
      Ausgabe_Karten="$Ausgabe_Karten $i"
      j=0
      while [ $j != 10 ]; do
        if [ $(aplay -l 2> /dev/null | grep "$S_KARTE $i" | grep -c "$S_DEVICE $j") != 0 ]; then
          SndDevice["$k 0"]="hw:$i,$j"												# hw:x,y
          SndDevice["$k 1"]=$(aplay -l 2> /dev/null | grep "$S_KARTE $i" | grep "$S_DEVICE $j" | sed "s/$S_KARTE $i: //g" | sed "s/ [.*]//g"\
        			| sed "s/ \[.*\], $S_DEVICE $j:/,/g" | sed "s/ \[.*\]//g" )						# Beschreibung
          SndDevice["$k 2"]="$S_KARTE $i"												# Karte x
          SndDevice["$k 3"]=$(aplay -l 2> /dev/null | grep "$S_KARTE $i" | grep "$S_DEVICE $j" | sed "s/$S_KARTE $i: //g" | cut -d" " -f1 )	# Kartenbez.
          SndDevice["$k 4"]="$S_DEVICE $j"												# Geraet Y
          SndDevice["$k 5"]=0 		# Anzahl der Kanaele mit 0 vorbelegen
          SndDevice["$k 6"]=".." 		# hier steht OK wenn Soundcheck erfolgreich
          SndDevice["$k 7"]="" 		# hier steht der erkannte Typ ( S/PDIF, HDMI oder Analog )
          SndDevice["$k 8"]="" 		# hier steht true/false je nach erkennung von AC-3
          SndDevice["$k 9"]=0			# Nicht Ausblenden 1 bedeutet Ausblenden
          SndDevice["$k 10"]="hw:$i,$j"	# angepasste Stream-ID wenn HDMI-codecs ausgeblendet werden
          ((k++))
	fi
	((j++))
      done
     fi
     ((i++))
    done
    AnzahlSndDev=$k
}
# Ende Liste der Sound-Devices erstellen
#############################################################################

#############################################################################
#  automatisch ausgefuehrte Konfiguration mit easy-alsa.sh
Auto_Easy_Alsa()
{
AmixerKarte="-c $1"
echo "---> Hier folgt die automatisch ausgefuehrte Konfiguration mit easy-alsa.sh fuer Karte $1:" >> $SNDLOG
echo "#! /bin/bash" > /tmp/easy-alsa.sh;
echo "     #! /bin/bash" >> $SNDLOG

#Controls mit Capability "pswitch":
ALL_MIX_PARA1=$(amixer $AmixerKarte |grep -A 1 "Simple mixer" |sed -e :a -e '$!N;s/\n / /;ta' -e 'P;D' |grep "Simple" |grep "pswitch" \
	                            |sed -r "s/Simple mixer control '/'/" |sed -r "s/  Capabilities.*$//"| sed -r "s/ /_/g" )

for MIX_PARA in $ALL_MIX_PARA1
  do 
    if [ "$(echo $MIX_PARA | grep "Master")" != "" ]
      then
        echo amixer $AmixerKarte -q set $MIX_PARA 100% unmute | sed s/_/\ /g >> /tmp/easy-alsa.sh
        echo "    " amixer $AmixerKarte -q set $MIX_PARA 100% unmute | sed s/_/\ /g >> $SNDLOG
      else
        if ( echo $MIX_PARA | grep -q -E "Mic|Beep|IEC958_In|IEC958_Loop|Line" )  
          then
            echo amixer $AmixerKarte -q set $MIX_PARA 0% mute | sed s/_/\ /g >> /tmp/easy-alsa.sh
            echo "    " amixer $AmixerKarte -q set $MIX_PARA 0% mute | sed s/_/\ /g >> $SNDLOG
          else
            echo amixer $AmixerKarte -q set $MIX_PARA 90% unmute | sed s/_/\ /g >> /tmp/easy-alsa.sh
            echo "    " amixer $AmixerKarte -q set $MIX_PARA 90% unmute | sed s/_/\ /g >> $SNDLOG
        fi
    fi
  done

#Controls mit Capability "volume" aber nicht "pswitch":
ALL_MIX_PARA2=$(amixer $AmixerKarte |grep -A 1 "Simple mixer" |sed -e :a -e '$!N;s/\n / /;ta' -e 'P;D' |grep "Simple" |grep -v "pswitch" \
            		            |grep -w "volume" |sed -r "s/Simple mixer control '/'/" |sed -r "s/  Capabilities.*$//"| sed -r "s/ /_/g" )

for MIX_PARA in $ALL_MIX_PARA2
  do 
    if [ "$(echo $MIX_PARA | grep "Mic")" != "" ]
      then
        echo amixer $AmixerKarte -q set $MIX_PARA 0% mute | sed s/_/\ /g >> /tmp/easy-alsa.sh
        echo "    " amixer $AmixerKarte -q set $MIX_PARA 0% mute | sed s/_/\ /g >> $SNDLOG
      else
        echo amixer $AmixerKarte -q set $MIX_PARA 90% unmute | sed s/_/\ /g >> /tmp/easy-alsa.sh
        echo "    " amixer $AmixerKarte -q set $MIX_PARA 90% unmute | sed s/_/\ /g >> $SNDLOG
    fi
  done

echo " " >> $SNDLOG
. /tmp/easy-alsa.sh
}
# Ende automatisch ausgefuehrte Konfiguration mit easy-alsa.sh
#############################################################################

#############################################################################
#  manuelle Konfiguration vom alsamixer
manuell_alsamixer()
{
    dialog --backtitle "$BACKTITLE"\
           --title "$TITLE"\
           --timeout $TIMEOUT2\
           --yes-label " Manuelle Konfiguration "\
           --no-label " nur Automatik (default) "\
           --defaultno\
           --yesno "\n\n\
          Die Sound-Ausgabe wurde automatisch voreingestellt.\n\n\
             Moechten sie jetzt noch von Hand zusaetzliche\n\
                Mic- und Capture-Devices einrichten ?" $DIA_BOX2_SIZE
    OK_CANCEL=$?
    clear

    if (( $OK_CANCEL == 0 ))
      then
        echo "  => Manuellen Alsamixer-Einstellungen vorgenommen,"  >> $SNDLOG
        echo "  ->  #   Starte fuer weitere manuelle Konfiguration alsamixer (alsamixer -V all)..                 #"  >> $SNDLOG
        echo "   >  #   Regler mit M entmuten, Bewegen mit den Pfeil-Tasten und den alsamixer mit ESC verlassen,  #" >> $SNDLOG
        echo "   >  #   Abschliessend Werte speichern mit \"alsactl store\"   #" >> $SNDLOG
#        echo "   >  #   Abschliessend Werte speichern mit \"alsactl -f /var/lib/alsa/asound.state.easyvdr store\"   #" >> $SNDLOG
        dialog --backtitle "$BACKTITLE"\
               --title "$TITLE"\
               --timeout $TIMEOUT2\
               --msgbox "\n\n\
        Zusaetzliche Konfiguration weiterer Sound-Einstellungen!\n\n\
          Regler mit M entmuten, Bewegen mit den Pfeil-Tasten\n\n\
           und bei mehreren Soundkarten diese mit F6 waehlen.\n\n\
             Abschliessend den alsamixer mit ESC verlassen!" $DIA_BOX2_SIZE
        clear
        alsamixer  -V all
      else
        echo "  => Keine manuellen Alsamixer-Einstellungen vorgenommen,"  >> $SNDLOG
        echo "  ->  #   Fuer spaetere individuelle Einstellungen alsamixer starten (alsamixer -V all),            #" >> $SNDLOG
        echo "   >  #   Regler mit M entmuten, Bewegen mit den Pfeil-Tasten und den alsamixer mit ESC verlassen,  #" >> $SNDLOG
        echo "   >  #   Abschliessend Werte speichern mit \"alsactl store\"   #" >> $SNDLOG
#        echo "   >  #   Abschliessend Werte speichern mit \"alsactl -f /var/lib/alsa/asound.state.easyvdr store\"   #" >> $SNDLOG
    fi
}
# Ende manuelle Konfiguration vom alsamixer
#############################################################################

#############################################################################
# Einsammeln der weiteren Schnittstellenparameter
#
Detect_Params()
{
    # Dazu die ELD auslesen

    VT_KONSOLE=$(fgconsole)         ## aktuell aktives Terminal
    if ( check_x_running ) >/dev/null 2>&1 ; then
      easyvdr-desktop stop >/dev/null 2>&1 ; sleep 2
    fi
    echo "Bitte warten!"
    echo "Versuche Soundparameter des angeschlossenen Monitors auszulesen."
    xFunktion="get-ELD"; TestDev=""
    export TestDev xFunktion
    startx "$SETUP/audio-setup/tools/x-functions"  --  $FRONTEND_DISPLAY >/dev/null 2>&1
    chvt $VT_KONSOLE

    #    $SETUP/audio-setup/tools/eldvalid-checker # alter Aufruf

    echo "---> Die erkannten Sound-Devices haben folgede Eigenschaften:"  >> $SNDLOG
	ParsePath="/tmp/asound"
    InactivHDMIcodecsExist=0
    for ((k=0;k<$AnzahlSndDev;k++)); do
        APLAY_INFO_1="$(aplay -l 2> /dev/null | grep "${SndDevice["$k 2"]}" | grep "${SndDevice["$k 4"]}" )" 
	if ( echo "$APLAY_INFO_1" | grep -q -E "Analog|DAC" ); then
	    # Ab hier nur fuer Sounddevices die als Analog erkannt wurden
	      SndDevice["$k 7"]="Analog"		#Tppe
	      SndDevice["$k 8"]="false"		#AC-3
	      SndDevice["$k 9"]=0			#Nicht Ausblenden
	    if [[ "$(aplay -L 2> /dev/null | grep -c "surround51:CARD=${SndDevice["$k 3"]}")" != "0" ]]; then
	      SndDevice["$k 5"]=6			#PCM-Channels
	    else
	      SndDevice["$k 5"]=2			#PCM-Channels
	    fi

	elif ( echo "$APLAY_INFO_1" | grep -q -E "Digital|IEC958|SPDIF" ); then
	    # Ab hier nur fuer Sounddevices die als SPDIF erkannt wurden
	      SndDevice["$k 7"]="S/PDIF"		#Tppe
	      SndDevice["$k 8"]="true "		#AC-3
	      SndDevice["$k 5"]=2			#PCM-Channels
	      SndDevice["$k 9"]=0			#Nicht Ausblenden

	elif ( echo "$APLAY_INFO_1" | grep -q -i hdmi ); then
	    # Ab hier nur fuer Sounddevices die als HDMI erkannt wurden
	      if [[ $(aplay -l 2> /dev/null | grep "${SndDevice["$k 2"]}" | grep -c HDMI) > 1 && \
	    	    $(aplay -l 2> /dev/null | grep "${SndDevice["$k 2"]}" | grep -c HDMI) == $(ls $ParsePath/${SndDevice["$k 3"]} | grep -c codec#) ]]; then
	        # Ab hier nur fuer Grafikkarten mit HDMI mit eld-Kennung und mehreren Codecs wie der GT210
	        j=0
		if [ ${SndDevice["$k 3"]} == "PCH" ]; then
	    	    # Bei Intel-HDMI-Codecs ist die eld-Nummerierung eld#X.Y 
	    	    #   wobei fuer X Werte von 2 oder 3 bekannt sind und Y die Nummerierung der PhysStreamID ist (z.B. 0 fuer ID=7 und 1 fuer ID=8):
		    #PhysStreamID="7 8"
	    	    #eldno="eld#3.jj"
	    	    # jetzt dynamisch - sicher nicht schoen aber tut:
		    PhysStreamID=$(grep "id: HDMI" $ParsePath/${SndDevice["$k 3"]}/pcm?p/info | cut -d: -f 1 | sed 's/p\/info//' | grep -oE "[^/]+$" | sed 's/pcm//' | tr "\n" " ")
		    EldID=$(ls $ParsePath/${SndDevice["$k 3"]}/eld* | sed 's/.*eld#//g' | tr "\n" " " | cut -d . -f 1)
		    eldno="eld#$EldID.jj"
		else
	    	    # Bei NVidia-HDMI-Codecs ist die eld-Nummerierung eld#X.Y 
	    	    #   wobei fuer Y der Wert von 0 ueblich ist und X die Nummerierung der PhysStreamID ist (z.B. 0 fuer ID=3 und 1 fuer ID=7, etc.):
	    	    PhysStreamID="3 7 8 9"
		    #PhysStreamID=$(grep "id: HDMI" $ParsePath/${SndDevice["$k 3"]}/pcm?p/info | cut -d: -f 1 | sed 's/p\/info//' | grep -oE "[^/]+$" | sed 's/pcm//' | tr "\n" " ")
	    	    eldno="eld#jj.0"
		fi
	        for i in $PhysStreamID; do
		  eld_no=${eldno/jj/$j}
	          if [[ "$(echo "${SndDevice["$k 0"]}" | cut -d"," -f2)" == "$i" ]]; then
#		    if [[ $(cat $ParsePath/${SndDevice["$k 3"]}/eld#$j.0 | grep "eld_valid" | grep -c "1") != 0 ]]; then
		    if [[ $(cat $ParsePath/${SndDevice["$k 3"]}/$eld_no | grep "eld_valid" | grep -c "1") != 0 ]]; then
#			eld_file="${SndDevice["$k 3"]}/eld#$j.0"
			eld_file="${SndDevice["$k 3"]}/$eld_no"
			SndDevice["$k 7"]="HDMI  "	#Tppe
		        SndDevice["$k 9"]=0		#Nicht Ausblenden
#			if [[ $(cat $ParsePath/${SndDevice["$k 3"]}/eld#$j.0 | grep sad  | grep "coding_type" | grep -c "AC-3") != 0 ]]; then
			if [[ $(cat $ParsePath/${SndDevice["$k 3"]}/$eld_no | grep sad  | grep "coding_type" | grep -c "AC-3") != 0 ]]; then
			  SndDevice["$k 8"]="true "	#AC-3
			else
			  SndDevice["$k 8"]="false"	#AC-3
			fi
#			if [[ $(cat $ParsePath/${SndDevice["$k 3"]}/eld#$j.0 | egrep -A 1 "_coding_type.*LPCM" | \
			if [[ $(cat $ParsePath/${SndDevice["$k 3"]}/$eld_no | egrep -A 1 "_coding_type.*LPCM" | \
				grep _channels | grep -c [68]) != 0 ]]; then #"
			    SndDevice["$k 5"]=6	#PCM-Channels
			else
			    SndDevice["$k 5"]=2	#PCM-Channels
			fi
	            else
			SndDevice["$k 7"]="HDMI ?"	#Tppe
		        SndDevice["$k 9"]=1		#Ausblenden
			SndDevice["$k 8"]="false"	#AC-3
			SndDevice["$k 5"]=2		#PCM-Channels
			InactivHDMIcodecsExist=1
	            fi
	          fi
	          ((j++))
	        done
	      elif [[ $(ls $ParsePath/${SndDevice["$k 3"]} | grep -c eld#*) != 0 ]]; then
	        # Ab hier nur fuer Grafikkarten mit HDMI mit eld-Kennung und einem Codec wie der GT520
		SndDevice["$k 7"]="HDMI  "		#Tppe
		SndDevice["$k 9"]=0			#Nicht Ausblenden
		eld_file="${SndDevice["$k 3"]}/eld#*"
		if [[ $(cat $ParsePath/${SndDevice["$k 3"]}/eld#* | grep sad  | grep "coding_type" | grep -c "AC-3") != 0 ]]; then
		    SndDevice["$k 8"]="true "		#AC-3
		else
		    SndDevice["$k 8"]="false"		#AC-3
		fi
		if [[ $(cat $ParsePath/${SndDevice["$k 3"]}/eld#* | egrep -A 1 "_coding_type.*LPCM" | \
			grep _channels | grep -c [68]) != 0 ]]; then #"
		    SndDevice["$k 5"]=6		#PCM-Channels
		else
		    SndDevice["$k 5"]=2		#PCM-Channels
		fi
	      else
	        # Ab hier nur fuer (OnBoard-)Grafikkarten mit HDMI aber ohne eld-Kennung
		SndDevice["$k 7"]="HDMI  "		#Tppe
		SndDevice["$k 9"]=0			#Nicht Ausblenden
		SndDevice["$k 8"]="???  "		#AC-3
		if [ $(speaker-test -c 6 -D "${SndDevice["$k 0"]}" -p 1 -s 6 -t wav 2>&1 | grep -c Bass) == 1 ]; then
		    SndDevice["$k 5"]=6		#PCM-Channels
		else
		    SndDevice["$k 5"]=2		#PCM-Channels
		fi
	      fi

	else
		# Ab hier fuer nicht aufgeloeste Anschluss-Typen
		SndDevice["$k 7"]="???   "		#Tppe
		SndDevice["$k 5"]=2			#PCM-Channels
		SndDevice["$k 9"]=0			#Nicht Ausblenden
		SndDevice["$k 8"]="???  "		#AC-3
	fi


	# Erkannte Informationen ins Log schreiben
	[[ ${SndDevice["$k 9"]} == 1 ]] && Ausbl="[Inaktiver HDMI-Codec]" || Ausbl=""
	echo "   > Device $k ${SndDevice["$k 0"]} (${SndDevice["$k 1"]}; ${SndDevice["$k 2"]}, ${SndDevice["$k 4"]}):\
 Type=${SndDevice["$k 7"]} PCM-${SndDevice["$k 5"]}-Channel AC-3=${SndDevice["$k 8"]} $Ausbl"  >> $SNDLOG #"

	if [[ ${SndDevice["$k 7"]} == "HDMI  " && $( grep "eld_valid" $ParsePath/$eld_file | grep -c "1") != 0 ]]; then
	    cat /tmp/asound/$eld_file | sed 's/^/\t/' >> $SNDLOG #"
	fi
    done
    rm -r -f /tmp/asound
}

# Ende Parametererkennung
#############################################################################

#############################################################################
# Sound-Check hilft bei der Auswahl der Ausgabe-Schnittstelle
#
SoundCheck()
{
# Test ob SND-Devices noch belegt sind 
# lsof |grep snd
# kill -TERM 8277
#
# oder
#
# cat /proc/modules|gawk '/^snd-/{print $1}'|xargs -i rmmod {}
# awk '/^snd/||/^sound/&&($3==0){system("rmmod " $1)}' /proc/modules /proc/modules /proc/modules
#
#
if [[ "$1" == "M" ]]; then
 Mini_Info "\
   \n \
   Kein Sound-Check fuer Multi-Device moeglich, \n \
   testen Sie zuerst die Devices separat..."
 sleep 3
 return 0
else
 TestDev="${SndDevice["${1} 0"]}" #"

    clear
    VT_KONSOLE=$(fgconsole)         ## aktuell aktives Terminal
    if ( check_x_running ) >/dev/null 2>&1 ; then
      easyvdr-desktop stop >/dev/null 2>&1 ; sleep 2
    fi
    echo "Sound-Check,"
    echo "Ausgabe von 200Hz und 600Hz Sinus ueber Kanaele vorne links & rechts"
    echo "von Sound-Device $TestDev"
    xFunktion="sound-check"
    export TestDev xFunktion
    startx "$SETUP/audio-setup/tools/x-functions"  --  $FRONTEND_DISPLAY >/dev/null 2>&1
    chvt $VT_KONSOLE

    # speaker-test -c 2 -D plug$TestDev -t sine -f 200 -l 1 > /dev/null
    # speaker-test -c 2 -D plug$TestDev -t sine -f 600 -l 1 > /dev/null

    # $SETUP/audio-setup/tools/sound-test "$TestDev" # Bisheriger Aufruf

 dialog --backtitle "$BACKTITLE"\
        --title "$TITLE"\
        --defaultno\
        --yesno "\n\n\
        War der Test-Ton ueber Device $TestDev zu hoeren ?" $DIA_BOX2_SIZE
   OK_CANCEL=$?
   if (( ! $OK_CANCEL )); then
        echo "   > Ausgabe ueber Device $1 ($TestDev) ist hoerbar"       >> $SNDLOG
        return 2
    else
        echo "   > Ausgabe ueber Device $1 ($TestDev) ist nicht hoerbar" >> $SNDLOG
        return 1
   fi
fi
clear
}
# Ende Sound-Check
#############################################################################

#############################################################################
# Channel-Check ermoeglicht eine abschliessende Ueberpruefung des Boxenlayouts
#
ChannelCheck()
{

# TestDev="${SndDevice["${1} 0"]}" #"

    clear
    VT_KONSOLE=$(fgconsole)         ## aktuell aktives Terminal
    if ( check_x_running ) >/dev/null 2>&1 ; then
      easyvdr-desktop stop >/dev/null 2>&1 ; sleep 2
    fi
    echo "Channel-Check,"
    echo "Ausgabe der Speaker-Bezeichnung ueber die jeweiligen Kanaele"
    xFunktion="channel-check"; TestDev="default"
    export TestDev xFunktion
    startx "$SETUP/audio-setup/tools/x-functions"  --  $FRONTEND_DISPLAY >/dev/null 2>&1
    chvt $VT_KONSOLE

# dialog --backtitle "$BACKTITLE"\
#        --title "$TITLE"\
#        --defaultno\
#        --yesno "\n\n\
#        War der Test-Ton ueber Device $TestDev zu hoeren ?" $DIA_BOX2_SIZE
#   OK_CANCEL=$?
#   if (( ! $OK_CANCEL )); then
#        echo "   > Ausgabe ueber Device $1 ($TestDev) ist hoerbar"       >> $SNDLOG
#        return 2
#    else
#        echo "   > Ausgabe ueber Device $1 ($TestDev) ist nicht hoerbar" >> $SNDLOG
#        return 1
#   fi

clear
}
# Ende Channel-Check
#############################################################################

#############################################################################
# Auswahl der Ausgabe-Schnittstelle
#
DeviceSelection()
{
    echo "---> SoundCheck und Auswahl der Devices fuer die Audio-Ausgabe:"  >> $SNDLOG
    unset Ausgabe_HW2
    if [ $AnzahlSndDev -gt 1 ]; then
      Ausgabe_HW2[0]="M"
      Ausgabe_HW2[1]="-> Multi: Ausgabe gleichzeitig ueber mehrere Devices"
    fi
    # Ausgabe_HW2[2]="keine"
    # Ausgabe_HW2[3]="keine Ausgabe-Hardware einstellen bzw. aendern"
    SELECTION_DONE=0
    ShowAlwaysAll=0
    while [ $SELECTION_DONE == 0 ]
     do
	l=0
	m=0
	HiddenExist=0
	unset Ausgabe_HW
        ShowAll=1
        OK_CANCEL=1
	for ((k=0;k<$AnzahlSndDev;k++)); do
          if [[ "${SndDevice["$k 9"]}" == "0" ]]; then	#"
            Ausgabe_HW[$l]="$k"; ((l++))
            Ausgabe_HW[$l]="${SndDevice["$k 6"]} ${SndDevice["$k 0"]}: ${SndDevice["$k 7"]} PCM-${SndDevice["$k 5"]}ch AC-3=${SndDevice["$k 8"]} (${SndDevice["$k 1"]})"; ((l++))
          else
            if (( ! ShowAlwaysAll )); then ShowAll=0; fi
          fi
            Ausgabe_HW_All[$m]="$k"; ((m++))
            Ausgabe_HW_All[$m]="${SndDevice["$k 6"]} ${SndDevice["$k 0"]}: ${SndDevice["$k 7"]} PCM-${SndDevice["$k 5"]}ch AC-3=${SndDevice["$k 8"]} (${SndDevice["$k 1"]})"; ((m++))
        done

        if (( ! $ShowAll )); then
	  SND_HW=$(dialog --title " $TITLE" \
		   --backtitle " $BACKTITLE" \
		   --ok-label " Device auswaehlen " \
		   --extra-button \
		   --extra-label " Device testen " \
		   --cancel-label "auch inaktive zeigen" \
		   --default-item "$SND_HW" \
		   --menu  "\n \
	  Es wurden folgende Ausgabe-Schnittstellen fuer den Sound gefunden,\n \
	  bitte waehlen Sie, ueber welche Hardware  \n \
	  (hw:x,y = Karte x, Geraet y) die Tonausgabe erfolgen soll. \n\n \
	  Ggf. kann ein Sound-Check bei der Auswahl helfen \n   " $DIA_BOX_SIZE \
  "${Ausgabe_HW[@]}" "${Ausgabe_HW2[@]}" 3>&1 1>&2 2>&3 3>&- )      # Index und Name im Menu
	  OK_CANCEL=$?
        fi
        if (( $OK_CANCEL == 1  || $ShowAll == 1 )); then
          ShowAll=1
          ShowAlwaysAll=1
	  SND_HW=$(dialog --title " $TITLE" \
		   --backtitle " $BACKTITLE" \
		   --ok-label " Device auswaehlen "\
		   --extra-button \
		   --extra-label " Device testen "\
		   --cancel-label "inaktive nicht zeigen" \
		   --default-item "$SND_HW" \
		   --menu  "\n \
	  Es wurden folgende Ausgabe-Schnittstellen fuer den Sound gefunden,\n \
	  bitte waehlen Sie, ueber welche Hardware  \n \
	  (hw:x,y = Karte x, Geraet y) die Tonausgabe erfolgen soll. \n\n \
	  Ggf. kann ein Sound-Check bei der Auswahl helfen \n   " $DIA_BOX_SIZE \
  "${Ausgabe_HW_All[@]}" "${Ausgabe_HW2[@]}" 3>&1 1>&2 2>&3 3>&- )      # Index und Name im Menu
	  OK_CANCEL=$?
	fi
        if (( $OK_CANCEL == 3 ))
	 then
	    #echo " ===> $SND_HW testen..."
	    SoundCheck $SND_HW
	    if [ "$?" -eq "2" ]; then
		SndDevice["${SND_HW} 6"]="OK"
	     elif [ "$?" -eq "1" ]; then
		SndDevice["${SND_HW} 6"]="--"
	     else
		SndDevice["${SND_HW} 6"]="->"
	    fi
         elif (( $OK_CANCEL == 1 ))
          then
    	    ShowAll=0
    	    ShowAlwaysAll=0
         else
	  if [[ $SND_HW == "M" ]]; then
	    echo "===> Multi-Tonausgabe ueber folgende Devices ausgewaehlt:" >> $SNDLOG
	    unset Ausgabe_HW_M
	    l=0
	    for ((k=0;k<$AnzahlSndDev;k++)); do
              if [[ "${SndDevice["$k 9"]}" == "0" || $ShowAll == 1 ]]; then	#"
                Ausgabe_HW_M[$l]="$k"; ((l++))
                Ausgabe_HW_M[$l]="${SndDevice["$k 6"]} ${SndDevice["$k 0"]}: ${SndDevice["$k 7"]} PCM-${SndDevice["$k 5"]}ch AC-3=${SndDevice["$k 8"]} (${SndDevice["$k 1"]})"; ((l++))
		if [[ ${SndDevice["$k 6"]} == "OK" ]]; then #"
	          Ausgabe_HW_M[$l]="on"; ((l++))
		else
	          Ausgabe_HW_M[$l]="off"; ((l++))
	        fi
              fi
            done
	    SND_HW=$(dialog --title " $TITLE" \
		   --backtitle " $BACKTITLE" \
		   --ok-label " Auswahl uebernehmen "\
		   --cancel-label " Zurueck "\
		   --checklist  "\n \
		Bitte waehlen Sie die Schnittstellen (maximal 2),   \n \
		ueber die die Tonausgabe gleichzeitig erfolgen soll.\n\n \
		( Auswahl per Leertaste ) \n " $DIA_BOX_SIZE \
  "${Ausgabe_HW_M[@]}" 3>&1 1>&2 2>&3 3>&- )      # Index und Name im Menu
	    OK_CANCEL=$?
	    if (( ! $OK_CANCEL )); then
	      if [[ $SND_HW != "" ]]; then
		SND_HW="$(echo $SND_HW | sed "s/\"//g")"
		SELECTION_DONE=1
	      fi
	    fi
	  else
	    echo "===> Einzel-Tonausgabe ueber folgende Audio-Devices ausgewaehlt:" >> $SNDLOG
	    SELECTION_DONE=1
	  fi
        fi
	clear
    done

    SndHW_Selection=" "
    for k in $SND_HW; do
	SndHW_Selection="$SndHW_Selection${SndDevice["$k 0"]} " #"
    done
    SndDeviceSelection=$SND_HW
    echo "  => Audio-Device $SndDeviceSelection ($SndHW_Selection)" >> $SNDLOG
}
# Ende Auswahl der Ausgabe-Schnittstelle
#############################################################################


#############################################################################
# Abfrage PassThroughDevice
#
SelectPassThroughDevice()
{
    unset Ausgabe_HW_P
    l=0
    DigDev=" "
    MaxChanNo=2
    for k in $SndDeviceSelection; do	# Nur unter den ausgewaehlten Kanalzahl und PassThrough-Device bestimmen
      if [[ "${SndDevice["$k 5"]}" == "6" ]]; then #"
	MaxChanNo=6
      fi
      if [[ "${SndDevice["$k 8"]}" != "false" ]]; then #"
        DigDev="$DigDev$k "
        Ausgabe_HW_P[$l]="$k"; ((l++))
        Ausgabe_HW_P[$l]="${SndDevice["$k 6"]} ${SndDevice["$k 0"]}: ${SndDevice["$k 7"]} AC-3=${SndDevice["$k 8"]} (${SndDevice["$k 1"]})"; ((l++)) #"
      fi
    done
    if (( ! $l )); then
	echo "---> Keine digitale Tonausgabe ueber Device [$SndDeviceSelection] moeglich => Defaultwert fuer die Tonausgabe (PassThrough) eingetragen" >> $SNDLOG
	SND_HW_PassThrough="None"
    else
	echo "---> PassThroughDevice unter den Devices [$DigDev] auswaehlen"  >> $SNDLOG
	SND_HW_PassThrough=$(dialog --title " $TITLE" \
		   --backtitle " $BACKTITLE" \
		   --ok-label " Auswahl einstellen " \
		   --cancel-label " keine => Defaultwert "\
		   --menu  "\n \
	Welche der Ausgabe-Schnittstellen soll als \n \
	PassThrough-Device fuer die Ausgabe von DolbyDigital\n \
	eingestellt werden ? \n   " $DIA_BOX_SIZE \
	"${Ausgabe_HW_P[@]}" 3>&1 1>&2 2>&3 3>&- )      # Index und Name im Menu
	OK_CANCEL=$?
	if (( ! $OK_CANCEL )); then
	    echo "===> Device $SND_HW_PassThrough (${SndDevice["${SND_HW_PassThrough} 0"]}) fuer die Tonausgabe (PassThrough) ausgewaehlt" >> $SNDLOG #"
	else
	    echo "===> Defaultwert an Stelle von [$DigDev] fuer die Tonausgabe (PassThrough) ausgewaehlt" >> $SNDLOG
	    SND_HW_PassThrough="None"
	fi
    fi
    clear

    # Fuer alle weiteren Einstellungen das PassThrough-Device vom Namen her ermitteln:
    if [[ $SND_HW_PassThrough != "None" ]]; then
        if [[ "${SndDevice["${SND_HW_PassThrough} 7"]}" == "HDMI  " || "${SndDevice["${SND_HW_PassThrough} 7"]}" == "HDMI ?" ]]; then
		DevNo=$(aplay -l 2> /dev/null | grep "${SndDevice["${SND_HW_PassThrough} 3"]} " | grep HDMI | grep -n "${SndDevice["${SND_HW_PassThrough} 3"]}" | \
			grep "${SndDevice["${SND_HW_PassThrough} 2"]}" | grep "${SndDevice["${SND_HW_PassThrough} 4"]}" | cut -d":" -f1)
		SND_Dev_PassThrough=$(aplay -L 2> /dev/null | grep "hdmi:CARD=${SndDevice["${SND_HW_PassThrough} 3"]}," | grep -n hdmi | grep "$DevNo:" | cut -b 3- )
        elif [[ "${SndDevice["${SND_HW_PassThrough} 7"]}" == "S/PDIF" ]]; then #"
		SND_Dev_PassThrough=$(aplay -L 2> /dev/null | grep "CARD=${SndDevice["${SND_HW_PassThrough} 3"]}," | grep iec958)
        else
		SND_Dev_PassThrough=${SndDevice["${SND_HW_PassThrough} 0"]} #"
        fi
    else
      SND_Dev_PassThrough="None"
    fi

}
# Ende SelectPassThroughDevice
#############################################################################

#############################################################################
# Erstellen einer passenden asound.conf fuer die Ausgabe ueber mehrere Devices
#
Write_AsoundConf_cx()
{
    AsoundConf="/etc/asound.conf.autogen_c$1"

    echo "# $AsoundConf"                                             >  $AsoundConf
    echo "# File generated by easyvdr-config-audio"                  >> $AsoundConf
    echo "# for up to $1 Channels per device"                        >> $AsoundConf
    echo "#"                                                         >> $AsoundConf
    echo "pcm.!default    {"                                         >> $AsoundConf
    echo "		type plug"                                   >> $AsoundConf
    echo "		slave   {"                                   >> $AsoundConf
    echo "			pcm multi"                           >> $AsoundConf
    echo "			rate 48000"                          >> $AsoundConf
    echo "			}"                                   >> $AsoundConf

    AllChan=0
    Out=1
    for k in $SndDeviceSelection; do
      Chan=0
      while [ $Chan -lt ${SndDevice["$k 5"]} ]
        do
          echo "		ttable.$Chan.$AllChan 1.0"           >> $AsoundConf
          ((Chan++)); ((AllChan++))
          [[ $Chan -ge $1 ]] && Chan=${SndDevice["$k 5"]}
        done
      ((Out++))
    done
    echo "		}"                                           >> $AsoundConf
    echo ""                                                          >> $AsoundConf
    echo "pcm.multi       {"                                         >> $AsoundConf
    echo "		type multi"                                  >> $AsoundConf
    Out=1
    for k in $SndDeviceSelection; do
	[ $Out == 1 ] && OutA="a"
	[ $Out == 2 ] && OutA="b"
	[ $Out == 3 ] && OutA="c"
	[ $Out == 4 ] && OutA="d"
	[ $Out == 5 ] && OutA="e"
	[ $Out == 6 ] && OutA="f"
        echo "		slaves.$OutA.pcm {  type hw "                >> $AsoundConf
        echo "				card \"${SndDevice["$k 3"]}\"" 				>> $AsoundConf	#"
        echo "				device $(echo ${SndDevice["$k 0"]} | cut -d"," -f2 ) }"	>> $AsoundConf
        if [[ $1 < ${SndDevice["$k 5"]} ]]; then #"
         echo "		slaves.$OutA.channels $1"                    >> $AsoundConf
        else
         echo "		slaves.$OutA.channels ${SndDevice["$k 5"]}">> $AsoundConf	#"
        fi
        ((Out++))
    done
    echo ""                                                          >> $AsoundConf
    AllChan=0
    Out=1
    for k in $SndDeviceSelection; do
      Chan=0
	[ $Out == 1 ] && OutA="a"
	[ $Out == 2 ] && OutA="b"
	[ $Out == 3 ] && OutA="c"
	[ $Out == 4 ] && OutA="d"
	[ $Out == 5 ] && OutA="e"
	[ $Out == 6 ] && OutA="f"
      while [ $Chan -lt ${SndDevice["$k 5"]} ]
        do
          echo "		bindings.$AllChan.slave $OutA"               >> $AsoundConf
          echo "		bindings.$AllChan.channel $Chan"             >> $AsoundConf
          ((Chan++)); ((AllChan++))
          [ $Chan -ge $1 ] && Chan=${SndDevice["$k 5"]}
        done
      ((Out++))
    done
    echo "		}"                                           >> $AsoundConf
    echo ""                                                          >> $AsoundConf
    echo "ctl.multi { type hw }"                                     >> $AsoundConf

    chmod 755 $AsoundConf

}
#############################################################################

#############################################################################
# Erstellen einer passenden asound.conf mit dmix fuer die Ausgabe ueber mehrere Devices
#
Write_AsoundConf_cx_dmix()
{
    AsoundConf="/etc/asound.conf.autogen_c$1.dmix"

    echo "# $AsoundConf"                                             >  $AsoundConf
    echo "# File generated by easyvdr-config-audio"                  >> $AsoundConf
    echo "# for up to $1 Channels per device"                        >> $AsoundConf
    echo "# and downmix from 6 Channels for each device"             >> $AsoundConf
    echo "#"                                                         >> $AsoundConf
    echo "pcm.!default    {"                                         >> $AsoundConf
    echo "		type plug"                                   >> $AsoundConf
    echo "		slave   {"                                   >> $AsoundConf
    echo "			pcm multi"                           >> $AsoundConf
    echo "			rate 48000"                          >> $AsoundConf
    echo "			}"                                   >> $AsoundConf

    AllChan=0
    Out=1
    for k in $SndDeviceSelection; do
      Chan=0
      while [ $Chan -lt ${SndDevice["$k 5"]} ]; do	#"
        echo "		ttable.$Chan.$AllChan 1.0"                   >> $AsoundConf
        ((Chan++)); ((AllChan++))
        if [[ $Chan -ge $1 || $Chan -ge ${SndDevice["$k 5"]} ]]; then #"
    	    AllChan=$AllChan-3
    	    if [[ $Chan -eq 2 ]]; then
    		((AllChan++))
    		echo "		ttable.$Chan.$AllChan 0.707  # hinten links -> links, Daempfung 3dB"    >> $AsoundConf
    		((Chan++)); ((AllChan++))
    		echo "		ttable.$Chan.$AllChan 0.707  # hinten rechts -> rechts, Daempfung 3dB"  >> $AsoundConf
    		((Chan++))
    	    fi
    	    if [[ $Chan -eq 4 ]]; then
    		((AllChan--))
    		echo "		ttable.$Chan.$AllChan 0.5    # zentrum -> links, Daempfung 6dB"         >> $AsoundConf
    		((AllChan++))
    		echo "		ttable.$Chan.$AllChan 0.5    # zentrum -> rechts, Daempfung 6dB"        >> $AsoundConf
    		((Chan++)); ((AllChan--))
    		echo "		ttable.$Chan.$AllChan 0.5    # basskanal -> links, Daempfung 6dB"       >> $AsoundConf
    		((AllChan++))
    		echo "		ttable.$Chan.$AllChan 0.5    # basskanal -> rechts, Daempfung 6dB"      >> $AsoundConf
    		((AllChan++))
    	    fi
    	    if [[ $1 -eq 4 && ${SndDevice["$k 5"]} -ge 4 ]]; then #"
    		((AllChan++)); ((AllChan++))
    	    fi
    	    Chan=${SndDevice["$k 5"]} #"
    	    if [[ $1 -eq 6 && ${SndDevice["$k 5"]} -ge 4 ]]; then #"
    		((AllChan++)); ((AllChan++)); ((AllChan++))
    	    fi
        fi
      done
      ((Out++))
    done
    echo "		}"                                           >> $AsoundConf
    echo ""                                                          >> $AsoundConf
    echo "pcm.multi       {"                                         >> $AsoundConf
    echo "		type multi"                                  >> $AsoundConf
    Out=1
    for k in $SndDeviceSelection; do
	[ $Out == 1 ] && OutA="a"
	[ $Out == 2 ] && OutA="b"
	[ $Out == 3 ] && OutA="c"
	[ $Out == 4 ] && OutA="d"
	[ $Out == 5 ] && OutA="e"
	[ $Out == 6 ] && OutA="f"
        echo "		slaves.$OutA.pcm {  type hw "                >> $AsoundConf
        echo "				card \"${SndDevice["$k 3"]}\"" 				>> $AsoundConf	#"
        echo "				device $(echo ${SndDevice["$k 0"]} | cut -d"," -f2 ) }"	>> $AsoundConf
        if [[ $1 < ${SndDevice["$k 5"]} ]]; then #"
         echo "		slaves.$OutA.channels $1"                    >> $AsoundConf
        else
         echo "		slaves.$OutA.channels ${SndDevice["$k 5"]}">> $AsoundConf	#"
        fi
        ((Out++))
    done
    echo ""                                                          >> $AsoundConf
    AllChan=0
    Out=1
    for k in $SndDeviceSelection; do
      Chan=0
	[ $Out == 1 ] && OutA="a"
	[ $Out == 2 ] && OutA="b"
	[ $Out == 3 ] && OutA="c"
	[ $Out == 4 ] && OutA="d"
	[ $Out == 5 ] && OutA="e"
	[ $Out == 6 ] && OutA="f"
      while [ $Chan -lt ${SndDevice["$k 5"]} ]
        do
          echo "		bindings.$AllChan.slave $OutA"               >> $AsoundConf
          echo "		bindings.$AllChan.channel $Chan"             >> $AsoundConf
          ((Chan++)); ((AllChan++))
          [ $Chan -ge $1 ] && Chan=${SndDevice["$k 5"]}
        done
      ((Out++))
    done
    echo "		}"                                           >> $AsoundConf
    echo ""                                                          >> $AsoundConf
    echo "ctl.multi { type hw }"                                     >> $AsoundConf

    chmod 755 $AsoundConf
}
#############################################################################

Write_AsoundConf_multi()
{
    echo "# File generated by easyvdr-config-audio"                  >  /etc/asound.conf.autogen_multi
    echo "# for up to 2 Channels per device, multi-source"           >> /etc/asound.conf.autogen_multi
    echo "#"                                                         >> /etc/asound.conf.autogen_multi
    echo "pcm.!default    {"                                         >> /etc/asound.conf.autogen_multi
    echo "		type plug"                                   >> /etc/asound.conf.autogen_multi
    echo "		slave   {"                                   >> /etc/asound.conf.autogen_multi
    echo "			pcm multi"                           >> /etc/asound.conf.autogen_multi
    echo "			rate 48000"                          >> /etc/asound.conf.autogen_multi
    echo "			}"                                   >> /etc/asound.conf.autogen_multi

    AllChan=0
    Out=1
    for k in $SndDeviceSelection; do
      Chan=0
      while [ $Chan -lt 2 ]; do
        echo "		ttable.$Chan.$AllChan 1.0"                   >> /etc/asound.conf.autogen_multi
        ((Chan++)); ((AllChan++))
      done
      ((Out++))
    done
    echo "		}"                                           >> /etc/asound.conf.autogen_multi
    echo ""                                                          >> /etc/asound.conf.autogen_multi
    echo "pcm.multi       {"                                         >> /etc/asound.conf.autogen_multi
    echo "		type multi"                                  >> /etc/asound.conf.autogen_multi
    Out=1; Key=1024
    for k in $SndDeviceSelection; do
	[ $Out == 1 ] && OutA="a"
	[ $Out == 2 ] && OutA="b"
	[ $Out == 3 ] && OutA="c"
	[ $Out == 4 ] && OutA="d"
	[ $Out == 5 ] && OutA="e"
	[ $Out == 6 ] && OutA="f"
        echo "		slaves.$OutA.pcm {  type dmix "              >> /etc/asound.conf.autogen_multi
        echo "				ipc_key $Key "               >> /etc/asound.conf.autogen_multi
        echo "				ipc_perm 0666 "              >> /etc/asound.conf.autogen_multi
        echo "				slave  { pcm {  type hw "    >> /etc/asound.conf.autogen_multi
        echo "						card \"${SndDevice["$k 3"]}\"" 				>> /etc/asound.conf.autogen_multi	#"
        echo "						device $(echo ${SndDevice["$k 0"]} | cut -d"," -f2 ) }"	>> /etc/asound.conf.autogen_multi
        echo "					period_time 0 "      >> /etc/asound.conf.autogen_multi
        echo "					period_size 1024 "   >> /etc/asound.conf.autogen_multi
        echo "					buffer_size 4096 "   >> /etc/asound.conf.autogen_multi
        echo "					rate 48000 "         >> /etc/asound.conf.autogen_multi
        echo "					channels 2 } "       >> /etc/asound.conf.autogen_multi
        echo "				} "                          >> /etc/asound.conf.autogen_multi
        echo "		slaves.$OutA.channels 2"                     >> /etc/asound.conf.autogen_multi
        ((Out++)); ((Key++))
    done
    echo ""                                                          >> /etc/asound.conf.autogen_multi
    AllChan=0
    Out=1
    for k in $SndDeviceSelection; do
      Chan=0
	[ $Out == 1 ] && OutA="a"
	[ $Out == 2 ] && OutA="b"
	[ $Out == 3 ] && OutA="c"
	[ $Out == 4 ] && OutA="d"
	[ $Out == 5 ] && OutA="e"
	[ $Out == 6 ] && OutA="f"
      while [ $Chan -lt 2 ]; do
        echo "		bindings.$AllChan.slave $OutA"               >> /etc/asound.conf.autogen_multi
        echo "		bindings.$AllChan.channel $Chan"             >> /etc/asound.conf.autogen_multi
        ((Chan++)); ((AllChan++))
      done
      ((Out++))
    done
    echo "		}"                                           >> /etc/asound.conf.autogen_multi
    echo ""                                                          >> /etc/asound.conf.autogen_multi
    echo "ctl.multi { type hw }"                                     >> /etc/asound.conf.autogen_multi

    chmod 755 /etc/asound.conf.autogen_multi

}
# Ende Write_AsoundConfs
#############################################################################

#############################################################################
# Anzahl der Ausgabekanaele Auswaehlen
#
Set_Anz_Channels()
{
    unset Ausgabe_Chan
#    Ausgabe_Chan[0]="Mono 1.0";		Ausgabe_Chan[1]="Alles Audiomaterial in Mono ausgegeben"
#    Ausgabe_Chan[2]="Stereo 2.0";	Ausgabe_Chan[3]="Audiomaterial in Stereo ausgegeben"
#    if [[ "$SND_HW_PassThrough" != "None" || "$MaxChanNo" == "6" ]]; then
#      Write_AsoundConf_cx 6     # fuer max 6-Kanaele
#      Write_AsoundConf_cx_dmix 4 #fuer 4-Kanaele mit Downmix von 6ch
#      Write_AsoundConf_cx_dmix 6 #fuer 6-Kanaele mit Downmix von 6ch wenn erforderlich
#      echo "---> asound.conf.autogen (6ch) erstellt" >> $SNDLOG
#      Ausgabe_Chan[4]="Surround 4.0";	Ausgabe_Chan[5]="Surround-Material auf bis zu 4 Kanaelen ausgeben"
#      Ausgabe_Chan[6]="Surround 5.1";	Ausgabe_Chan[7]="Surround-Material auf bis zu 6 Kanaelen ausgeben"
#      if [[ "$SND_HW_PassThrough" != "None" ]]; then
#       Ausgabe_Chan[8]="Pass Through";	Ausgabe_Chan[9]="Wie 5.1, DolbyDigital-Material aber direkt an ${SndDevice["${SND_HW_PassThrough} 7"]}" #"
#      fi
#    fi
    if [[ "$SND_HW_PassThrough" != "None" || "$MaxChanNo" == "6" ]]; then
	Ausgabe_Chan[0]="Stereo 2.0";	Ausgabe_Chan[1]="Audiomaterial in Stereo ausgegeben"
          if [[ "$SND_HW_PassThrough" != "None" ]]; then
    	    Ausgabe_Chan[2]="PassThrough20";	Ausgabe_Chan[3]="Wie 2.0, DolbyDigital-Material aber direkt an ${SndDevice["${SND_HW_PassThrough} 7"]}" #"
	    if [[ "$MaxChanNo" == "6" ]]; then
    	      Ausgabe_Chan[4]="Surround 4.0";	Ausgabe_Chan[5]="Surround-Material auf bis zu 4 Kanaelen ausgeben"
    	      Ausgabe_Chan[6]="PassThrough40";	Ausgabe_Chan[7]="Wie 4.0, DolbyDigital-Material aber direkt an ${SndDevice["${SND_HW_PassThrough} 7"]}" #"
	      Ausgabe_Chan[8]="Surround 5.1";	Ausgabe_Chan[9]="Surround-Material auf bis zu 6 Kanaelen ausgeben"
    	      Ausgabe_Chan[10]="PassThrough51";	Ausgabe_Chan[11]="Wie 5.1, DolbyDigital-Material aber direkt an ${SndDevice["${SND_HW_PassThrough} 7"]}" #"
	    fi
	  else
	    #if [[ "$MaxChanNo" == "6" ]]; then
    	      Ausgabe_Chan[2]="Surround 4.0";	Ausgabe_Chan[3]="Surround-Material auf bis zu 4 Kanaelen ausgeben"
	      Ausgabe_Chan[4]="Surround 5.1";	Ausgabe_Chan[5]="Surround-Material auf bis zu 6 Kanaelen ausgeben"
	    #fi
	  fi
      SelectChannelNo=$(dialog --title " $TITLE" \
		   --backtitle " $BACKTITLE" \
		   --ok-label " Einstellung uebernehmen " \
		   --default-item "Stereo 2.0" \
		   --no-cancel \
		   --menu  "\n \n \n\
	        Welches Boxenlayout soll eingestellt werden ? \n\n " $DIA_BOX_SIZE \
	"${Ausgabe_Chan[@]}"  3>&1 1>&2 2>&3 3>&- )
	SpeakerLayout=$SelectChannelNo
        case $SelectChannelNo in
          "PassThrough20") SpeakerLayout="2.0/Pass Through"
	                   SelectChannelNo="Pass Through"   ;;
          "PassThrough40") SpeakerLayout="4.0/Pass Through"
	                   SelectChannelNo="Pass Through"   ;;
          "PassThrough51") SpeakerLayout="5.1/Pass Through"
	                   SelectChannelNo="Pass Through"   ;;
        esac 
	echo "===> $SpeakerLayout als Boxenlayout ausgewaehlt" >> $SNDLOG
    else
	SelectChannelNo="Stereo 2.0"
	SpeakerLayout=$SelectChannelNo
	echo "---> $SpeakerLayout automatisch als Boxenlayout eingestellt" >> $SNDLOG
    fi
      clear
}
# Ende Kanalzahl festlegen
#############################################################################

#############################################################################
# Asound.conf erstellen und passende verlinken
#
Generate_Link_Asound()
{
      echo "---> erforderliche asound.confs erstellen..." >> $SNDLOG
      Write_AsoundConf_cx 2        # fuer max 2-Kanaele
      Write_AsoundConf_cx_dmix 2   # fuer 2-Kanaele mit Downmix von 6ch
      Write_AsoundConf_multi       # fuer 2-Kanaele Multi-Source
      if [[ "$MaxChanNo" == "6" ]]; then
        echo "  -> asound.conf.autogen (2ch und multi) als Fallback erstellt" >> $SNDLOG
        Write_AsoundConf_cx 6      # fuer max 6-Kanaele
        Write_AsoundConf_cx_dmix 4 # fuer max 4-Kanaele mit Downmix von 6ch
        Write_AsoundConf_cx_dmix 6 # fuer max 6-Kanaele mit Downmix von 6ch wo erforderlich
        echo "  -> asound.conf.autogen (6ch) erstellt" >> $SNDLOG
      else
        echo "  -> asound.conf.autogen (2ch und multi) erstellt" >> $SNDLOG
      fi

      if [ -e /etc/asound.conf ]; then
         [ -L /etc/asound.conf ] && rm -f /etc/asound.conf || mv /etc/asound.conf /etc/asound.conf.SIK
      fi
#	if [[ "$SelectChannelNo" == "Mono 1.0" || "$SelectChannelNo" == "Stereo 2.0" ]]; then
#	    ln -s /etc/asound.conf.autogen_c2 /etc/asound.conf
#	    echo "  -> asound.conf.autogen_c2 als asound.conf verlinkt" >> $SNDLOG
#	else
#	    ln -s /etc/asound.conf.autogen_c6 /etc/asound.conf
#	    echo "  -> asound.conf.autogen_c6 als asound.conf verlinkt" >> $SNDLOG
#	fi
	if [[ "$SpeakerLayout" == "Stereo 2.0" || "$SpeakerLayout" == "2.0/Pass Through" || "$MaxChanNo" == "2" ]]; then
	    ln -s /etc/asound.conf.autogen_c2.dmix /etc/asound.conf
	    echo "  -> asound.conf.autogen_c2.dmix als asound.conf verlinkt" >> $SNDLOG
	elif [[ "$SpeakerLayout" == "Surround 4.0" || "$SpeakerLayout" == "4.0/Pass Through" ]]; then
	    ln -s /etc/asound.conf.autogen_c4.dmix /etc/asound.conf
	    echo "  -> asound.conf.autogen_c4.dmix als asound.conf verlinkt" >> $SNDLOG
	else
	    ln -s /etc/asound.conf.autogen_c6.dmix /etc/asound.conf
	    echo "  -> asound.conf.autogen_c6.dmix als asound.conf verlinkt" >> $SNDLOG
	fi

}
# Ende asound.conf verlinken
#############################################################################

#############################################################################
# Hier folgen noch einige weitere optionale (Experten) Einstellungen
#
Weitere_Einstellungen()
{
PulseAudio_Default="Off"
DoChannelCheck="False"

dialog --backtitle "$BACKTITLE"\
       --title "$TITLE"\
       --timeout $TIMEOUT2\
       --yes-label " Weitere Einstellungen "\
       --no-label " Konfiguration abschliessen "\
       --defaultno\
       --yesno "\n\n\
    Normalerweise ist die Konfiguration der Audio-Ausgabe fertig,\n\n\
      weitere (Experten-) Einstellungen koennen aber auf Wunsch\n\
            in den folgenden Dialogen vorgenommen werden.\n\n\
                        Dazu gehoeren:\n\n\
             Pulseaudio, Alsamixer, Surroundkanal-Check, \n\
             Codecs ausblenden, Logfile bereinigen..." $DIA_BOX2_SIZE
OK_CANCEL=$?
clear

if (( $OK_CANCEL == 0 ))
  then
    echo "===> Weitere (Experten-) Einstellungen:"  >> $SNDLOG

    ###  Inaktive HDMI-codecs ausblenden
    if [[ $InactivHDMIcodecsExist == 1 ]]; then
      DeActivateCodec Ausblenden
    fi

    ### Pulseaudio per default aus oder an
    # evtl. noch alten Wert uebernehmen
    dialog --backtitle "$BACKTITLE"\
       --timeout $TIMEOUT\
       --defaultno\
       --yesno "\n\n\
            Pulseaudio an Stelle der normalen \n\
        Audiokunfiguration ueber Alsa verwenden?" $DIA_BOX2_SIZE
    Def_Pulse=$?
    clear
    if [ $Def_Pulse == 0 ]; then
       PulseAudio_Default="On"
    else
       PulseAudio_Default="Off"
    fi
    # parameter in setup-state schreiben


    ### Nacharbeit am Alsamixer, wenn gewuenscht
    manuell_alsamixer
    alsactl store 2> /dev/null
    alsactl -f /var/lib/alsa/asound.state.easyvdr store 2> /dev/null

    ### Optional zum Abschluss noch Boxenlayout ueberpruefen?
    dialog --backtitle "$BACKTITLE"\
       --timeout $TIMEOUT\
       --defaultno\
       --yesno "\n\n\
        Soll ganz zum Ende der Audio-Konfiguration \n\
    ein Kanal-Test der Lautsprecheranschluesse erfolgen?" $DIA_BOX2_SIZE
    CheckChannels=$?
    clear
    if [ $CheckChannels == 0 ]; then
       DoChannelCheck="True"
    else
       DoChannelCheck="False"
    fi

    ### Loesche alte Teile des Logfiles von config-audio
    dialog --backtitle "$BACKTITLE"\
           --title "$TITLE"\
           --timeout $TIMEOUT2\
           --yes-label " Logfile bereinigen "\
           --no-label " Logfile nicht veraendern "\
           --defaultno\
           --yesno "\n\n\
    Logfile Bereinigen loescht aus der easyvdr-config-audio.log \n\n\
         alle Eintraege frueherer Konfigurationen..." $DIA_BOX2_SIZE
    OK_CANCEL=$?
    clear
    if (( $OK_CANCEL == 0 ))
      then
        echo "  => Logfile bereinigen"  >> $SNDLOG
        cp $SNDLOG /tmp/audio.log
        LineNumber=$(egrep -n "============================================================" $SNDLOG | tail -1 | cut -d":" -f1)
        let LineNumber=$LineNumber-1
        echo "`date` Aeltere Eintraege geloescht" > $SNDLOG
        awk "NR==$LineNumber,EOF" /tmp/audio.log >> $SNDLOG
    fi
    ### Force Channel-No & AC3
fi
}

# Ende weitere Einstellungen
#############################################################################


#############################################################################
# Setzen der globalen Soundparameter
#
#
Set_GlobalSoundParams()
{
    echo "---> Allgemeine Parameter in der setup.conf werden eingestellt ..." >> $SNDLOG
    #if [[ $SND_HW_PassThrough == "None" ]]; then
    #  SetSetupConf UseDolbyDigital 				0
    #else
      SetSetupConf UseDolbyDigital 				1
    #fi
}
# Ende von SetGlobalParams
#############################################################################


#############################################################################
# Hardware-Abhaengiges Auswaehlen und Konfigurieren der Soundausgabe
Config_Sound_HW()
{
case $easyvdr_video_out in
    dvbsd)      Config_Sound_dvbsd;;
    dvbhd)      Config_Sound_dvbhd;;
    ehd)        Config_Sound_ehd;;
    pvr350)     Config_Sound_pvr350;;
    x)          Config_Sound_X;;
    nvidia)     Config_Sound_X;;
    ati)        Config_Sound_X;;
    intel)      Config_Sound_X;;
    standard-x) Config_Sound_X;;
    *)      echo " $easyvdr_video_out - Unbekanntes, noch nicht erfasstes Ausgabegeraet. " >> $SNDLOG;;
esac
}
# Hier folgen noch detailierte Einstellungen fuer die einzelnen Ausgabe-Varianten
Config_Sound_dvbsd()
{
if [ "x$NON_X11_and_X11" == "xtrue" ]; then
    echo "---> Die Sound- und Videoausgabe erfolgt ueber SD-FullFeatured-Karte, dafuer ist bei alsa nichts zu tun," >> $SNDLOG
    echo "     zusaetzlich ist ein Desktop fuer weitere Funktionen aktiviert, daher muss alsa eingerichtet werden..." >> $SNDLOG
    Config_Sound_X
else
    echo "---> Die Sound- und Videoausgabe erfolgt ueber SD-FullFeatured-Karte, fuer alsa ist nichts zu tun!" >> $SNDLOG
fi
}
############################
Config_Sound_dvbhd()
{
if [ "x$NON_X11_and_X11" == "xtrue" ]; then
    echo "---> Die Sound- und Videoausgabe erfolgt ueber HD-FullFeatured-Karte, dafuer ist bei alsa nichts zu tun," >> $SNDLOG
    echo "     zusaetzlich ist ein Desktop fuer weitere Funktionen aktiviert, daher muss alsa eingerichtet werden..." >> $SNDLOG
    Config_Sound_X
else
    echo "---> Die Sound- und Videoausgabe erfolgt ueber HD-FullFeatured-Karte, fuer alsa ist nichts zu tun!" >> $SNDLOG
fi
}
############################
Config_Sound_ehd()
{
echo "---> Die Sound- und Videoausgabe erfolgt ueber die reel eHD, fuer alsa ist nichts zu tun!" >> $SNDLOG
}
############################
Config_Sound_X()
{
pulseaudio -D > /dev/null 2>&1
echo " "                               >> $SNDLOG
echo "---> Version von alsa:"          >> $SNDLOG
aplay --version | sed 's/^/\t/'        >> $SNDLOG
echo "---> Status: 'aplay -l'"         >> $SNDLOG
aplay -l 2> /dev/null | sed 's/^/\t/'  >> $SNDLOG
echo " "                               >> $SNDLOG

if ( aplay -l 2> /dev/null | grep -q Karte ); then
    S_KARTE="Karte"; S_DEVICE="Gerät"
else
    S_KARTE="card"; S_DEVICE="device"
fi
echo "---> Suche nach den Begriffen \"$S_KARTE\" und \"$S_DEVICE\" in aplay -l" >> $SNDLOG

DeActivateCodec Einblenden  #  Ausgeblendete inaktive HDMI-codecs wieder einblenden

### Erkennung, welche Ausgabe-Hardware vorhanden ist
if [ $(aplay -l 2> /dev/null | grep -c $S_KARTE) == 0 ]; then
    Mini_Info "\
           \n\
    keine Soundkarte erkannt"
    echo "---> keine Soundkarte erkannt. Good Bye..."  >> $SNDLOG
    sleep 2

    # rm -f /etc/asound.conf

else
    List_Sound_Device   ### Liste erstellen
    alsactl init > /dev/null 2>&1  ### alsamixer einstellen, wenn hw vorhanden
    AnzKarten=0
    for KARTE in $Ausgabe_Karten; do
	((AnzKarten++))
	Auto_Easy_Alsa $KARTE    # automatisch vorbelegen
    done
    alsactl store 2> /dev/null
    alsactl -f /var/lib/alsa/asound.state.easyvdr store 2> /dev/null

    Detect_Params    ### Kanalzahl und weiteres fuer die Ausgabe-Device ermitteln
    DeviceSelection  ### Ausgabe-Device erfragen

    # Was ist wenn keine Auswahl ( $SND_HW == "\"keine\"" ?

    if [[ $SndDeviceSelection != "" ]]; then
            SelectPassThroughDevice  ### Auswaehlen und Einstellen des PassThroughDevices
            Set_Anz_Channels         ### Festlegen der Anzahl Ausgabekanaele
            Weitere_Einstellungen    ### Weitere Funktionen und Spezialeinstellungen
 		    		     # Inaktive HDMI-codecs ausblenden
 				     # Nacharbeit am alsamixer, wenn gewuenscht
            Generate_Link_Asound     ### asound.confs erstellen und passende verlinken
            Set_GlobalSoundParams    ### Soundparameter schreiben

      if [ -d $SETUP/audio-setup ]; then
        echo "---> Audiokonfiguration fuer Plugins und AddOns uebernehmen durch..." >> $SNDLOG
        for Script in $SETUP/audio-setup/*
          do
            [ -f $Script ] && [ -x $Script ] && $Script "$SND_Dev_PassThrough" "$SpeakerLayout"
          done
      fi
      echo "---> Besonderheiten von Pulseaudio beruecksichtigen:" >> $SNDLOG
      rm -f /etc/asound.conf.ohne_pulseaudio
      if [ $PulseAudio_Default == "Off" ]; then
        echo "  -> Pulseaudio defaultmaessig nicht aktivieren..." >> $SNDLOG
        cp -d /etc/asound.conf /etc/asound.conf.ohne_pulseaudio # ohne pulseaudio Sicherheitskopie erstellen
      else
        echo "  -> Pulseaudio defaultmaessig aktivieren..." >> $SNDLOG
        echo "  -> dazu Link /etc/asound.conf entfernen..." >> $SNDLOG
        mv /etc/asound.conf /etc/asound.conf.ohne_pulseaudio # bei pulseaudio keine asound.conf
      fi
      $SETUP/easyvdr-config-audio_pulseaudio $PulseAudio_Default
      if [ $DoChannelCheck == "True" ]; then
        ChannelCheck
      fi
    else
      echo "---> Da kein Ausgabedevice ausgewaehlt wurde, werden keine weiteren Einstellungen vorgenommen !" >> $SNDLOG
    fi

    echo "---> Die Sound-Konfiguration ist jetzt an die Videoausgabe ueber X angepasst!" >> $SNDLOG

fi
clear
}
############################
Config_Sound_pvr350()
{
echo "---> Die Sound- und Videoausgabe erfolgt ueber die pvr350, fuer alsa ist nichts zu tun!" >> $SNDLOG
}
# Ende von HW_depending alsa-config
#############################################################################

## Setup.State schreiben ##
Write_Status()
{
    Configured4=""
    sed -i '/"*easyvdr-config-audio"*/d' $SETUP_STATUS
    echo "# `date` easyvdr-config-audio zuletzt ausgefuehrt" >> $SETUP_STATUS
    sed -i '/Audio_configured"*/d' $SETUP_STATUS
    echo "Audio_configured=\"true\"" >> $SETUP_STATUS
    if [[ "$SndDeviceSelection" != "" ]]; then
      for k in $SndDeviceSelection; do
	Configured4="$Configured4 ${SndDevice["$k 0"]}" #"
      done
      echo "Audio_configured_for=\"$Configured4\"" >> $SETUP_STATUS
      echo "Audio_configured_PassThrough=\"$SND_Dev_PassThrough\"" >> $SETUP_STATUS
      echo "Audio_configured_Layout=\"$SpeakerLayout\"" >> $SETUP_STATUS
      echo "Audio_configured_Pulse=\"$PulseAudio_Default\"" >> $SETUP_STATUS
   fi
}

#####
Mini_Info()
{  
INPUT_TEXT=$1
dialog --backtitle "$BACKTITLE"\
       --title " working "\
       --colors\
       --infobox "\n\n$INPUT_TEXT " 10 60
}

######
Config_Sound()
{
OnlyPulseSetup="false"
#if [ x$Audio_configured_Pulse == x"On" ]; then
    # ist Pulseaudio bereits aktiv, fragen, ob nur Pulseaudio-Setup oder Komplett
    dialog --backtitle "$BACKTITLE"\
       --timeout $TIMEOUT2\
       --defaultno\
       --no-label " nur Pulseaudio-Config "\
       --yes-label " Komplette Audio-Config "\
       --yesno "\n\n\
        Aktuell ist Sound ueber Pulseaudio konfiguriert. \n\n\
        Soll nur die Pulseaudio Konfiguration erneut starten \n\
                            oder\n\
            soll auf Alsa zurueckgestellt bzw. Alsa \n\
            und Pulseaudio erneut konfiguriert werden?" $DIA_BOX2_SIZE
    Only_Pulse=$?
    clear
    if [ $Only_Pulse == 0 ]; then
       OnlyPulseSetup="false"
    else
       OnlyPulseSetup="true"
    fi
#fi

if [ $OnlyPulseSetup == "false" ]; then
    # Audiosetup normal durchlaufen
    Config_Sound_HW
    Write_Status
else
    # Nur Pulseaudio-Setup
    $SETUP/easyvdr-config-audio_pulseaudio On
#echo "    $SETUP/easyvdr-config-audio_pulseaudio On"
fi
}


######################## main #############################################

[ ! -f  $SNDLOG ] && touch $SNDLOG
echo "" >> $SNDLOG
echo "============================================================" >>$SNDLOG
echo "File-Info: $FILENAME $FILEVERSION" >> $SNDLOG
echo "`date` $FILENAME mit den Parametern $1 $2 $3 gestartet..." >> $SNDLOG
echo ""

#############################################################################
# Aufrufparameter auswerten und erforderliche Schritte ausfuehren
###################################################
if [ "$2" == "--quiet" ]; then
    show_dialogs="few"
    echo "`date` Info: Option_2 --quiet: Nur wenige Dialoge anzeigen" >> $SNDLOG
else
    show_dialogs="all"
    echo "`date` Info: Option_2 --all: Alle Dialoge anzeigen" >> $SNDLOG
fi 
#echo "Dialog-Level = $show_dialogs"
###################################################
if [ "$3" == "--debug" ]; then
    log_debuginfo="true"
    echo "`date` Info: Option_3 --debug: Weitere Debug-Informationen loggen" >> $SNDLOG
else
    log_debuginfo="false"
fi 
#echo "Log Debug-Informationen = $log_debuginfo"
###################################################

case "$1" in
    "--config"     |"-c")  Config_Sound                         ;;
    "--help"       |"-h")  Usage                                ;;
    "--status"     |"-s")  Log_Status                           ;;
                       *)  echo "Parameter: $1 unbekannt"; Usage;;
esac
echo "`date` $FILENAME bis zum Ende durchgelaufen." >> $SNDLOG

