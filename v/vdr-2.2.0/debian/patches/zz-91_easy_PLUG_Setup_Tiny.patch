Index: vdr-2.2.0/PLUGINS/src/setup/config.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/config.c	2015-12-24 15:16:31.680279526 +0100
@@ -0,0 +1,387 @@
+/****************************************************************************
+ * DESCRIPTION: 
+ *             Read / Write Config Data
+ *
+ * $Id: config.cpp,v 1.13 2006/02/04 11:59:29 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ ****************************************************************************/
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include "vdr/plugin.h"
+#include "tinystr.h"
+#include "config.h"
+#include "setupsetup.h"
+#include "sysconfig.h"
+#include "plugins.h"
+#include "debug.h"
+#include "util.h"
+
+/**
+ * Constructor
+ * @param fname  XML File
+ * @return
+ */
+
+// Initialize static private data
+
+const char *Config::childLockCode = NULL; // will be set within Menu
+
+Config::Config(char *fname)
+{
+  _filename  = Util::Strdupnew(fname);
+  _libDir = NULL;
+  _xmlDoc = TiXmlDocument( fname );
+  _bootLinux = NULL;
+  _returnValue  = NULL;
+
+  childLockCode = NULL; //will not be freed hold only reference to data
+}
+
+
+Config::~Config()
+{
+  delete [] _returnValue;
+  delete [] _bootLinux;
+  delete [] _libDir;
+  delete [] _filename;
+}
+
+/************************
+* Read XML-File
+*************************/
+/**
+ * Decode XML File
+ * @return
+ */
+bool Config::LoadFile()
+{
+  bool ok = false;
+  TiXmlElement *root;
+  const char *sysconfigFile = NULL;
+
+  if ((ok = _xmlDoc.LoadFile())) {
+     if ((root = _xmlDoc.FirstChildElement("setup" )) != NULL
+     && (sysconfigFile = root->Attribute("sysconfigFile"))
+     && (ok = _sysconfig.LoadFile(sysconfigFile)) == true) {
+        // Set some default Values
+        const char *tmp = NULL;
+
+        if ((tmp = root->Attribute("bootLinux")) == NULL)
+           _bootLinux = Util::Strdupnew("/sbin/reboot");
+        else
+           _bootLinux = Util::Strdupnew(tmp);
+
+        if ((tmp = root->Attribute("VDRlibDir")) == NULL)
+           _libDir = Util::Strdupnew("/usr/lib/vdr/plugins");
+        else
+           _libDir = Util::Strdupnew(tmp);
+
+        if ((tmp = root->Attribute("ReturnValue")) == NULL)
+            _returnValue = Util::Strdupnew("");
+        else {
+           _returnValue = Util::Strdupnew(tmp);
+           if (!strcasecmp(_returnValue,  "true/false")) setupSetup.ReturnValue = 0;
+           else if (!strcasecmp(_returnValue, "on/off")) setupSetup.ReturnValue = 1;
+           else if (!strcasecmp(_returnValue, "yes/no")) setupSetup.ReturnValue = 2;
+           else _returnValue = Util::Strdupnew("");
+           }
+
+        root = root->FirstChildElement();
+        if (root != NULL && strcmp(root->Value(), "plugins") == 0) {
+           const char *nameSysconfig = root->Attribute("sysconfig");
+           if (nameSysconfig != NULL) {
+              _activePlugins.SetSysconfigName(nameSysconfig);
+              if (ok = loadPlugins(root->FirstChildElement()))
+                 ok = _menus.LoadXml(root->NextSibling("menus"));
+              }
+           else
+              ok = false;
+           }
+        }
+     }
+
+  if (!ok)
+     dumpXMLError("Error while Loading XML-FILE");
+
+  if (ok) {
+     if ((ok = _sysconfig.LoadFile(sysconfigFile)) == true)
+        ok = readVdrLib();
+     }
+
+  return(ok);
+}
+
+/**
+ * Save the the ConfigFile, overwrite opened file
+ * @return true if no error occured
+ */
+bool Config::SaveFile()
+{
+  return(SaveFile(_filename));
+}
+
+/**
+ * Save the the ConfigFile,
+ * @param fname name of config file to write to
+ * @return true if no error occured
+ */
+bool Config::SaveFile(char *fname)
+{
+  bool ok = true;
+  if (_filename != fname) {
+     delete _filename;
+     _filename = Util::Strdupnew(fname);
+    }
+
+  TiXmlComment  comment;
+  comment.SetValue("\n\
+-   VDR Configuration File for easyVDR\n\
+-\n\
+-\n\
+" );
+
+  TiXmlDocument xml = TiXmlDocument(fname);
+  TiXmlElement root("setup");
+
+  if (_sysconfig.GetFileName() == NULL)
+    root.SetAttribute("sysconfigFile", "/var/lib/vdr/sysconfig");
+  else
+    root.SetAttribute("sysconfigFile", _sysconfig.GetFileName());
+
+  root.SetAttribute("bootLinux", _bootLinux);
+  root.SetAttribute("VDRlibDir", _libDir);
+  root.SetAttribute("ReturnValue", _returnValue);
+
+  TiXmlElement *plugins=savePlugins();
+
+  if (plugins!= NULL && root.LinkEndChild(plugins) != NULL
+  && _menus.SaveXml(&root) == true
+  && xml.InsertEndChild(comment) != NULL
+  && xml.InsertEndChild(root) != NULL
+  && xml.SaveFile())
+     ok=true;
+  else {
+     ok = false;
+     dumpXMLError("Error writing file");
+     }
+
+  if (ok) {
+     prepareSysConfig();
+     ok = _sysconfig.SaveFile();
+     }
+
+  return(ok);
+}
+
+/**
+ * Returns Child Lock Code
+ * @return child Lock Code or NULL if not available
+ */
+const char *Config::GetChildLock()
+{
+  return(childLockCode);
+}
+
+/**
+ * Set a child Clock Code,
+ * @param lock lockk code "0000" or NULL means not locked.
+ */
+void Config::SetChildLock(const char *lock)
+{
+  childLockCode = lock;
+}
+
+//-------------------------------------------------------
+// Private Methods
+//-------------------------------------------------------
+/**
+ * Load XML Plugin Information
+ * @param elem
+ * @return
+ */
+bool Config::loadPlugins(TiXmlNode *node)
+{
+  bool ok = true;
+  TiXmlElement *elem = NULL;
+  if (node == NULL || strcmp(node->Value(), "plugin") != 0 ) {
+     dumpXMLError("no <plugin> tag found");
+     ok=false;
+     }
+  else {
+     do {
+        elem = node->ToElement ();
+        const char *name = elem->Attribute("name");
+        const char *info = elem->Attribute("info");
+        const char *active = elem->Attribute("active");
+        const char *param = elem->Attribute("param");
+        const char *protect = elem->Attribute("protected");
+        bool  b_active;
+        bool  b_protect;
+        if (protect == NULL || Util::isBool(protect, b_protect) == false)
+           b_protect = false;
+
+        if (name != NULL && info != NULL && active != NULL && Util::isBool(active, b_active))
+           _activePlugins.AddPlugin(name, param,  info, b_active, b_protect);
+        else
+           ok = false;
+        } while ((node = node->NextSibling()) != NULL && ok == true);
+     }
+
+  return(ok) ;
+}
+
+/**
+ * Save Plugins
+ * @return ptr to XML Element
+ */
+TiXmlElement *Config::savePlugins()
+{
+  TiXmlElement *xml = new TiXmlElement("plugins");
+
+  xml->SetAttribute("sysconfig", _activePlugins.GetSysconfigName());
+
+  savePlugins(&_activePlugins, xml);
+  savePlugins(&_notInSystemPlugins, xml);
+
+  return(xml);
+}
+
+void Config::savePlugins(Plugins *plugins, TiXmlElement *xml)
+{
+  int nr = plugins->GetNr();
+
+  for (int i=0; i<nr && xml!=NULL; i++) {
+     Plugin *p = plugins->Get(i);
+     if (p!= NULL) {
+        TiXmlElement *pl = new TiXmlElement("plugin");
+        if (pl != NULL) {
+           pl->SetAttribute("name", p->GetName());
+           if (p->GetParameter() != NULL)
+              pl->SetAttribute("param", p->GetParameter());
+           pl->SetAttribute("info", p->GetInfo());
+           pl->SetAttribute("active", p->GetActiveString());
+           if (p->GetProtect() == true)
+              pl->SetAttribute("protected", Util::boolToStr(p->GetProtect()));
+           xml->LinkEndChild(pl);
+           }
+        }
+     }
+}
+
+
+/**
+ * Dump XML-Error
+ */
+void Config::dumpXMLError()
+{
+  const char *errStr;
+  int col, row;
+  if (_xmlDoc.Error()) {
+     errStr = _xmlDoc.ErrorDesc();
+     col    = _xmlDoc.ErrorCol();
+     row    = _xmlDoc.ErrorRow();
+     DEBUG6("%s: Error in %s Col=%d Row=%d :%s\n", DBG_PREFIX, _filename, col, row, errStr );
+     }
+}
+
+void Config::dumpXMLError(const char *myErrStr)
+{
+  const char *errStr;
+  int col, row;
+
+  if (_xmlDoc.Error()) {
+     errStr = _xmlDoc.ErrorDesc();
+     col    = _xmlDoc.ErrorCol();
+     row    = _xmlDoc.ErrorRow();
+     DEBUG7("%s: %s: %s: Error in %s Col=%d Row=%d\n", DBG_PREFIX, myErrStr, errStr, _filename, col, row);
+     }
+}
+
+/**
+ * Returns a reference to the Plugins Object
+ * @return plugins object
+ */
+Plugins *Config::GetPlugins()
+{
+  return(&_activePlugins);
+}
+
+/**
+ * returns a reference to the Menus Object
+ * @return reference to Menus Object
+ */
+Menus *Config::GetMenus()
+{
+  return(&_menus);
+}
+
+/**
+ * Write internal representation to Sysconf Values
+ */
+void Config::prepareSysConfig()
+{
+  // Plugins
+  const char *pluginList = _activePlugins.GetActivePlugins();
+  _sysconfig.SetVariable(_activePlugins.GetSysconfigName(), pluginList);
+  for (int i=0; i<_menus.GetNr(); i++)
+     _menus.GetMenuNode(i)->SetSysConfig(&_sysconfig);
+}
+
+/**
+ * get all installed plugins in the specified lib directory
+ * and set the state within the plugin list
+ * @return true on success
+ */
+bool Config::readVdrLib()
+{
+  bool ok = true;
+  DIR  *dir = opendir(_libDir);
+  struct dirent *entry = NULL;
+  char *module = NULL;
+  char *tmp = NULL;
+  char *suffix = NULL;
+
+  //accept only dynamic Link libs with the current vdr version
+  asprintf(&suffix, ".so.%s", APIVERSION);
+  if (dir !=NULL) {
+     while ((entry = readdir(dir)) != NULL) {
+        if (strncmp(entry->d_name, "libvdr-", 7) == 0  && (tmp = strstr(entry->d_name, suffix)) != NULL) {
+           tmp[0]='\0';
+           module = entry->d_name +7;
+           _activePlugins.SetLibDirPlugin(module);
+          }
+        }
+
+     int nrPlugins = _activePlugins.GetNr();
+     for (int i=0; i<nrPlugins; i++) {
+        Plugin *p = _activePlugins.Get(i);
+
+        if (p != NULL && p->GetInSystem() == false) {
+           _activePlugins.Del(p, false);
+           _notInSystemPlugins.Add(p);
+           nrPlugins--;
+           i--;
+           }
+        }
+
+     closedir(dir);
+     }
+  else {
+     DEBUG3("%s: Could not read directory: %s\n", DBG_PREFIX, _libDir);
+     ok = false;
+     }
+
+  if (suffix != NULL) free(suffix);
+
+  return(ok);
+}
+
+char *Config::GetBootLinux()
+{
+  return(_bootLinux);
+}
Index: vdr-2.2.0/PLUGINS/src/setup/config.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/config.h	2015-12-24 15:16:31.680279526 +0100
@@ -0,0 +1,61 @@
+/*********************************************************
+ * DESCRIPTION: 
+ *             Header File
+ *
+ * $Id: config.h,v 1.9 2006/02/04 11:59:29 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ *********************************************************/
+
+#ifndef CONFIG_H
+#define CONFIG_H
+#include "tinystr.h"
+#include "plugins.h"
+#include "sysconfig.h"
+#include "menus.h"
+/**
+@author Ralf Dotzert
+*/
+
+
+
+
+
+class Config{
+public:
+    Config(char *xmlFile);
+    ~Config();
+    bool         LoadFile();
+    Plugins     *GetPlugins();
+    Menus       *GetMenus();
+    bool         SaveFile();
+    bool         SaveFile(char* fname);
+    char        *GetBootLinux();
+    static const char *GetChildLock();
+    static void SetChildLock(const char *lock);
+    
+
+private:
+    TiXmlDocument       _xmlDoc;
+    char               *_filename;
+    char               *_bootLinux;
+    Menus              _menus;
+    Sysconfig          _sysconfig;
+    Plugins            _activePlugins;
+    Plugins            _notInSystemPlugins;
+    static const char  *childLockCode;
+    const char         *_libDir;
+    const char         *_returnValue;
+    bool                loadPlugins(TiXmlNode *node);
+    TiXmlElement       *savePlugins() ;
+    void                savePlugins(Plugins *p, TiXmlElement *xml);
+    void                dumpXMLError();
+    void                dumpXMLError(const char* errStr);
+    bool                readVdrLib();
+    void                prepareSysConfig();
+};
+
+
+#endif
Index: vdr-2.2.0/PLUGINS/src/setup/COPYING
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/COPYING	2015-12-24 15:16:31.680279526 +0100
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
Index: vdr-2.2.0/PLUGINS/src/setup/debug.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/debug.h	2015-12-24 15:16:31.680279526 +0100
@@ -0,0 +1,36 @@
+/*********************************************************
+ * DESCRIPTION: 
+ *             Header File
+ *
+ * $Id: debug.h,v 1.3 2005/10/12 13:44:14 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ *********************************************************/
+
+#ifndef DEBUG_H
+#define DEBUG_H
+#include "vdr/plugin.h"
+
+#ifdef  DEBUG_STDOUT
+#define DEBUG1(p1)                      printf(p1)
+#define DEBUG2(p1, p2)                  printf(p1, p2)
+#define DEBUG3(p1, p2, p3)              printf(p1, p2, p3)
+#define DEBUG4(p1, p2, p3, p4)          printf(p1, p2, p3, p4)
+#define DEBUG5(p1, p2, p3, p4, p5)      printf(p1, p2, p3, p4, p5)
+#define DEBUG6(p1, p2, p3, p4, p5, p6)  printf(p1, p2, p3, p4, p5, p6)
+#define DEBUG7(p1, p2, p3, p4, p5, p6, p7)  printf(p1, p2, p3, p4, p5, p6, p7)
+#else
+#define DEBUG1(p1)                      esyslog(p1)
+#define DEBUG2(p1, p2)                  esyslog(p1, p2)
+#define DEBUG3(p1, p2, p3)              esyslog(p1, p2, p3)
+#define DEBUG4(p1, p2, p3, p4)          esyslog(p1, p2, p3, p4)
+#define DEBUG5(p1, p2, p3, p4, p5)      esyslog(p1, p2, p3, p4, p5)
+#define DEBUG6(p1, p2, p3, p4, p5, p6)  esyslog(p1, p2, p3, p4, p5, p6)
+#define DEBUG7(p1, p2, p3, p4, p5, p6, p7)  esyslog(p1, p2, p3, p4, p5, p6, p7)
+
+#endif
+#define DBG_PREFIX                      "ERROR: vdr-setup"
+
+#endif /* DEBUG_H */
Index: vdr-2.2.0/PLUGINS/src/setup/Doxyfile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/Doxyfile	2015-12-24 15:16:31.680279526 +0100
@@ -0,0 +1,266 @@
+# Doxyfile 1.3.7-KDevelop
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+PROJECT_NAME           = setup.kdevelop
+PROJECT_NUMBER         = $VERSION$
+OUTPUT_DIRECTORY       = 
+CREATE_SUBDIRS         = NO
+OUTPUT_LANGUAGE        = English
+USE_WINDOWS_ENCODING   = NO
+BRIEF_MEMBER_DESC      = YES
+REPEAT_BRIEF           = YES
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+ALWAYS_DETAILED_SEC    = NO
+INLINE_INHERITED_MEMB  = NO
+FULL_PATH_NAMES        = YES
+STRIP_FROM_PATH        = /home/Ralf/
+STRIP_FROM_INC_PATH    = 
+SHORT_NAMES            = NO
+JAVADOC_AUTOBRIEF      = NO
+MULTILINE_CPP_IS_BRIEF = NO
+DETAILS_AT_TOP         = NO
+INHERIT_DOCS           = YES
+DISTRIBUTE_GROUP_DOC   = NO
+TAB_SIZE               = 8
+ALIASES                = 
+OPTIMIZE_OUTPUT_FOR_C  = NO
+OPTIMIZE_OUTPUT_JAVA   = NO
+SUBGROUPING            = YES
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+EXTRACT_ALL            = NO
+EXTRACT_PRIVATE        = NO
+EXTRACT_STATIC         = NO
+EXTRACT_LOCAL_CLASSES  = YES
+EXTRACT_LOCAL_METHODS  = NO
+HIDE_UNDOC_MEMBERS     = NO
+HIDE_UNDOC_CLASSES     = NO
+HIDE_FRIEND_COMPOUNDS  = NO
+HIDE_IN_BODY_DOCS      = NO
+INTERNAL_DOCS          = NO
+CASE_SENSE_NAMES       = YES
+HIDE_SCOPE_NAMES       = NO
+SHOW_INCLUDE_FILES     = YES
+INLINE_INFO            = YES
+SORT_MEMBER_DOCS       = YES
+SORT_BRIEF_DOCS        = NO
+SORT_BY_SCOPE_NAME     = NO
+GENERATE_TODOLIST      = YES
+GENERATE_TESTLIST      = YES
+GENERATE_BUGLIST       = YES
+GENERATE_DEPRECATEDLIST= YES
+ENABLED_SECTIONS       = 
+MAX_INITIALIZER_LINES  = 30
+SHOW_USED_FILES        = YES
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+QUIET                  = NO
+WARNINGS               = YES
+WARN_IF_UNDOCUMENTED   = YES
+WARN_IF_DOC_ERROR      = YES
+WARN_FORMAT            = "$file:$line: $text"
+WARN_LOGFILE           = 
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+INPUT                  = /home/Ralf/src/vdr-1.3.17/PLUGINS/src/setup
+FILE_PATTERNS          = *.c \
+                         *.cc \
+                         *.cxx \
+                         *.cpp \
+                         *.c++ \
+                         *.java \
+                         *.ii \
+                         *.ixx \
+                         *.ipp \
+                         *.i++ \
+                         *.inl \
+                         *.h \
+                         *.hh \
+                         *.hxx \
+                         *.hpp \
+                         *.h++ \
+                         *.idl \
+                         *.odl \
+                         *.cs \
+                         *.php \
+                         *.php3 \
+                         *.inc \
+                         *.m \
+                         *.mm \
+                         *.C \
+                         *.CC \
+                         *.C++ \
+                         *.II \
+                         *.I++ \
+                         *.H \
+                         *.HH \
+                         *.H++ \
+                         *.CS \
+                         *.PHP \
+                         *.PHP3 \
+                         *.M \
+                         *.MM \
+                         *.C \
+                         *.H \
+                         *.tlh \
+                         *.diff \
+                         *.patch \
+                         *.moc \
+                         *.xpm \
+                         *.dox
+RECURSIVE              = yes
+EXCLUDE                = 
+EXCLUDE_SYMLINKS       = NO
+EXCLUDE_PATTERNS       = 
+EXAMPLE_PATH           = 
+EXAMPLE_PATTERNS       = *
+EXAMPLE_RECURSIVE      = NO
+IMAGE_PATH             = 
+INPUT_FILTER           = 
+FILTER_SOURCE_FILES    = NO
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+SOURCE_BROWSER         = NO
+INLINE_SOURCES         = NO
+STRIP_CODE_COMMENTS    = YES
+REFERENCED_BY_RELATION = YES
+REFERENCES_RELATION    = YES
+VERBATIM_HEADERS       = YES
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+ALPHABETICAL_INDEX     = NO
+COLS_IN_ALPHA_INDEX    = 5
+IGNORE_PREFIX          = 
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+GENERATE_HTML          = YES
+HTML_OUTPUT            = html
+HTML_FILE_EXTENSION    = .html
+HTML_HEADER            = 
+HTML_FOOTER            = 
+HTML_STYLESHEET        = 
+HTML_ALIGN_MEMBERS     = YES
+GENERATE_HTMLHELP      = NO
+CHM_FILE               = 
+HHC_LOCATION           = 
+GENERATE_CHI           = NO
+BINARY_TOC             = NO
+TOC_EXPAND             = NO
+DISABLE_INDEX          = NO
+ENUM_VALUES_PER_LINE   = 4
+GENERATE_TREEVIEW      = NO
+TREEVIEW_WIDTH         = 250
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+GENERATE_LATEX         = YES
+LATEX_OUTPUT           = latex
+LATEX_CMD_NAME         = latex
+MAKEINDEX_CMD_NAME     = makeindex
+COMPACT_LATEX          = NO
+PAPER_TYPE             = a4wide
+EXTRA_PACKAGES         = 
+LATEX_HEADER           = 
+PDF_HYPERLINKS         = NO
+USE_PDFLATEX           = NO
+LATEX_BATCHMODE        = NO
+LATEX_HIDE_INDICES     = NO
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+GENERATE_RTF           = NO
+RTF_OUTPUT             = rtf
+COMPACT_RTF            = NO
+RTF_HYPERLINKS         = NO
+RTF_STYLESHEET_FILE    = 
+RTF_EXTENSIONS_FILE    = 
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+GENERATE_MAN           = NO
+MAN_OUTPUT             = man
+MAN_EXTENSION          = .3
+MAN_LINKS              = NO
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+GENERATE_XML           = yes
+XML_OUTPUT             = xml
+XML_SCHEMA             = 
+XML_DTD                = 
+XML_PROGRAMLISTING     = YES
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+GENERATE_AUTOGEN_DEF   = NO
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+GENERATE_PERLMOD       = NO
+PERLMOD_LATEX          = NO
+PERLMOD_PRETTY         = YES
+PERLMOD_MAKEVAR_PREFIX = 
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+ENABLE_PREPROCESSING   = YES
+MACRO_EXPANSION        = NO
+EXPAND_ONLY_PREDEF     = NO
+SEARCH_INCLUDES        = YES
+INCLUDE_PATH           = 
+INCLUDE_FILE_PATTERNS  = 
+PREDEFINED             = 
+EXPAND_AS_DEFINED      = 
+SKIP_FUNCTION_MACROS   = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+TAGFILES               = 
+GENERATE_TAGFILE       = setup.tag
+ALLEXTERNALS           = NO
+EXTERNAL_GROUPS        = YES
+PERL_PATH              = /usr/bin/perl
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+CLASS_DIAGRAMS         = YES
+HIDE_UNDOC_RELATIONS   = YES
+HAVE_DOT               = NO
+CLASS_GRAPH            = YES
+COLLABORATION_GRAPH    = YES
+UML_LOOK               = NO
+TEMPLATE_RELATIONS     = NO
+INCLUDE_GRAPH          = YES
+INCLUDED_BY_GRAPH      = YES
+CALL_GRAPH             = NO
+GRAPHICAL_HIERARCHY    = YES
+DOT_IMAGE_FORMAT       = png
+DOT_PATH               = 
+DOTFILE_DIRS           = 
+MAX_DOT_GRAPH_WIDTH    = 1024
+MAX_DOT_GRAPH_HEIGHT   = 1024
+MAX_DOT_GRAPH_DEPTH    = 1000
+GENERATE_LEGEND        = YES
+DOT_CLEANUP            = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+SEARCHENGINE           = NO
Index: vdr-2.2.0/PLUGINS/src/setup/getVdrSetupMenu.pl
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/getVdrSetupMenu.pl	2015-12-24 15:16:31.680279526 +0100
@@ -0,0 +1,145 @@
+#!/usr/bin/perl
+
+sub getClass
+{
+
+  if(/(\s*class\s+cMenuSetupLiveBuffer)(.*)(\s+:\s+public\s+cMenuSetupBase)/)
+  {
+    $patchlevel = "extensions";
+    push @classes, "#ifdef USE_LIVEBUFFER\n";
+  }
+
+  push @classes, $_;
+  if(/(\s*class\s+cMenuSetup)(.*)(\s+:\s+public\s+cMenuSetupBase)/)
+  {
+    push @identifiers,$2;
+  }
+  while(<INPUT>)
+  {
+    push @classes, $_;
+    if(/}\s*;/)
+      { last;}
+  };
+
+  if($patchlevel eq "extensions")
+  {
+    $patchlevel = "";
+    push @classes, "#endif /* LIVEBUFFER */\n";
+  }
+
+  push @classes, "\n\n";
+
+}
+
+#####################################################################################
+# Extracts VDR Setup Class Definitions from <vdr-dir>/menu.c
+#####################################################################################
+my $file   = $ARGV[0];
+my $output = "setupsystemmenu.c";
+my @headers=[];
+local @classes=[];
+local @identifiers=[];
+
+open(INPUT,  $file)      or die "Can't open $file ";
+open(OUTPUT, ">$output") or die "Can't open $file ";
+
+ while (<INPUT>) 
+ {   
+    if (/^\s*#include/)
+    {
+      #printf(OUTPUT $_);
+      push @headers, $_;
+    }
+    if (/^\s*class\s+\w+MenuSetupBase/) 
+    {
+       getClass;
+    }
+    if (/^\s*class\s+\w+\s*:\s*public\s+cMenuSetupBase/) 
+    {
+       getClass;
+    }
+ }
+
+
+
+ printf( OUTPUT "/***********************************************************\n");
+ printf( OUTPUT " * Header file holding Class Definitions from <VDR>/menu.c *\n");
+ printf( OUTPUT " *                                                         *\n");
+ printf( OUTPUT " * This file is generated automaticly!                     *\n");
+ printf( OUTPUT " * Do not make changes!                                    *\n");
+ printf( OUTPUT " *                                                         *\n");
+ printf( OUTPUT " ***********************************************************/\n\n");
+printf( OUTPUT "// Headers included by <VDR>/menu.c\n");
+
+for($i=1; $i<= $#headers; $i++)
+ {
+if ($headers[$i]=~ m/ "/) {
+ my @values = split(' "',$headers[$i],2);
+     printf( OUTPUT '%s "vdr/%s', $values[0], $values[1]);
+}
+else
+{
+   printf( OUTPUT "%s", $headers[$i]);
+}
+}
+
+printf( OUTPUT "\n// local headers needed\n");
+printf( OUTPUT "#include \"setupsystemmenu.h\"\n");
+printf( OUTPUT "#include \"setupmenu.h\"\n");
+printf( OUTPUT "#include \"debug.h\"\n");
+
+printf( OUTPUT "// ************************************\n");
+printf( OUTPUT "// SetupClasses defined in <VDR>/menu.c\n");
+printf( OUTPUT "// ************************************\n\n");
+for($i=1; $i<= $#classes; $i++)
+{
+  printf( OUTPUT "%s", $classes[$i]);
+}
+
+printf( OUTPUT "//############################################################################\n");
+printf( OUTPUT "// cSetupSystemMenu\n");
+printf( OUTPUT "//############################################################################\n");
+printf( OUTPUT "cSetupSystemMenu::cSetupSystemMenu()\n");
+printf( OUTPUT "{\n");
+printf( OUTPUT "}\n");
+printf( OUTPUT "cSetupSystemMenu::~cSetupSystemMenu()\n");
+printf( OUTPUT "{\n");
+printf( OUTPUT "}\n");
+printf( OUTPUT "// Get SystemMenu\n");
+printf( OUTPUT "cOsdMenu *cSetupSystemMenu::GetSystemMenu(const char *sysCommand, Config  *config)\n");
+printf( OUTPUT "{\n");
+printf( OUTPUT " cOsdMenu *menu=NULL;\n");
+printf( OUTPUT " if( sysCommand != NULL)\n");
+printf( OUTPUT " {\n");
+printf( OUTPUT "    if( strcmp(sysCommand, \"ActPlugins\") == 0)\n");
+printf( OUTPUT "        menu = new cSetupPluginMenu(config);\n");
+printf( OUTPUT "    else\n");
+printf( OUTPUT "      if(strcmp(sysCommand, \"VDRMenu\") == 0)\n");
+printf( OUTPUT "        menu = new cSetupVdrMenu(tr(\"Menu Edit\"));\n");
+
+
+for($i=1; $i<= $#identifiers; $i++)
+{
+   if($identifiers[$i] eq "LiveBuffer")
+   {
+     printf( OUTPUT "#ifdef USE_LIVEBUFFER\n");
+   }
+   printf( OUTPUT "    else\n");
+   printf( OUTPUT "      if(strcmp(sysCommand, \"%s\") == 0)\n", $identifiers[$i]);
+   printf( OUTPUT "         menu = new cMenuSetup%s;\n", $identifiers[$i]);
+   if($identifiers[$i] eq "LiveBuffer")
+   {
+     printf( OUTPUT "#endif /* LIVEBUFFER */\n");
+   }
+}
+
+printf( OUTPUT "   else\n");
+printf( OUTPUT "      DEBUG3(\"%%s: <menu System=%%s> not known\\n\", DBG_PREFIX, sysCommand);\n");
+printf( OUTPUT "  }\n");
+printf( OUTPUT "  return (menu);\n");
+printf( OUTPUT "}\n");
+
+close(OUTPUT);
+close(FILE)
+
+
Index: vdr-2.2.0/PLUGINS/src/setup/HISTORY
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/HISTORY	2015-12-24 15:16:31.680279526 +0100
@@ -0,0 +1,144 @@
+VDR Plugin 'setup' Revision History
+-----------------------------------
+2008-06-19: setup-0.3.1-zulu-edition
+- From now VDR-Extensions-Patch => 63 or
+  VDR-Extensions-Patch 62 + vdr-ext62_setup-custom-plugin-title.diff
+  is required
+- Reworked setupmenu.c and setupmenu.h
+  Added new xml 'title' tag for plugins, from now it is
+  possible to customize the menuentrys for all plugins
+  Two new functions for the 'Menu Edit':
+  - Edit / Move -> Plugins
+  - Add / Edit / Move / Delete -> Commands and Threads
+
+2008-01-30: setup-0.3.1-zulu-edition
+- Reworked the Return Value, now it is possible to set
+  a default value in vdr-setup.xml
+- Some code cleaning
+
+2008-01-27: setup-0.3.1-zulu-edition
+- Added Internationalization for VDRs Setup Menu in vdr-setup.xml
+- Added some examples for the new xml format
+
+2008-01-22: setup-0.3.1-zulu-edition
+- Added Internationalization for vdr-menu.xml and vdr-setup.xml
+  If VDR is patched with <=Extensions-Patch-43, it is required to
+  apply the patch to VDR included with the plugin.
+  After this just copy your vdr-menu.xml to vdr-menu.OSDLanguage.xml
+  OSDLanguage must be named like in VDRs setup.conf
+  example ( vdr >=1.5.7 )
+    OSDLanguage=de_DE  ->    vdr-menu.de_DE.xml
+  example ( vdr <1.5.7 )
+    OSDLanguage=1      ->    vdr-menu.1.xml
+  for default VDR uses vdr-menu.xml
+- Fixed french translation in plugins setup
+
+2008-01-21: setup-0.3.1-zulu-edition
+- Fixed wrong count for ReturnValues in setupsetup.h
+- Added french translation - thanks to Patrice Staudt
+- Fixed wrong Date in HISTORY :)
+
+2008-01-20: setup-0.3.1-zulu-edition
+- Fixed missing translations in Menu Edit
+- Renamed "Direct Access to the Menu Edit" to "Main menu entry"
+- Added french translation - thanks to Patrice Staudt
+
+2008-01-19: setup-0.3.1-zulu-edition
+- Fixed Process Key in cSetupSetupPage
+- Reworked i18n.c and added some trVDR to setupmenu.c
+- Now i18n-to-gettext.pl founds all translations
+
+2008-01-16: setup-0.3.1-zulu-edition
+- Added a new Setup-Option "Direct Access to the Menu Edit"
+
+2008-01-10: setup-0.3.1-zulu-edition
+changes done by zulu
+- Added all known fixes
+- Make it ready for Extensions-Patch
+- Renamed all *.cpp to *.c
+- Renamed minivdr-setup.xml to vdr-setup.xml
+- Added a new Setup-Option "Return Value"
+  to select between true/false, on/off or yes/no
+- Added Internationalization for vdr-1.5.7 and above
+
+2006-03-06
+- do not use std::vector
+
+
+2006-03-05
+- handle missing channellists /etc/vdr/channels/*.conf
+- when changing channel lists delete timers with unknown channel
+- correct behaviour if menucommandpatch was applied
+- Show title of current Submenu
+
+
+
+2006-01-15: Version 0.2.3
+- Now Reload Channel-List if Channel-List was changed
+- patched for vdr Version 1.3.38
+
+2005-10-12: Version 0.2.2
+- fixed bug, know do not hide other buttons if help button is shown.
+- know compatible with BIG-PATCH,
+- Supports all VDR System Menu Commands are extracted during buidl process
+  If BIGPATCH was applied, then the new System-Command "LiveBuffer", "BigPatch"
+  are supported
+
+
+2005-10-06: Version 0.2.1
+-  fixed Bug: Know changes are saved again in sysConfigFile
+
+2005-10-03: Version 0.2.0
+-  Added Setup Men for plugin. Allowing to edit Menusuffix and Entry-Prefix)
+-  Changed minivdr-setup.xml format
+   all <menu>..</menu> tags are now within a <menus>..</menus> tag
+   New system attribute values for the Menu Tags:
+       VDRMenu     ( specifies the position of "Edit Vdr Menu")
+       ActPlugins  ( specifies the position of Activate Plugins-Menu)
+-  Added new type "Ip" for Entry holding IP-Addresses Digits and dots.
+-  Added new attribut "help1" Entry and Menu in minivdr-setup.xml
+-  Added new attribut "help2" Entry and Menu in minivdr-setup.xml
+-  The file sysconfig will now be created if it does not exist
+-  removed attribute "bootVDR", now using standard vdr Rebot mechanism
+-  Configurationfiles (minivdr-setup.xml and vdr-menu.xml) are now stored
+   "PluginConfigDirectory/setup"
+
+2005-06-19: Version 0.1.0
+- changed interaction with user, now the setup plugin behaves as usually known by VDR Users.
+  By pressing the OK Button the user may switch back to the previous menu.
+- fixed bug, if Directory <VDR-Configdir>/channels or <VDR-Configdir>/channels/*.conf are missing
+- do not remove plugins from "minivdr-setup.xml", when plugin is not in system
+- Allows to edit Plugin-Parameters
+- Support executing User Defined commands when walking through MiniVDR Setup Menu
+  specify new command attribute within menu tag
+- Know supports VDR Standard Setup Menu within Setup-Plugin Menu
+- Support paging plugin in Menu Acivate/Deactivbate Plugins
+
+2005-02-26: Version 0.0.5
+- Added new Attributes in minivdr-setup.xml to configure system dependent pathes
+- improved edit menu handling
+- fixed crash, when no network modules were found
+- now add also network modules in subdirectories
+- Show name of plugin in Pluginmenu
+
+2005-01-28: Version 0.0.4
+- Added Creation of new Menus
+- Added Editing of Menu-name
+- Added deltion of menu
+
+2005-01-23: Version 0.0.3
+- Added new entry types:
+    hex     - hexvalues in the form of AB:FF:12
+    numtext - String holding only digits
+- Added new feature ChildLock
+- Added SubMenu Patch for VDR
+- Added SubMenu Edit-Menu
+
+2005-01-05: Version 0.0.2
+- first released version
+- Enable/Disable Plugins
+- Added Menu / SubMenus
+
+2004-12-05: Version 0.0.1
+
+- Initial revision.
Index: vdr-2.2.0/PLUGINS/src/setup/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/Makefile	2015-12-24 15:16:31.684279546 +0100
@@ -0,0 +1,133 @@
+#
+# Makefile for a Video Disk Recorder(2.0.0 >) plugin
+#
+# $Id:
+
+# The official name of this plugin.
+# This name will be used in the '-P...' option of VDR to load the plugin.
+# By default the main source file also carries this name.
+#
+PLUGIN = setup
+
+### The version number of this plugin (taken from the main source file):
+
+VERSION = $(shell grep 'static const char \*VERSION *=' $(PLUGIN).c | awk '{ print $$6 }' | sed -e 's/[";]//g')
+
+### The directory environment:
+
+# Use package data if installed...otherwise assume we're under the VDR source directory:
+PKGCFG = $(if $(VDRDIR),$(shell pkg-config --variable=$(1) $(VDRDIR)/vdr.pc),$(shell pkg-config --variable=$(1) vdr || pkg-config --variable=$(1) ../../../vdr.pc))
+LIBDIR = $(call PKGCFG,libdir)
+LOCDIR = $(call PKGCFG,locdir)
+PLGCFG = $(call PKGCFG,plgcfg)
+VDRCONFDIR= $(call PKGCFG,configdir)
+PLGRESDIR = $(call PKGCFG,resdir)/plugins/$(PLUGIN)
+TMPDIR ?= /tmp
+
+### The compiler options:
+export CFLAGS   = $(call PKGCFG,cflags)
+export CXXFLAGS = $(call PKGCFG,cxxflags)
+
+### Allow user defined options to overwrite defaults:
+-include $(PLGCFG)
+
+APIVERSION = $(call PKGCFG,apiversion)
+
+### The name of the distribution archive:
+
+ARCHIVE = $(PLUGIN)-$(VERSION)
+PACKAGE = vdr-$(ARCHIVE)
+
+### The name of the shared object file:
+
+SOFILE = libvdr-$(PLUGIN).so
+
+### Includes and Defines (add further entries here):
+
+INCLUDES += -I$(VDRDIR)/include
+
+-include $(VDRDIR)/Make.config 
+
+DEFINES += -DPLUGIN_NAME_I18N='"$(PLUGIN)"'
+
+### The object files (add further files here):
+OBJS     = $(PLUGIN).o  menus.o setupmenu.o setupsetup.o config.o plugins.o sysconfig.o util.o setupsystemmenu.o
+
+### The main target:
+
+all: $(SOFILE) i18n
+
+### Implicit rules:
+
+%.o: %.c
+	$(CXX) $(CXXFLAGS) -c $(DEFINES) $(INCLUDES) -o $@ $<
+
+# Dependencies:
+
+MAKEDEP = $(CXX) -MM -MG
+DEPFILE = .dependencies
+$(DEPFILE): setupsystemmenu.c Makefile
+	@$(MAKEDEP) $(CXXFLAGS) $(DEFINES) $(INCLUDES) $(OBJS:%.o=%.c) > $@
+
+-include $(DEPFILE)
+
+### Internationalization (I18N):
+
+PODIR     = po
+I18Npo    = $(wildcard $(PODIR)/*.po)
+I18Nmo    = $(addsuffix .mo, $(foreach file, $(I18Npo), $(basename $(file))))
+I18Nmsgs  = $(addprefix $(DESTDIR)$(LOCDIR)/, $(addsuffix /LC_MESSAGES/vdr-$(PLUGIN).mo, $(notdir $(foreach file, $(I18Npo), $(basename $(file))))))
+I18Npot   = $(PODIR)/$(PLUGIN).pot
+
+%.mo: %.po
+	msgfmt -c -o $@ $<
+
+$(I18Npot): $(wildcard *.c)
+	xgettext -C -cTRANSLATORS --no-wrap --no-location -k -ktr -ktrNOOP --package-name=vdr-$(PLUGIN) --package-version=$(VERSION) --msgid-bugs-address='<vdrdev@schmirler.de>' -o $@ `ls $^`
+
+%.po: $(I18Npot)
+	msgmerge -U --no-wrap --no-location --backup=none -q -N $@ $<
+	@touch $@
+
+$(I18Nmsgs): $(DESTDIR)$(LOCDIR)/%/LC_MESSAGES/vdr-$(PLUGIN).mo: $(PODIR)/%.mo
+	install -D -m644 $< $@
+
+.PHONY: i18n
+i18n: $(I18Nmo) $(I18Npot)
+
+install-i18n: $(I18Nmsgs)
+
+### Targets:
+
+$(SOFILE): $(OBJS)
+	$(CXX) $(CXXFLAGS) $(LDFLAGS) -shared $(OBJS) -o $@
+
+install-lib: $(SOFILE)
+	install -D $^ $(DESTDIR)$(LIBDIR)/$^.$(APIVERSION)
+
+install: install-lib install-i18n
+	
+setupsystemmenu.c:  ../../../menu.c
+	@echo "Extracting class definitions from VDR's menu.c for standard Setup"
+	@perl getVdrSetupMenu.pl ../../../menu.c
+
+	
+dist: clean
+	@rm -rf $(TMPDIR)/$(ARCHIVE)
+	@mkdir $(TMPDIR)/$(ARCHIVE)
+	@cp -a * $(TMPDIR)/$(ARCHIVE)
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop.filelist
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevelop.pcs
+	@rm -f $(TMPDIR)/$(ARCHIVE)/$(PLUGIN).kdevses
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/CVS
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/Examples/CVS
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/Examples/help/CVS
+	@rm -rf $(TMPDIR)/$(ARCHIVE)/Patch/CVS
+	@tar czf $(PACKAGE).tgz -C $(TMPDIR) $(ARCHIVE)
+	@rm -rf $(TMPDIR)/$(ARCHIVE) $(TMPDIR)/$(PLUGIN)
+	@echo Distribution package created as $(PACKAGE).tgz
+
+clean:
+	@-rm -f $(PODIR)/*.mo $(PODIR)/*.pot
+	@-rm -f $(OBJS) $(MAIN) $(DEPFILE) *.so *.tgz core* setupsystemmenu.c Makefile.new *~
Index: vdr-2.2.0/PLUGINS/src/setup/MANUAL.DE
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/MANUAL.DE	2015-12-24 15:16:31.684279546 +0100
@@ -0,0 +1,286 @@
+****** Einleitung ******
+
+Das SETUP-Plugin erlaubt die einfache Konfiguration der wichtigsten
+Systemeinstellungen ber das OSD des VDR's. Dieses Plugin wurde ursprnglich fr die
+MiniVDR Distribution entwickelt, kann aber einfach fr andere Distributionen
+konfiguriert werden.
+
+****** Features ******
+
+Folgende Funktionen werden mit dem Setup Plugin realisiert:
+
+****** An- und Abwahl von Plugins ******
+
+Per OSD knnen Plugins an oder abgeschaltet werden. Eventuell bentigte Plugin-
+Parameter knnen im Konfigurationsfile vdr-setup.xml hinzugefgt werden.
+Eine genderte Plugin-Konfiguration wird erst nach dem nchsten Neustart aktiv.
+
+***** VDR-Mens *****
+
+Mit dem Setup-Plugin wird ein Patch fr den VDR ab Version 1.3.33 geliefert,
+welcher die Erzeugung von Submens erlaubt.
+
+ACHTUNG: Hierbei handelt es sich um eine eigene neue Entwicklung, welcher
+         beliebig viele geschachtelte Sub-Sub-Mens zulsst. Das Plugin Submenu
+         und dessen Patch kann nicht zusammen mit dem Setup-Plugin verwendet
+         werden!
+
+In der Menkonfigurationsdatei "vdr-menu.xml" knnen Mens, Plugins und Kommandos
+definiert werden, welche dann per OSD ausgefhrt werden knnen.
+Eventuelle Bildschirmausgaben der Kommandos werden auf dem OSD ausgegeben.
+
+Mens und Kommandos knnen im Setup-Plugin auch per OSD hinzugefgt, editiert
+und verschoben werden. Eine genderte Menkonfiguration wird sofort nach dem Speichern
+und erneutem ffnen des Mens aktiv.
+
+Plugins knnen mit einem frei whlbaren Title versehen werden.
+
+****** Systemkonfiguration ndern ******
+
+Im Setup Plugin knnen die gngigen Systemkonfigurationen per OSD gendert
+werden. Im Konfigurations-File vdr-setup.xml knnen dazu beliebige
+geschachtelte Mens (XML Tag <menu> </menu> konfiguriert werden. Jedem
+Systemparameter wird ein Variablenname zugeordnet, der dann im angegebenen
+System-Konfigurationsfile, welches mit dem Attribut "sysconfigFile" definiert
+wurde, abgespeichert. Diese Datei kann dann von der Distribution beim Booten und
+Starten des VDR ausgelesen werden und das System nach den Einstellungen des
+Benutzers konfigurieren.
+Die Beschreibung der Konfigurationsdateien wird hier im Detail beschrieben.
+
+****** Systemvoraussetzungen ******
+
+    * In das Plugin Konfigurationsverzeichnis (z.B: /etc/vdr/plugins/setup)
+      mssen die Dateien vdr-setup.xml und vdr-menu.xml abgelegt werden.
+    * Die in der Datei vdr-setup.xml mit dem Attribut "sysconfigFile
+      gekennzeichnete Datei wird vom Plugin angelegt, falls Sie nicht existieren
+      sollte. In dieser Datei werden die Einstellungen in Form von
+      Shellvariablen gespeichert.
+    * Hilfedateien werden in dem Vezeichnis /etc/vdr/plugins/setup/help
+      abgelegt.
+    * Der beigefgte Patch fr VDR 1.3.x muss installiert werden.
+    * Das Submen-Plugin darf nicht zusammen mit dem Setup-Plugin verwendet
+      werden.
+
+****** Support ******
+
+Fragen, Verbesserungsvorschlge und eventuelle Fehler knnen direkt ber das
+Forum im VDR-Portal weiter gegeben werden.
+
+
+
+*************************************
+****** VDR-Setup Konfiguration ******
+*************************************
+
+Das VDR-Setup Plugin nutzt zwei Konfigurationsdateien.
+    * vdr-setup.xml
+    * vdr-menu.xml
+
+***** Beschreibung vdr-setup.xml *****
+
+Die Datei vdr-setup.xml beschreibt die Konfiguration des Setup-Plugins im XML
+Format.
+
+<setup>
+
+Das ist das Wurzelelement der Konfigurationsdatei. Alle anderen Elemente liegen
+verschachtelt in diesem.
+Attribute     Beschreibung
+              Pfad zu Sysconfig Datei. In dieser Datei speichert das Plugin die
+              Einstellungen in Form von SHELL Variable Definitionen. Diese Datei
+sysconfigFile kann dann vom Backend z.B.:runvdr einfach eingelesen und
+              ausgewertet werden.
+              Achtung: die Datei wird bei jeder nderung innerhalb des Plugins
+              neu erzeugt.
+bootLinux     Enthlt das Kommando, welches aufgerufen wird um LINUX zu
+              rebooten. Default ="/sbin/reboot"
+VDRlibDir     Gibt das Verzeichnsi an, in welchem die VDR-Plugins abgelegt sind.
+              Deafult ="/usr/lib/vdr/plugins"
+ 
+
+
+<plugins>
+
+Beinhaltet die Liste der Plugins.
+Attribute Beschreibung
+sysconfig Variablen Name im sysconfigFile. In dieser Variable wird die Liste der
+          aktivierten Plugins gespeichert.
+ 
+
+<plugin>
+
+Beschreibt ein Plugin.
+Attribute Beschreibung
+          Name des Plugins. Gibt den Namen des Plugins an. Im VDR-Lib-
+name      Verzeichnis muss das Plugin dann unter dem Namenlib-"name"-vdrversion
+          gefunden werden.
+param     Dieses optionale Attribut gibt die Aufrufparameter des Plugins an.
+info      Beschreibung des Plugins
+active    Hat den Wert "yes" oder "no" und gibt an, ob das Plugin aktiv ist.
+          Hat den Wert "yes" oder "no". Wenn == yes , dann kann dieses Plugin
+protected nicht deaktiviert werden und im OSD erscheint "geschtzt".
+
+          Dieses Attribut ist optional. Default: "no".
+ 
+
+<menus>
+
+Es folgen nun beliebig viele Menbeschreibungen <menu>. Innerhalb eines Mens
+knnen weitere Mens <menu> oder aber Eintrge (<entry>) folgen.
+ 
+
+<menu>
+
+Beschreibt ein Men. Innerhalb eines Mens knnen weitere Mens <menu> oder aber
+Eintrge (<entry>) folgen.
+Attribute Beschreibung
+name      Name des Mens. Dieser String wird dann im VDR-Men angezeigt.
+          Dieses optionale Attribut gibt ein Kommando mit kompletter
+command   Pfadbeschreibung und Parametern an, welches ausgefhrt wird, wenn das
+          Submen mit OK beendet wird.
+          erlaubt die Angabe eines Standard Untermens der "Einstellungen".
+          Mgliche Werte sind:
+              * OSD
+              * EPG
+              * DVB
+              * LNB
+              * CICAM
+system        * Record
+              * Replay
+              * Misc
+              * Plugins
+          Zustzlich zu den VDR-Standardmens sind die folgenden Untermens
+          definiert:
+              * ActPlugins (Aktiviere / Deaktiviere Plugin)
+              * VDRMenu (Editiere das VDR-Men)
+          Whrend dem Build-Prozess werden alle in <vdr>/menu.c definierten
+          Setup-Mens eingelesen und konfiguriert.
+          Ist der Live-Buffer Patch angewendet worden, kann auch der zustzliche
+          Wert genutzt werden:
+              * LiveBuffer (Men des Live-Buffer Patches)
+help1     Dieses optionale Attribut gibt einen kurzen Hilfstext an welcher in
+          der Statuszeile angezeigt wird, wenn der Cursor auf dem Eintrag steht.
+          Dieses optionale Attribut gibt eine Datei mit einem langen Hilfstext
+help2     an. Diese Datei muss sich in dem Verzeichnis PluginConfigDir/setup/
+          help befinden. Der Text der Datei wird ausgegeben, wenn die rote Taste
+          gedrckt wird.
+ 
+
+<entry>
+
+Innerhalb eines Men knnen beliebig viele Eintrge aufgefhrt werden, mit denen
+jeweils einen Wert konfiguriert werden kann.
+Attribute Beschreibung
+name      Name des Eintrags. Dieser String wird dann im VDR-Men angezeigt.
+sysconfig Variablen Name im sysconfigFile. In dieser Variable wird die Liste der
+          aktivierten Plugins gespeichert.
+          Dieses optionale Attribut gibt ein Kommando mit kompletter
+command   Pfadbeschreibung und Parametern an, welches ausgefhrt wird, wenn das
+          Submen mit OK beendet wird.
+          definiert den Typ des Eintrags. Erlaubt sind die folgenden Eintrge:
+            text
+                Erlaubt das Editieren eines Textes.
+            bool
+                Erlaubt das Editieren eines Booleschen Wertes (yes oder no)
+            numtext
+                Erlaubt die Eingabe eines Strings der nur aus Ziffern besteht.
+                Fhrende Nullen bleiben erhalten.
+type        hex
+                Erlaubt die Eingabe von Hexadezimalwerten.
+            number
+                Erlaubt die Eingabe eines Integer Wertes.
+            ip
+                Erlaubt die Eingabe einer Internetadresse der Form
+                DDD.DDD.DDD.DDD.
+            selection
+                Erlaubt die Auswahl eines Elementes welches innerhalb des
+                <entry> Eintrags mit <value> definiert werden muss.
+value     Ausgewhlter Wert.
+          Mit diesem Attribut knnen interne Funktionen aufgerufen werden.
+            childlock
+                Definiert die Kindersicherungsfunktion. Die eingegebenen Werte
+                werden in Form von "*" angezeigt.
+            channellist
+setup           Erlaubt die Auswahl von vordefinierten Kanallisten. Die
+                Kanallisten mssen in den Verzeichnis <vdrdir>/plugins/channels
+                mit der Endung *.conf abgelegt werden. Das Setup-Plugin linkt
+                dann die ausgewhlte Kanalliste nach <vdrdir>/channels.conf
+            networkdriver"
+                erlaubt die Auswahl eines Netzwerktreibers
+help1     Dieses optionale Attribut gibt einen kurzen Hilfstext an welcher in
+          der Statuszeile angezeigt wird, wenn der Cursor auf dem Eintrag steht.
+          Dieses optionale Attribut gibt eine Datei mit einem langen Hilfstext
+help2     an. Diese Datei muss sich in dem Verzeichnis PluginConfigDir/setup/
+          help befinden. Der Text der Datei wird ausgegeben, wenn die rote Taste
+          gedrckt wird.
+ 
+
+<value>
+
+Innerhalb eines Entries vom Typ "selection" knnen beliebig viele <value> Werte
+definiert werden, die dann zur Auswahl stehen.
+ 
+***** Beschreibung vdr-menu.xml *****
+
+In der Datei vdr-menu.xml wird die Menkonfiguration des VDR abgelegt.
+
+<menus>
+
+Das ist das Wurzelelement der Konfigurationsdatei. Innerhalb dieses Elementes
+drfen beliebig viele Elemente der folgenden Typen liegen:
+    * menu
+    * plugin
+    * system
+    * command
+
+
+<menu>
+
+Innerhalb eines Mens, knnen beliebig viele weitere Tags von folgende Typen
+folgen:
+    * menu
+    * plugin
+    * system
+    * command
+Attribute Beschreibung
+name      Name des Mens. Dieser String wird dann als VDR-Men angezeigt.
+
+
+<plugin>
+
+Beschreibt den Name des Plugins, der an dieser Stelle im Men angezeigt wird.
+Attribute Beschreibung
+name      Name des Plugins. Im Men erscheint dann der Sprachen spezifische Name
+          des Plugins.
+
+
+<system>
+
+Beschreibt eines der Standart VDR-Mens, die an dieser Stelle im Men angezeigt
+wird.
+Attribute Beschreibung
+          Name des System Kommandos. Im Men erscheint dann der Sprachen
+          spezifische Name des System Kommandos. Die folgenden Werte sind
+          definiert:
+            Schedule
+                Das Programm Men.
+            Channels
+name            Das Men Kanle.
+            Timers
+                Das Timer Men.
+            Recordings
+                Das Aufnahme Men.
+            Setup
+                Das Men Einstellungen.
+
+
+<command>
+
+Beschreibt ein Kommando welches im Men eingebunden werden kann.
+Attribute Beschreibung
+name      Name des Kommandos. Dieser String wird dann als VDR-Men angezeigt.
+execute   Kompletter String mit Pfadname zum Kommando und optionalen Parametern,
+          der ausgefhrt werden soll.
+ 
+
+
Index: vdr-2.2.0/PLUGINS/src/setup/menus.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/menus.c	2015-12-24 15:16:31.684279546 +0100
@@ -0,0 +1,1436 @@
+/****************************************************************************
+ * DESCRIPTION: 
+ *             Configuration Menus
+ *
+ * $Id: menus.cpp,v 1.15 2006/03/05 09:47:25 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ ****************************************************************************/
+
+#include <sys/utsname.h> 
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <limits.h>
+#include <stdlib.h>
+
+#include <vdr/device.h>
+#include "menus.h"
+#include "config.h"
+#include "sysconfig.h"
+#include "debug.h"
+
+#define VALUETEXTMAXLEN 40
+#define VALUEIPMAXLEN   16
+
+// ###################################################################################
+//  MenuNode
+// ###################################################################################
+
+/**
+ * Constructor of Object
+ *
+ */
+MenuNode::MenuNode( )
+{
+  _menu      = NULL;
+  _menuEntry = NULL;
+  _objType   = MenuNode::UNDEFINED;
+}
+
+/**
+ * Destructor of Object 
+ *
+ */
+MenuNode::~ MenuNode( )
+{
+  destroy();
+}
+
+/**
+ * Destroy Object
+ */
+void MenuNode::destroy( )
+{
+  delete _menu;
+  delete _menuEntry;
+  _objType   = MenuNode::UNDEFINED;
+  _menu      = NULL;
+  _menuEntry = NULL;
+}
+
+/**
+ * 
+ * @param menu 
+ */
+void MenuNode::SetNode( Menu * menu )
+{
+     _menu    = menu;
+     if( menu->GetSystem() != NULL )
+       _objType = MENUSYSTEM;
+     else
+       _objType = MENU;
+}
+
+/**
+ * 
+ * @param menuEntry 
+ */
+void MenuNode::SetNode( MenuEntry * menuEntry )
+{
+     _menuEntry  = menuEntry;
+     _objType    = ENTRY;
+}
+
+/**
+ * 
+ * @return 
+ */
+MenuNode::Type MenuNode::GetType( )
+{
+  return(_objType);
+}
+
+/**
+ * 
+ * @return 
+ */
+Menu * MenuNode::GetMenu( )
+{
+  if( _objType == MENU || _objType == MENUSYSTEM)
+    return(_menu);
+  else
+    return(NULL);
+}
+
+/**
+ * 
+ * @return 
+ */
+MenuEntry * MenuNode::GetMenuEntry( )
+{
+  if( _objType == ENTRY)
+    return(_menuEntry);
+  else
+    return(NULL);
+}
+
+int MenuNode::GetNr( )
+{
+  if( _objType == MENU)
+    return(_menu->GetNr());
+  else
+    return(_menuEntry->GetNr());
+
+}
+
+MenuNode * MenuNode::GetNode( int index )
+{
+  if( _objType == MENU)
+    return(_menu->GetNode(index));
+  else
+    return(_menuEntry->GetNode(index));
+}
+
+
+/**
+ * 
+ * @return 
+ */
+const char * MenuNode::GetName( )
+{
+  const char* result = NULL;
+
+  if( _menu != NULL)  result= _menu->GetName();
+  else
+  if( _menuEntry != NULL)  result= _menuEntry->GetName();
+
+  return(result);
+}
+
+
+/**
+ * 
+ */
+ void MenuNode::Print( int offset)
+{
+  if( _objType == MenuNode::MENU)
+  {
+    _menu->Print(offset);
+  }
+  else
+   if( _objType == MenuNode::ENTRY)
+   {
+    _menuEntry->Print(offset);
+   }
+}
+/**
+ * 
+ */
+ void MenuNode::Print()
+{
+  Print(0);
+}
+
+void MenuNode::SetSysConfig( Sysconfig *sysconf )
+{
+  if( _objType == ENTRY)
+  {
+     _menuEntry->SetSysConfig(sysconf);
+  }
+  else
+    _menu->SetSysConfig(sysconf);
+}
+
+
+
+// ###################################################################################
+//  Menu
+// ###################################################################################
+
+/**
+ * 
+ * @return 
+ */
+Menu::Menu()
+{
+  _name    = NULL;
+  _command = NULL;
+  _help    = NULL;
+  _help2   = NULL;
+  _system  = NULL;
+}
+
+/**
+ * 
+ * @param name 
+ * @return 
+ */
+Menu::Menu(const char * name )
+{
+  _name    = NULL;
+  _command = NULL;
+  _help    = NULL;
+  _help2   = NULL;
+  _system  = NULL;
+  SetName(name);
+}
+
+
+/**
+ * 
+ * @return 
+ */
+Menu::~ Menu( )
+{
+  destroy();
+}
+
+
+
+/**
+ * Destroy Object
+ */
+void Menu::destroy( )
+{
+  delete [] _name;
+  delete [] _command;
+  delete [] _help;
+  delete [] _help2;
+  delete [] _system;
+  _name    = NULL;
+  _command = NULL;
+  _system  = NULL;
+  _help    = NULL;
+  _help2    = NULL;
+}
+
+
+
+
+/**
+ * set name of menu
+ * @param nam specifies the name of the menu
+ */
+void Menu::SetName( const char * nam )
+{
+  delete [] _name;
+  _name=Util::Strdupnew(nam);
+}
+
+/**
+ * return Menu Name
+ * @return name of menu
+ */
+const char * Menu::GetName( )
+{
+ return(_name);
+}
+
+/**
+ * return Menu Comand
+ * @return command of menu
+ */
+const char * Menu::GetCommand( )
+{
+  return(_command);
+}
+
+
+/**
+ * set command of menu
+ * @param command specifies the command of the menu
+ */
+void Menu::SetCommand( const char * command )
+{
+  delete [] _command;
+  _command=Util::Strdupnew(command);
+}
+
+
+/**
+ * return Menu System
+ * @return system command of menu
+ */
+const char * Menu::GetSystem( )
+{
+  return(_system);
+}
+
+
+/**
+ * set system command of menu
+ * @param system specifies the system command of the menu
+ */
+void Menu::SetSystem( const char * system )
+{
+  delete [] _system;
+  _system=Util::Strdupnew(system);
+}
+
+/**
+ * Add the given node to the Node List
+ * @param menu pointer to allocate Menu Object
+ */
+void Menu::AddNode( Menu * menu )
+{
+     MenuNode *n = new MenuNode;
+     n->SetNode(menu);
+     _subMenus.Add(n);
+}
+
+/**
+ * Add the given node to the Node List
+ * @param menuEntry pointer to allocate MenuEntry Object
+ */
+void Menu::AddNode( MenuEntry * menuEntry )
+{
+     MenuNode *n = new MenuNode;
+     n->SetNode(menuEntry);
+     _subMenus.Add(n);
+}
+
+
+/**
+ * Load XMl subtrre
+ * @param xmlNode current XMl Node to Parse
+ * @return true on success
+ */
+bool Menu::LoadXml( TiXmlNode * xmlNode )
+{
+  bool ok = true;
+  TiXmlElement *elem = NULL;
+
+  if(xmlNode != NULL && xmlNode->Type() == TiXmlNode::ELEMENT)
+  {
+    do
+    {
+        if(xmlNode->Type() == TiXmlNode::ELEMENT)
+        {
+          elem = xmlNode->ToElement ();
+          if( strcmp(xmlNode->Value(), "menu")== 0)
+          {
+                const char* name    = elem->Attribute("name");
+                const char* command = elem->Attribute("command");
+                const char* system  = elem->Attribute("system");
+                const char* help1   = elem->Attribute("help1");
+                const char* help2   = elem->Attribute("help2");
+                if( name != NULL )
+                {
+                    Menu * m = new Menu(name);
+
+                    if( m!= NULL && (ok=m->LoadXml(xmlNode->FirstChild()))== true )
+                    {
+                      m->SetCommand(command);
+                      m->SetHelp1(help1);
+                      m->SetHelp2(help2);
+                      m->SetSystem(system);
+                      AddNode(m);
+                    }
+                    else
+                        delete m;
+                }
+                else
+                    ok = false;
+
+           }
+           else
+            if( strcmp(xmlNode->Value(), "entry")== 0)
+            {   const char* command = elem->Attribute("command");
+                const char* help1   = elem->Attribute("help1");
+                const char* help2   = elem->Attribute("help2");
+                MenuEntry * e = new MenuEntry();
+
+                if( e != NULL && (ok=e->AddEntry(xmlNode))== true )
+                {
+                    e->SetCommand(command);
+                    e->SetHelp1(help1);
+                    e->SetHelp2(help2);
+                    AddNode(e);
+                }
+                else
+                    delete e;
+            }
+        }
+    
+    }while( (xmlNode=xmlNode->NextSibling())!=NULL && ok == true);
+    
+  }
+  
+  return(ok);
+}
+
+/**
+ * Save Menu to XML Structure
+ * @param xml xml structure
+ * @return true on success
+ */
+TiXmlNode *Menu::SaveXml()
+{   
+  bool ok = true;
+  TiXmlElement  *m   = new TiXmlElement("menu");
+  TiXmlNode  *tmp = NULL;
+
+  m->SetAttribute("name", GetName());
+  if( GetCommand()!= NULL)
+    m->SetAttribute("command", GetCommand());
+  if( GetHelp1() != NULL)
+    m->SetAttribute("help1", GetHelp1());
+  
+  if( GetHelp2() != NULL)
+    m->SetAttribute("help2", GetHelp2());
+  
+  if( GetSystem()!= NULL)
+    m->SetAttribute("system", GetSystem());
+  
+  for (MenuNode *subMenu = _subMenus.First(); subMenu; subMenu = _subMenus.Next(subMenu))
+  {
+    if(subMenu->GetType() == MenuNode::MENU ||
+       subMenu->GetType() == MenuNode::MENUSYSTEM)
+    {
+       tmp=subMenu->GetMenu()->SaveXml();
+    }
+    else
+     if(subMenu->GetType() == MenuNode::ENTRY)
+     {
+       tmp=subMenu->GetMenuEntry()->SaveXml();
+     }
+
+    
+    if( tmp != NULL)
+       m->LinkEndChild(tmp);
+    else
+      ok=false;
+  }
+
+  if( ok=false)
+  {
+    delete m;
+    m = NULL;
+  }
+  
+  return(m);
+}
+
+
+/**
+ * return Help for Menu/Entry
+ * @return help of menu/entry
+ */
+const char * Menu::GetHelp1( )
+{
+  return(_help);
+}
+
+
+/**
+ * set help for menu/entry
+ * @param command specifies the help for the menu/entry
+ */
+void Menu::SetHelp1( const char * help )
+{
+  delete [] _help;
+  _help=Util::Strdupnew(help);
+}
+
+/**
+ * return Detailed Help for Menu/Entry
+ * @return help of menu/entry
+ */
+const char * Menu::GetHelp2( )
+{
+  return(_help2);
+}
+
+
+/**
+ * set detailed help for menu/entry
+ * @param command specifies the help for the menu/entry
+ */
+void Menu::SetHelp2( const char * help )
+{
+  delete [] _help2;
+  _help2=Util::Strdupnew(help);
+}
+
+int Menu::GetNr( )
+{
+  return(_subMenus.Count());
+}
+
+/**
+ * 
+ * @param index 
+ * @return 
+ */
+MenuNode * Menu::GetNode( int index )
+{
+  return(_subMenus.Get(index));
+}
+
+
+
+
+void Menu::SetSysConfig( Sysconfig *sysconf )
+{
+
+  for (MenuNode *subMenu = _subMenus.First(); subMenu; subMenu = _subMenus.Next(subMenu))
+  {
+    subMenu->SetSysConfig(sysconf );
+  }
+}
+
+
+
+/**
+ * 
+ */
+ void Menu::Print( int offset)
+{
+  for(int i=0; i<offset; i++)
+     printf("-");
+    
+  printf("Menu: Name: %s \n",   _name);
+
+  for (MenuNode *subMenu = _subMenus.First(); subMenu; subMenu = _subMenus.Next(subMenu))
+  {
+    for(int j=0; j<offset; j++)
+        printf("-");
+    subMenu->Print(offset+4);
+  }
+}
+/**
+ * 
+ */
+ void Menu::Print()
+{
+  Print(0);
+}
+
+
+// ###################################################################################
+//  MenuEntry
+// ###################################################################################
+/**
+ * 
+ * @return 
+ */
+MenuEntry::MenuEntry( )
+{
+  _sysconfigName = NULL;
+  _valueText     = NULL;
+  _valueIp       = NULL;
+  _valueTextMaxLen = 0;
+  _valueIpMaxLen = 0;
+  _valueNumber   = 0;
+  _valueBool     = 0;
+  _setupCommand  = NULL;
+  _type          = Util::UNDEFINED;
+  _command       = NULL;
+  _help          = NULL;
+  _help2         = NULL;
+  _system        = NULL;
+}
+
+/**
+ * 
+ * @return 
+ */
+MenuEntry::~ MenuEntry( )
+{
+  destroy();
+}
+
+
+/**
+ * Destroy Object
+ */
+void MenuEntry::destroy( )
+{
+  delete [] _sysconfigName;
+  delete [] _valueText;
+  delete [] _valueIp;
+  delete [] _setupCommand;
+  delete [] _help;
+  delete [] _help2;
+  _sysconfigName = NULL;
+  _valueText     = NULL;
+  _valueIp       = NULL;
+  _setupCommand  = NULL;
+  _help          = NULL;
+  _help2         = NULL;
+}
+
+
+
+/**
+ * set the corrspondig name in the sysconfig file
+ * @param nam the name used in the sysconfig file
+ */
+void MenuEntry::SetSysconfigName( const char * name )
+{
+ _sysconfigName = Util::Strdupnew(name);
+}
+
+/**
+ * 
+ * @return the name used in the sysconfig file
+ */
+const char * MenuEntry::GetSysconfigName( )
+{
+ return(_sysconfigName);
+}
+
+
+
+/**
+ * 
+ * @param typ Set Type
+ */
+void MenuEntry::SetType( Util::Type typ )
+{
+  _type = typ;
+}
+
+
+/**
+ * 
+ * @return 
+ */
+Util::Type MenuEntry::GetType( )
+{
+  return(_type);
+}
+
+
+/**
+ * Set the Value
+ * @param val 
+ */
+void MenuEntry::SetValue(Util::Type type,const char * val )
+{
+  _type = type;
+  switch(_type)
+  {
+    case Util::BOOL: Util::isBool(val, _valueBool);
+                     break;
+
+    case Util::TEXT: _valueText = Util::Strdupnew(val, VALUETEXTMAXLEN);
+                     _valueTextMaxLen = VALUETEXTMAXLEN;
+                     break;
+    case Util::IP:   _valueIp = Util::Strdupnew(val, VALUEIPMAXLEN);
+                     _valueIpMaxLen = VALUEIPMAXLEN;
+                     break;
+    case Util::NUMBER_TEXT: _valueText = Util::Strdupnew(val, VALUETEXTMAXLEN);
+                     _valueTextMaxLen = VALUETEXTMAXLEN;
+                     break;
+    case Util::HEX:  _valueText = Util::Strdupnew(val, VALUETEXTMAXLEN);
+                     _valueTextMaxLen = VALUETEXTMAXLEN;
+                     break;
+    case Util::NUMBER: Util::isNumber(val, _valueNumber);
+                      break;
+    
+    case Util::SELECTION:
+                     _valueText = Util::Strdupnew(val, VALUETEXTMAXLEN);
+                     _valueTextMaxLen = VALUETEXTMAXLEN;
+                      break;
+    case Util::UNDEFINED:
+                 break;
+  }
+  
+}
+
+const char * MenuEntry::GetSelectedValue( )
+{
+   return(_selectionValues.GetSelectedValue());
+}
+
+
+const char * MenuEntry::GetSelectionValue( int index )
+{
+  return(_selectionValues.GetValue(index));
+}
+
+int MenuEntry::GetNrOfSelectionValues( )
+{
+  return(_selectionValues.GetNr());
+}
+
+const char ** MenuEntry::GetSelectionValues( )
+{
+  return(_selectionValues.GetValues());
+}
+
+void MenuEntry::SetSelection( const char * val)
+{
+  _selectionValues.SetSelection(val);
+}
+void MenuEntry::SetSetupCommand( const char * command )
+{
+  _setupCommand = Util::Strdupnew(command);
+}
+
+const char * MenuEntry::GetSetupCommand( )
+{
+  return(_setupCommand);
+}
+
+
+/**
+ * Return the Value
+ * @return 
+ */
+const char * MenuEntry::GetValue( )
+{
+ return(_valueText);
+}
+
+
+int MenuEntry::GetValueTextMaxLen( )
+{
+  return(_valueTextMaxLen);
+}
+
+/**
+ * 
+ * @return 
+ */
+const char * MenuEntry::GetValueAsString( )
+{
+  const char * result=NULL;
+  static char numberStr[20];
+  
+  switch(_type)
+  {
+    case Util::BOOL: result   = Util::boolToStr(_valueBool); 
+                     break;
+
+    case Util::NUMBER_TEXT:
+    case Util::HEX:
+    case Util::TEXT:   result   =_valueText;
+                       break;
+    case Util::IP:     result = _valueIp;
+                       break;
+    case Util::NUMBER: sprintf(numberStr,"%d", _valueNumber);
+                       result = (const char*) numberStr;
+                       break;
+    case Util::SELECTION:
+                   result=_selectionValues.GetSelectedValue();
+                   break;
+    default:
+                 result=Util::typeToStr(_type);
+                 break;
+  }
+  return(result);
+}
+
+/**
+ * 
+ * @return 
+ */
+int * MenuEntry::GetValueBoolRef( )
+{
+  return(&_valueBool);
+}
+
+/**
+ * 
+ * @return 
+ */
+int * MenuEntry::GetValueNumberRef( )
+{
+  return(&_valueNumber);
+}
+
+
+
+/**
+ * 
+ * @param node 
+ * @param selection 
+ * @return 
+ */
+bool MenuEntry::AddSelectionValues( TiXmlNode * node, const char*selection )
+{
+    bool ok = true;
+
+    if( _setupCommand != NULL)
+    {
+     if(strcmp(_setupCommand, "networkdriver")==0)
+     {
+       ok = ReadNetworkDrivers();
+       _selectionValues.SetSelection(selection);
+     }
+     if( strcmp(_setupCommand, "channellist")==0 )
+     {
+       ok = ChannelList();
+     }
+    }
+    else
+        if( node != NULL && node->Type() == TiXmlNode::ELEMENT)
+        {
+            do
+            {
+                _selectionValues.Add(node->FirstChild()->Value());
+            }while( (node=node->NextSibling("value"))!= NULL  && ok==true);
+            _selectionValues.SetSelection(selection);
+        }
+    return(ok);
+}
+
+
+
+/**
+ * 
+ * @return 
+ */
+bool MenuEntry::ChannelList( )
+{
+  bool ok = true;
+  DIR        *dirFP = NULL;
+  char * channelDir=NULL;
+  char * channelFile=NULL;
+  struct dirent *entry = NULL;
+
+  asprintf(&channelDir,"%s", cPlugin::ConfigDirectory());
+  char *tmp = strrchr(channelDir,'/');
+  *tmp = '\0';
+
+  asprintf(&channelFile, "%s/channels.conf",channelDir);
+  asprintf(&channelDir,  "%s/channels",channelDir);
+
+  
+   if(  (dirFP = opendir(channelDir))!= NULL)
+   {
+        while( (entry=readdir(dirFP))!=NULL)
+        {
+            char *tmp=NULL;
+
+            if( (tmp=strstr(entry->d_name, ".conf"))!= NULL)
+            {
+              tmp[0]='\0';
+              _selectionValues.Add(entry->d_name);
+            }
+        }
+        char buf[PATH_MAX];
+        if( realpath(channelFile, buf) != NULL)
+        {
+          _selectionValues.SetSelection(buf);
+        }
+        else
+        {
+          DEBUG4("%s Can not resolve realpath of %s  errno=%d\n", DBG_PREFIX, channelFile, errno );
+          ok = false;
+        }
+   }
+   else
+   {
+     DEBUG4("%s Can not read directory:%s  errno=%d\n", DBG_PREFIX, channelDir, errno);
+   }
+   
+   if( dirFP!=NULL ) closedir(dirFP);
+   if( channelDir != NULL) free(channelDir);
+   if( channelFile != NULL) free(channelFile);
+   
+   return(ok);
+  
+}
+
+
+
+/**
+ * 
+ * @return 
+ */
+bool MenuEntry::ReadNetworkDrivers( )
+{
+ struct utsname uName;
+ bool ok=true;
+ 
+ if( uname(&uName) == 0)
+ {
+   char * dir = NULL;
+      
+   asprintf(&dir, "/lib/modules/%s/kernel/drivers/net", uName.release);
+   readNetworkDriversDir(dir, "");
+   if( dir!= NULL) free(dir);
+ }
+ else
+ {
+   DEBUG3("%s UNAME failed, errno=%d\n", DBG_PREFIX, errno);
+   ok=false;
+ }
+
+ return(ok);
+}
+
+/**
+ * 
+ * @param dir 
+ * @return 
+ */
+bool MenuEntry::readNetworkDriversDir(char *dir, char *prefix)
+{
+ DIR           *modDir = NULL;
+ struct dirent *entry  = NULL;
+ struct stat   buf;
+ bool ok=true;
+ char *path=NULL;
+
+   asprintf(&path, "%s/%s", dir, prefix);
+
+   if(  (modDir = opendir(path))!= NULL)
+   {
+        _selectionValues.Add("AUTODETECT");
+        _selectionValues.Add("ndiswrapper");
+        while( (entry=readdir(modDir))!=NULL)
+        {   
+
+            if( strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0)
+            {
+                char *tmp=NULL;                
+                asprintf(&tmp, "%s/%s", path, entry->d_name);
+                stat(tmp, &buf);
+                free(tmp);
+                
+                if( S_ISDIR(buf.st_mode))
+                {
+
+                  char *newPrefix=NULL;
+                  if(strlen(prefix)>0)
+                    asprintf(&newPrefix, "%s/%s", prefix, entry->d_name);
+                  else
+                    asprintf(&newPrefix, "%s", entry->d_name);
+                  readNetworkDriversDir(dir, newPrefix);
+                  free(newPrefix);
+                }
+                else
+                if( S_ISREG(buf.st_mode))
+                {
+                    if( (tmp=strstr(entry->d_name, ".o")) != NULL ||
+                        (tmp=strstr(entry->d_name, ".ko"))!= NULL)
+                    {
+                      tmp[0] = '\0';
+                      char *myEntry=NULL;
+                      if(strlen(prefix)!= 0)
+                         asprintf(&myEntry, "%s/%s", prefix, entry->d_name);
+                      else
+                         asprintf(&myEntry, "%s", entry->d_name);
+                      _selectionValues.Add(myEntry);
+                      free(myEntry);
+                    }
+                }
+            }
+        }
+   }
+   else
+   {
+     ok=false;
+     DEBUG4("%s Can not read directory:%s  errno=%d\n", DBG_PREFIX, path, errno);
+   }
+   if( modDir!=NULL ) closedir(modDir);
+   if( path!=NULL) free(path);
+   
+   return(ok);
+}
+
+int * MenuEntry::GetReferenceSelection( )
+{
+ return(_selectionValues.GetReferenceSelection());
+}
+
+
+/**
+ * Add SubEntry to
+ * @param node XML poiter to subtree
+ * @return ok on success
+ */
+bool MenuEntry::AddEntry( TiXmlNode *node  )
+{
+    bool          ok   = true;
+    TiXmlElement *elem = NULL;
+
+    if(node != NULL && node->Type() == TiXmlNode::ELEMENT)
+    {
+
+      elem = node->ToElement ();
+      const char* nam      = elem->Attribute("name");
+      const char* sysconf  = elem->Attribute("sysconfig");
+      const char* typStr   = elem->Attribute("type");
+      const char* val      = elem->Attribute("value");
+      const char* setup    = elem->Attribute("setup");
+    
+      Util::Type  typ      = Util::UNDEFINED;
+      if( nam != NULL && sysconf!= NULL && typStr != NULL && val != NULL &&
+          Util::isType(typStr, typ))
+      {
+        if( Sysconfig::GetVariable(sysconf) != NULL)
+          val=Sysconfig::GetVariable(sysconf);
+    
+        SetName(nam);
+        SetSysconfigName(sysconf);
+        SetValue(typ, val);
+        SetSetupCommand(setup);
+
+        //CHILDLOCK
+        if( setup != NULL && strcmp(setup, "childlock")== 0)
+           Config::SetChildLock(GetValue());
+    
+        ok = AddSelectionValues(node->FirstChild("value"), val);
+        if(ok    == true &&
+           _type == Util::SELECTION)  // Set Selection
+        {
+         SetSelection (val);
+        }
+      }
+      else
+      {
+        DEBUG4("%s Error in XML File, Column=%d Row%d\n", DBG_PREFIX, node->Column (), node->Row());
+        ok = false;
+      }
+
+    }
+
+    return(ok);
+}
+
+
+/**
+ * Convert ENtry in XML Structure
+ * @return xml Element or NULL if error
+ */
+TiXmlNode *MenuEntry::SaveXml( )
+{
+
+  TiXmlElement *e = new TiXmlElement("entry");
+  if( e != NULL )
+  {
+    e->SetAttribute("name", GetName());
+    e->SetAttribute("sysconfig", GetSysconfigName());
+    e->SetAttribute("type", Util::typeToStr(_type));
+
+    if( _setupCommand != NULL )
+        e->SetAttribute("setup", _setupCommand);
+
+    if( _type == Util::SELECTION)
+    {
+        if( _setupCommand != NULL )
+        {
+            if(strcmp(_setupCommand, "channellist")==0)
+              Util::SwitchChannelList(GetSelectedValue());
+        }
+        else
+        {
+            for(int i=0; i< GetNrOfSelectionValues(); i++)
+            {
+            TiXmlElement *e1 = new TiXmlElement("value");
+            e1->LinkEndChild( new TiXmlText (GetSelectionValue(i)));
+            e->LinkEndChild(e1);
+            }
+    
+        }
+        e->SetAttribute("value", GetSelectedValue());
+    }
+    else
+      e->SetAttribute("value", GetValueAsString());
+    
+    if( GetCommand()!= NULL)
+      e->SetAttribute("command", GetCommand());
+    
+    if( GetHelp1()!= NULL)
+      e->SetAttribute("help1", GetHelp1());
+
+    if( GetHelp2()!= NULL)
+      e->SetAttribute("help2", GetHelp2());
+
+  }
+
+  for (MenuNode *subMenu = _subMenus.First(); subMenu; subMenu = _subMenus.Next(subMenu))
+  {
+    e->LinkEndChild(subMenu->GetMenuEntry()->SaveXml());
+  }
+
+  
+  return(e);
+}
+
+
+
+
+void MenuEntry::SetSysConfig( Sysconfig *sysconf )
+{
+  sysconf->SetVariable(GetSysconfigName(), GetValueAsString());
+
+  for (MenuNode *subMenu = _subMenus.First(); subMenu; subMenu = _subMenus.Next(subMenu))
+  {
+    subMenu->SetSysConfig(sysconf );
+  }
+}
+
+
+/**
+ * 
+ */
+void MenuEntry::Print( int offset)
+{
+  for(int i=0; i<offset; i++)
+     printf("-");
+    
+  printf("Entry: Name: %s SysconfigName=%s Type=%s Value=%s",
+          _name, _sysconfigName, Util::typeToStr(_type), GetValueAsString());
+  if( _command != NULL ) printf(" command=%s", _command);
+  if( _help    != NULL ) printf(" command=%s", _help);
+  _selectionValues.Print(offset);
+  
+
+    for (MenuNode *subMenu = _subMenus.First(); subMenu; subMenu = _subMenus.Next(subMenu))
+    {
+       for(int j=0; j<offset; j++)
+         printf("-");
+          subMenu->Print(offset+4);
+    }
+
+}
+/**
+ * 
+ */
+void MenuEntry::Print()
+{
+  Print(0);
+}
+
+
+// ###################################################################################
+//  Menus
+// ###################################################################################
+
+
+/**
+ * Constructor of Object
+ * 
+ */
+Menus::Menus()
+{
+
+}
+
+
+/**
+ * Destructor of Object
+ * 
+ */
+Menus::~Menus()
+{
+}
+
+/**
+ * return the numer of menus
+ * @return 
+ */
+int Menus::GetNr( )
+{
+  return(Count());
+}
+
+
+/**
+ * Load XML representation
+ * @param node current node in XML Tree
+ * @return true on success
+ */
+bool Menus::LoadXml( TiXmlNode * node )
+{
+   bool ok = true;
+   TiXmlElement *elem = NULL;
+   if(node != NULL && node->Type() == TiXmlNode::ELEMENT && (node=node->FirstChild())!=NULL)
+   {
+        do
+        {
+           if(node->Type() == TiXmlNode::ELEMENT && strcmp(node->Value(), "menu")== 0)
+           {
+            elem = node->ToElement ();
+            const char* name = elem->Attribute("name");
+            const char* command = elem->Attribute("command");
+            const char* system = elem->Attribute("system");
+            const char* help1   = elem->Attribute("help1");
+            const char* help2   = elem->Attribute("help2");
+            if( name != NULL )
+            {
+              Menu * m = new Menu(name);
+              m->SetCommand(command);
+              m->SetSystem(system);
+              m->SetHelp1(help1);
+              m->SetHelp2(help2);
+              if( m!= NULL && (ok=m->LoadXml(node->FirstChild()))== true )
+                 ok=AddNode(m);
+              else
+                 delete m;
+            }
+            else
+            {
+             ok = false;
+            }
+           }
+        }while( (node=node->NextSibling())!=NULL && ok == true);
+   }
+   else
+     ok = false;
+
+   return(ok);
+}
+
+
+/**
+ * Save Menues to XML Structure
+ * @param xml XML structure
+ * @return true on success
+ */
+bool Menus::SaveXml(TiXmlNode * root)
+{
+  bool ok = true;
+  TiXmlNode *tmp   = NULL;
+  TiXmlElement  *m   = new TiXmlElement("menus"); // Root element of menus
+  for(int i=0; i<Count() && ok==true; i++)
+  {
+    if( (tmp=Get(i)->GetMenu()->SaveXml()) != NULL)
+    {
+      m->LinkEndChild(tmp);
+    }
+    else
+      ok=false;
+  }
+  root->LinkEndChild(m);
+  return(ok);
+}
+
+
+/**
+ * Add a Menu Node
+ * @param name name of Menu
+ * @param xmlNode current XML Node
+ * @return true on success
+ */
+bool Menus::AddNode( Menu *menu )
+{
+    bool ok = true;
+    
+     MenuNode *n = new MenuNode;
+     Add(n);
+
+     n->SetNode(menu);
+
+    return(ok);
+
+}
+
+/**
+ * Return refernce to specified Menu
+ * @param index of menu
+ * @return pointer to menu
+ */
+MenuNode  *Menus::GetMenuNode(int index)
+{
+  return(Get(index));
+}
+
+
+/**
+ * Print Nodes
+ */
+void Menus::Print( )
+{
+  for( int i=0; i<Count(); i++)
+    Get(i)->Print();
+}
+
+
+// ###################################################################################
+//  MenuEntryValueList
+// ###################################################################################
+
+MenuEntryValueList::MenuEntryValueList( )
+{
+  _values = NULL;
+  _nr    = 0;
+  _selection =0;
+
+}
+
+MenuEntryValueList::~ MenuEntryValueList( )
+{
+  destroy();
+}
+
+void MenuEntryValueList::copy( MenuEntryValueList const & other )
+{
+
+  for(int i=0; i<other._nr;i++)
+  {   
+    Add(other._values[i]);
+  }
+  _nr = other._nr;
+  _selection = other._selection;
+
+}
+
+void MenuEntryValueList::destroy( )
+{
+ if( _values != NULL )
+ {
+    for( int i=0; i<_nr; i++)
+        delete [] _values[i];
+    delete [] _values;
+    _nr=0;
+ }
+ _values = NULL;
+}
+
+
+
+MenuEntryValueList const &MenuEntryValueList::operator =(MenuEntryValueList const &right )
+{
+ if( this != &right)
+ {
+   destroy();
+   copy(right);
+ }
+ return(*this);
+}
+
+
+void MenuEntryValueList::Add( const char * value )
+{
+  const char **vals = new  const char*[_nr + 1];
+
+  for(int i=0; i<_nr; i++)
+  {
+    vals[i] = Util::Strdupnew(_values[i]);
+  }
+  
+  vals[_nr] =  Util::Strdupnew(value);
+  int nr =_nr;
+  destroy();
+  _nr =++nr;
+  _values  = vals;
+  
+  
+}
+
+void MenuEntryValueList::Print( )
+{
+  Print(0);
+}
+
+void MenuEntryValueList::Print( int offset )
+{
+ if( _nr >0)
+ {
+
+    
+    for(int i=0; i<_nr; i++)
+    {
+        for(int j=0; j<offset+2; j++)
+           printf("-");
+        printf("Value[%d]=%s\n", i, _values[i]);
+    }
+ }
+}
+
+
+int MenuEntryValueList::GetNr( )
+{
+  return(_nr);
+}
+
+const char * MenuEntryValueList::GetValue( int index )
+{
+  const char*result=NULL;
+  if(_nr > 0 && index <_nr && index >=0)
+  {
+    result=_values[index];
+  }
+  return(result);
+}
+
+const char ** MenuEntryValueList::GetValues( )
+{
+ return(_values);
+}
+
+int * MenuEntryValueList::GetReferenceSelection( )
+{
+ return(&_selection);
+}
+
+
+
+
+void MenuEntryValueList::SetSelection( const char * value )
+{
+  bool found =false;
+  _selection = 0;
+
+  for(int i=0; i<_nr && found==false; i++)
+  {
+    if( strcmp(_values[i], value)== 0)
+    {
+      _selection =i;
+      found=true;
+    }
+  }
+}
+
+
+
+const char * MenuEntryValueList::GetSelectedValue( )
+{
+  if(_nr == 0)
+    return(NULL);
+  else
+  {
+    return(_values[_selection]);
+  }
+}
Index: vdr-2.2.0/PLUGINS/src/setup/menus.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/menus.h	2015-12-24 15:16:31.684279546 +0100
@@ -0,0 +1,185 @@
+/*********************************************************
+ * DESCRIPTION: 
+ *             Header File
+ *
+ * $Id: menus.h,v 1.11 2006/03/05 09:47:26 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ *********************************************************/
+
+#ifndef MENUS_H
+#define MENUS_H
+#include <vdr/tools.h>
+#include "util.h"
+#include "tinystr.h"
+#include "sysconfig.h"
+
+
+/**
+@author Ralf Dotzert
+*/
+
+
+class Menu;
+class MenuEntry;
+class MenuEntryValueList;
+class MenuNode;
+
+class SubMenus : public cList<MenuNode> {};
+
+
+class MenuNode :  public cListObject
+{
+public:
+enum Type { UNDEFINED, MENU, MENUSYSTEM, ENTRY};
+    MenuNode();
+    virtual ~MenuNode();
+    void destroy();
+    void SetNode(Menu *menu);
+    void SetNode(MenuEntry *menuEntry);
+    Menu      *GetMenu();
+    MenuEntry *GetMenuEntry();
+    MenuNode::Type GetType();
+    const char *GetName();
+    int GetNr();
+    MenuNode *GetNode(int index);
+    void Print();
+    void Print(int offset);
+    void SetSysConfig(Sysconfig *sysconf);
+private:
+MenuNode::Type  _objType;
+Menu           *_menu;
+MenuEntry      *_menuEntry;
+};
+
+
+
+
+class Menu
+{
+protected:
+const char *_name;
+const char *_command;
+const char *_system;
+SubMenus   _subMenus;
+const char *_help;
+const char *_help2;
+public:
+    Menu();
+    Menu(const char *name);
+    virtual ~Menu();
+    void destroy();
+    void SetName(const char *nam);
+    const char *GetName();
+    void SetCommand(const char *command);
+    const char *GetCommand();
+    void SetSystem(const char *system);
+    const char *GetSystem();
+    int  GetNr();
+    const char * GetHelp1( );
+    void SetHelp1( const char * help );
+    const char * GetHelp2( );
+    void SetHelp2( const char * help );
+    MenuNode *GetNode(int index);
+    void AddNode(Menu* menu);
+    void AddNode(MenuEntry* menuEntry);
+    bool LoadXml( TiXmlNode *node  );
+    void SetSysConfig(Sysconfig *sysconf);
+    TiXmlNode *SaveXml();
+    virtual void Print();
+    virtual void Print(int offset);
+};
+
+class MenuEntryValueList
+{
+  private:
+  const char **_values;
+  int          _nr;
+  int         _selection;
+  public:
+    MenuEntryValueList();
+    ~MenuEntryValueList();
+    MenuEntryValueList const &operator =(MenuEntryValueList const &right   );
+    void copy(MenuEntryValueList const &other);
+    void destroy();
+    void Add(const char *value);
+    int  GetNr();
+    const char*GetValue(int index);
+    const char**GetValues();
+    int  *GetReferenceSelection();
+    const char *GetSelectedValue();
+    void SetSelection(const char *value);
+    void Print();
+    void Print(int offset);
+};
+
+class MenuEntry : public Menu
+{
+protected:
+const char *_sysconfigName;
+const char *_valueText;
+const char *_valueIp;
+const char *_setupCommand;
+int         _valueTextMaxLen;
+int         _valueIpMaxLen;
+int         _valueNumber;
+int         _valueBool;
+MenuEntryValueList  _selectionValues;
+Util::Type  _type;
+public:
+    MenuEntry();
+    ~MenuEntry();
+    void destroy();
+    bool AddEntry( TiXmlNode *node  );
+    bool AddSubEntry( TiXmlNode *node  );
+    bool AddSelectionValues( TiXmlNode *node, const char *selection);
+    TiXmlNode *SaveXml( );
+    void SetSysconfigName(const char* nam);
+    const char*GetSysconfigName();
+    void SetValue(Util::Type type,const char* val);
+    const char*GetValue();
+    const char*GetValueIp() {return _valueIp;}
+    void SetSetupCommand(const char *command);
+    const char* GetSetupCommand();
+    bool  ReadNetworkDrivers( );
+    bool  ChannelList();
+    int   GetNrOfSelectionValues();
+    const char *GetSelectionValue(int index);
+    const char *GetSelectedValue();
+    const char **GetSelectionValues();
+    int   *GetReferenceSelection();
+    void SetSelection(const char* val);
+    int   GetValueTextMaxLen();
+    int   GetValueIpMaxLen() {return _valueIpMaxLen;}
+    int   *GetValueBoolRef();
+    int   *GetValueNumberRef();
+    const char*GetValueAsString();
+    void SetType(Util::Type typ);
+    void SetSysConfig(Sysconfig *sysconf);
+    Util::Type GetType();
+    void Print();
+    void Print(int offset);
+private:
+    bool  readNetworkDriversDir(char *dir, char *prefix);
+};
+
+
+class Menus : public cList<MenuNode> 
+{
+public:
+    Menus();
+    ~Menus();
+    bool LoadXml(TiXmlNode *node);
+    bool SaveXml(TiXmlNode *node);
+    bool AddNode( Menu *menu );
+    int  GetNr();
+
+    MenuNode  *GetMenuNode(int index);
+    void Print();
+    
+};
+
+
+#endif
Index: vdr-2.2.0/PLUGINS/src/setup/patches/setup-0.3.1-zulu-edition_custom-plugin-title.diff
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/patches/setup-0.3.1-zulu-edition_custom-plugin-title.diff	2015-12-24 15:16:31.688279566 +0100
@@ -0,0 +1,3226 @@
+diff -ruN setup-0.3.1-zulu-edition-old/HISTORY setup-0.3.1-zulu-edition/HISTORY
+--- setup-0.3.1-zulu-edition-old/HISTORY	2008-01-30 21:14:17.000000000 +0100
++++ setup-0.3.1-zulu-edition/HISTORY	2008-06-19 10:04:50.000000000 +0200
+@@ -1,5 +1,16 @@
+ VDR Plugin 'setup' Revision History
+ -----------------------------------
++2008-06-19: setup-0.3.1-zulu-edition
++- From now VDR-Extensions-Patch => 63 or
++  VDR-Extensions-Patch 62 + vdr-ext62_setup-custom-plugin-title.diff
++  is required
++- Reworked setupmenu.c and setupmenu.h
++  Added new xml 'title' tag for plugins, from now it is
++  possible to customize the menuentrys for all plugins
++  Two new functions for the 'Menu Edit':
++  - Edit / Move -> Plugins
++  - Add / Edit / Move / Delete -> Commands and Threads
++
+ 2008-01-30: setup-0.3.1-zulu-edition
+ - Reworked the Return Value, now it is possible to set
+   a default value in vdr-setup.xml
+diff -ruN setup-0.3.1-zulu-edition-old/i18n.c setup-0.3.1-zulu-edition/i18n.c
+--- setup-0.3.1-zulu-edition-old/i18n.c	2008-01-22 13:53:42.000000000 +0100
++++ setup-0.3.1-zulu-edition/i18n.c	2008-06-18 09:45:50.000000000 +0200
+@@ -143,6 +143,204 @@
+     "Rediger",
+     "Editace",
+   },
++  { "Title",
++    "Titel",
++    "", // Slovenski
++    "", // Italiano
++    "", // Nederlands
++    "", // Portugus
++    "", // Franais
++    "", // Norsk
++    "", // suomi
++    "", // Polski
++    "", // Espaol
++    "", //  (Greek)
++    "", // Svenska
++    "", // Romaneste
++    "", // Magyar
++    "", // Catal
++    "", //  (Russian)
++    "", // Hrvatski (Croatian)
++    "", // Eesti
++    "", // Dansk
++    "", // esky (Czech)
++  },
++  { "Command",
++    "Befehl",
++    "", // Slovenski
++    "", // Italiano
++    "", // Nederlands
++    "", // Portugus
++    "", // Franais
++    "", // Norsk
++    "", // suomi
++    "", // Polski
++    "", // Espaol
++    "", //  (Greek)
++    "", // Svenska
++    "", // Romaneste
++    "", // Magyar
++    "", // Catal
++    "", //  (Russian)
++    "", // Hrvatski (Croatian)
++    "", // Eesti
++    "", // Dansk
++    "", // esky (Czech)
++  },
++  { "Has to confirm",
++    "Zu besttigen",
++    "", // Slovenski
++    "", // Italiano
++    "", // Nederlands
++    "", // Portugus
++    "", // Franais
++    "", // Norsk
++    "", // suomi
++    "", // Polski
++    "", // Espaol
++    "", //  (Greek)
++    "", // Svenska
++    "", // Romaneste
++    "", // Magyar
++    "", // Catal
++    "", //  (Russian)
++    "", // Hrvatski (Croatian)
++    "", // Eesti
++    "", // Dansk
++    "", // esky (Czech)
++  },
++  { "Execute as thread",
++    "Als Thread ausfhren",
++    "", // Slovenski
++    "", // Italiano
++    "", // Nederlands
++    "", // Portugus
++    "", // Franais
++    "", // Norsk
++    "", // suomi
++    "", // Polski
++    "", // Espaol
++    "", //  (Greek)
++    "", // Svenska
++    "", // Romaneste
++    "", // Magyar
++    "", // Catal
++    "", //  (Russian)
++    "", // Hrvatski (Croatian)
++    "", // Eesti
++    "", // Dansk
++    "", // esky (Czech)
++  },
++  { "Create Command",
++    "Neuer Befehl",
++    "", // Slovenski
++    "", // Italiano
++    "", // Nederlands
++    "", // Portugus
++    "", // Franais
++    "", // Norsk
++    "", // suomi
++    "", // Polski
++    "", // Espaol
++    "", //  (Greek)
++    "", // Svenska
++    "", // Romaneste
++    "", // Magyar
++    "", // Catal
++    "", //  (Russian)
++    "", // Hrvatski (Croatian)
++    "", // Eesti
++    "", // Dansk
++    "", // esky (Czech)
++  },
++  { "Create Menu",
++    "Neues Men",
++    "", // Slovenski
++    "", // Italiano
++    "", // Nederlands
++    "", // Portugus
++    "", // Franais
++    "", // Norsk
++    "", // suomi
++    "", // Polski
++    "", // Espaol
++    "", //  (Greek)
++    "", // Svenska
++    "", // Romaneste
++    "", // Magyar
++    "", // Catal
++    "", //  (Russian)
++    "", // Hrvatski (Croatian)
++    "", // Eesti
++    "", // Dansk
++    "", // esky (Czech)
++  },
++  { "Edit Command",
++    "Editiere Befehl",
++    "", // Slovenski
++    "", // Italiano
++    "", // Nederlands
++    "", // Portugus
++    "", // Franais
++    "", // Norsk
++    "", // suomi
++    "", // Polski
++    "", // Espaol
++    "", //  (Greek)
++    "", // Svenska
++    "", // Romaneste
++    "", // Magyar
++    "", // Catal
++    "", //  (Russian)
++    "", // Hrvatski (Croatian)
++    "", // Eesti
++    "", // Dansk
++    "", // esky (Czech)
++  },
++  { "Edit Plugin",
++    "Editiere Plugin",
++    "", // Slovenski
++    "", // Italiano
++    "", // Nederlands
++    "", // Portugus
++    "", // Franais
++    "", // Norsk
++    "", // suomi
++    "", // Polski
++    "", // Espaol
++    "", //  (Greek)
++    "", // Svenska
++    "", // Romaneste
++    "", // Magyar
++    "", // Catal
++    "", //  (Russian)
++    "", // Hrvatski (Croatian)
++    "", // Eesti
++    "", // Dansk
++    "", // esky (Czech)
++  },
++  { "Edit Menu",
++    "Editiere Men",
++    "", // Slovenski
++    "", // Italiano
++    "", // Nederlands
++    "", // Portugus
++    "", // Franais
++    "", // Norsk
++    "", // suomi
++    "", // Polski
++    "", // Espaol
++    "", //  (Greek)
++    "", // Svenska
++    "", // Romaneste
++    "", // Magyar
++    "", // Catal
++    "", //  (Russian)
++    "", // Hrvatski (Croatian)
++    "", // Eesti
++    "", // Dansk
++    "", // esky (Czech)
++  },
+   { "Delete Menu?",
+     "Men lschen?",
+     "", // Slovenski
+diff -ruN setup-0.3.1-zulu-edition-old/MANUAL.DE setup-0.3.1-zulu-edition/MANUAL.DE
+--- setup-0.3.1-zulu-edition-old/MANUAL.DE	2005-10-12 15:51:30.000000000 +0200
++++ setup-0.3.1-zulu-edition/MANUAL.DE	2008-06-18 08:41:28.000000000 +0200
+@@ -1,7 +1,7 @@
+ ****** Einleitung ******
+ 
+ Das SETUP-Plugin erlaubt die einfache Konfiguration der wichtigsten
+-Systemeinstellungen ber das OSD des VDR's. Dieses Plugin wurde speziell fr die
++Systemeinstellungen ber das OSD des VDR's. Dieses Plugin wurde ursprnglich fr die
+ MiniVDR Distribution entwickelt, kann aber einfach fr andere Distributionen
+ konfiguriert werden.
+ 
+@@ -12,7 +12,7 @@
+ ****** An- und Abwahl von Plugins ******
+ 
+ Per OSD knnen Plugins an oder abgeschaltet werden. Eventuell bentigte Plugin-
+-Parameter knnen im Konfigurationsfile minivdr-setup.xml hinzugefgt werden.
++Parameter knnen im Konfigurationsfile vdr-setup.xml hinzugefgt werden.
+ Eine genderte Plugin-Konfiguration wird erst nach dem nchsten Neustart aktiv.
+ 
+ ***** VDR-Mens *****
+@@ -25,18 +25,20 @@
+          und dessen Patch kann nicht zusammen mit dem Setup-Plugin verwendet
+          werden!
+ 
+-Mens knnen im Setup-Plugin per OSD hinzugefgt, editiert und verschoben
+-werden. Eine genderte Menkonfiguration wird sofort nach dem Speichern und
+-erneutem ffnen des Mens aktiv.
+-
+-In der Menkonfigurationsdatei "vdr-menu.xml" knnen zustzlich Kommandos
+-definiert werden, welche dann wie ein Plugin per OSD ausgefhrt werden knnen.
+-Eventuelle Bildschirmausgaben des Kommandos werden auf dem OSD ausgegeben.
++In der Menkonfigurationsdatei "vdr-menu.xml" knnen Mens, Plugins und Kommandos
++definiert werden, welche dann per OSD ausgefhrt werden knnen.
++Eventuelle Bildschirmausgaben der Kommandos werden auf dem OSD ausgegeben.
++
++Mens und Kommandos knnen im Setup-Plugin auch per OSD hinzugefgt, editiert
++und verschoben werden. Eine genderte Menkonfiguration wird sofort nach dem Speichern
++und erneutem ffnen des Mens aktiv.
++
++Plugins knnen mit einem frei whlbaren Title versehen werden.
+ 
+ ****** Systemkonfiguration ndern ******
+ 
+ Im Setup Plugin knnen die gngigen Systemkonfigurationen per OSD gendert
+-werden. Im Konfigurations-File minivdr-setup.xml knnen dazu beliebige
++werden. Im Konfigurations-File vdr-setup.xml knnen dazu beliebige
+ geschachtelte Mens (XML Tag <menu> </menu> konfiguriert werden. Jedem
+ Systemparameter wird ein Variablenname zugeordnet, der dann im angegebenen
+ System-Konfigurationsfile, welches mit dem Attribut "sysconfigFile" definiert
+@@ -48,8 +50,8 @@
+ ****** Systemvoraussetzungen ******
+ 
+     * In das Plugin Konfigurationsverzeichnis (z.B: /etc/vdr/plugins/setup)
+-      mssen die Dateien minivdr-setup.xml und vdr-menu.xml abgelegt werden.
+-    * Die in der Datei minivdr-setup.xml mit dem Attribut "sysconfigFile
++      mssen die Dateien vdr-setup.xml und vdr-menu.xml abgelegt werden.
++    * Die in der Datei vdr-setup.xml mit dem Attribut "sysconfigFile
+       gekennzeichnete Datei wird vom Plugin angelegt, falls Sie nicht existieren
+       sollte. In dieser Datei werden die Einstellungen in Form von
+       Shellvariablen gespeichert.
+@@ -62,12 +64,7 @@
+ ****** Support ******
+ 
+ Fragen, Verbesserungsvorschlge und eventuelle Fehler knnen direkt ber das
+-Forum im MiniVDR-Portal weiter gegeben werden.
+-
+-
+-
+-
+-
++Forum im VDR-Portal weiter gegeben werden.
+ 
+ 
+ 
+@@ -76,12 +73,12 @@
+ *************************************
+ 
+ Das VDR-Setup Plugin nutzt zwei Konfigurationsdateien.
+-    * minivdr-setup.xml
++    * vdr-setup.xml
+     * vdr-menu.xml
+ 
+-***** Beschreibung minivdr-setup.xml *****
++***** Beschreibung vdr-setup.xml *****
+ 
+-Die Dateiminivdr-setup.xml beschreibt die Konfiguration des Setup-Plugins im XML
++Die Datei vdr-setup.xml beschreibt die Konfiguration des Setup-Plugins im XML
+ Format.
+ 
+ <setup>
+@@ -152,15 +149,14 @@
+               * Replay
+               * Misc
+               * Plugins
+-          Zustzlich zu den VDR-Standardmens sind die folgenden Untermen
++          Zustzlich zu den VDR-Standardmens sind die folgenden Untermens
+           definiert:
+-              * ActPlugins (Aktiviere /Deaktiviere Plugin)
++              * ActPlugins (Aktiviere / Deaktiviere Plugin)
+               * VDRMenu (Editiere das VDR-Men)
+           Whrend dem Build-Prozess werden alle in <vdr>/menu.c definierten
+           Setup-Mens eingelesen und konfiguriert.
+-          Ist z.B. der BigPatch angewendet worden, dann knnen zum Beispiel
+-          zustzlich die folgenden Werte genutzt werden: 
+-              * BigPatch (Men des Bigpatches)
++          Ist der Live-Buffer Patch angewendet worden, kann auch der zustzliche
++          Wert genutzt werden:
+               * LiveBuffer (Men des Live-Buffer Patches)
+ help1     Dieses optionale Attribut gibt einen kurzen Hilfstext an welcher in
+           der Statuszeile angezeigt wird, wenn der Cursor auf dem Eintrag steht.
+diff -ruN setup-0.3.1-zulu-edition-old/po/ca_ES.po setup-0.3.1-zulu-edition/po/ca_ES.po
+--- setup-0.3.1-zulu-edition-old/po/ca_ES.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/ca_ES.po	2008-06-18 09:55:32.000000000 +0200
+@@ -9,7 +9,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Jordi Vil <jvila@tinet.org>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -47,12 +47,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Editar"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Editar"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/cs_CZ.po setup-0.3.1-zulu-edition/po/cs_CZ.po
+--- setup-0.3.1-zulu-edition-old/po/cs_CZ.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/cs_CZ.po	2008-06-18 09:55:32.000000000 +0200
+@@ -7,7 +7,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Vladimr Brta <vladimir.barta@k2atmitec.cz>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -45,12 +45,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Editace"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Editace"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/da_DK.po setup-0.3.1-zulu-edition/po/da_DK.po
+--- setup-0.3.1-zulu-edition-old/po/da_DK.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/da_DK.po	2008-06-18 09:55:32.000000000 +0200
+@@ -7,7 +7,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Mogens Elneff <mogens@elneff.dk>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -45,12 +45,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Rediger"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Rediger"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/de_DE.po setup-0.3.1-zulu-edition/po/de_DE.po
+--- setup-0.3.1-zulu-edition-old/po/de_DE.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/de_DE.po	2008-06-18 09:55:32.000000000 +0200
+@@ -7,7 +7,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Klaus Schmidinger <kls@cadsoft.de>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -45,12 +45,42 @@
+ msgid "Move"
+ msgstr "Verschieben"
+ 
++msgid "Title"
++msgstr "Titel"
++
++msgid "Edit Plugin"
++msgstr "Editiere Plugin"
++
++msgid "Command"
++msgstr "Befehl"
++
++msgid "Has to confirm"
++msgstr "Zu besttigen"
++
++msgid "Execute as thread"
++msgstr "Als Thread ausfhren"
++
++msgid "Edit Command"
++msgstr "Editiere Befehl"
++
++msgid "Edit Menu"
++msgstr "Editiere Men"
++
++msgid "Create Menu"
++msgstr "Neues Men"
++
++msgid "Create Command"
++msgstr "Neuer Befehl"
++
+ msgid "Delete Menu?"
+ msgstr "Men lschen?"
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr "Auf/Ab fr neue Position - dann Farbtaste"
+ 
++msgid "Menu"
++msgstr "Men"
++
+ msgid "Into"
+ msgstr "Hinein"
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/el_GR.po setup-0.3.1-zulu-edition/po/el_GR.po
+--- setup-0.3.1-zulu-edition-old/po/el_GR.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/el_GR.po	2008-06-18 09:55:32.000000000 +0200
+@@ -7,7 +7,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Dimitrios Dimitrakos <mail@dimitrios.de>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -45,12 +45,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr ""
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr ""
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/es_ES.po setup-0.3.1-zulu-edition/po/es_ES.po
+--- setup-0.3.1-zulu-edition-old/po/es_ES.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/es_ES.po	2008-06-18 09:55:32.000000000 +0200
+@@ -7,7 +7,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Ruben Nunez Francisco <ruben.nunez@tang-it.com>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -45,12 +45,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Modificar"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Modificar"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/et_EE.po setup-0.3.1-zulu-edition/po/et_EE.po
+--- setup-0.3.1-zulu-edition-old/po/et_EE.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/et_EE.po	2008-06-18 09:55:32.000000000 +0200
+@@ -7,7 +7,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Arthur Konovalov <kasjas@hot.ee>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -45,12 +45,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Muuda"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Muuda"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/fi_FI.po setup-0.3.1-zulu-edition/po/fi_FI.po
+--- setup-0.3.1-zulu-edition-old/po/fi_FI.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/fi_FI.po	2008-06-18 09:55:32.000000000 +0200
+@@ -10,7 +10,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Rolf Ahrenberg <rahrenbe@cc.hut.fi>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -48,12 +48,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Muokkaa"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Muokkaa"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/fr_FR.po setup-0.3.1-zulu-edition/po/fr_FR.po
+--- setup-0.3.1-zulu-edition-old/po/fr_FR.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/fr_FR.po	2008-06-18 09:55:32.000000000 +0200
+@@ -10,7 +10,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Nicolas Huillard <nhuillard@e-dition.fr>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -48,12 +48,47 @@
+ msgid "Move"
+ msgstr "Dplacer"
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Edition du menu"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Edition du menu"
++
++#, fuzzy
++msgid "Create Menu"
++msgstr "Crer"
++
++#, fuzzy
++msgid "Create Command"
++msgstr "Crer"
++
+ msgid "Delete Menu?"
+ msgstr "Effacer le menu?"
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr "^/v pour nouvel emplacement - touches couleurs pour dplacer"
+ 
++#, fuzzy
++msgid "Menu"
++msgstr "Edition du menu"
++
+ msgid "Into"
+ msgstr "Dans"
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/hr_HR.po setup-0.3.1-zulu-edition/po/hr_HR.po
+--- setup-0.3.1-zulu-edition-old/po/hr_HR.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/hr_HR.po	2008-06-18 09:55:32.000000000 +0200
+@@ -8,7 +8,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Drazen Dupor <drazen.dupor@dupor.com>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -46,12 +46,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Promijeni"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Promijeni"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/hu_HU.po setup-0.3.1-zulu-edition/po/hu_HU.po
+--- setup-0.3.1-zulu-edition-old/po/hu_HU.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/hu_HU.po	2008-06-18 09:55:32.000000000 +0200
+@@ -8,7 +8,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Istvan Koenigsberger <istvnko@hotmail.com>, Guido Josten <guido.josten@t-online.de>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -46,12 +46,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Belltani"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Belltani"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/it_IT.po setup-0.3.1-zulu-edition/po/it_IT.po
+--- setup-0.3.1-zulu-edition-old/po/it_IT.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/it_IT.po	2008-06-18 09:55:32.000000000 +0200
+@@ -9,7 +9,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Sean Carlos <seanc@libero.it>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -47,12 +47,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Modifica"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Modifica"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/nl_NL.po setup-0.3.1-zulu-edition/po/nl_NL.po
+--- setup-0.3.1-zulu-edition-old/po/nl_NL.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/nl_NL.po	2008-06-18 09:55:32.000000000 +0200
+@@ -9,7 +9,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Maarten Wisse <Maarten.Wisse@urz.uni-hd.de>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -47,12 +47,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Verander"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Verander"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/nn_NO.po setup-0.3.1-zulu-edition/po/nn_NO.po
+--- setup-0.3.1-zulu-edition-old/po/nn_NO.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/nn_NO.po	2008-06-18 09:55:32.000000000 +0200
+@@ -8,7 +8,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Truls Slevigen <truls@slevigen.no>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -46,12 +46,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Editer"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Editer"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/pl_PL.po setup-0.3.1-zulu-edition/po/pl_PL.po
+--- setup-0.3.1-zulu-edition-old/po/pl_PL.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/pl_PL.po	2008-06-18 09:55:33.000000000 +0200
+@@ -7,7 +7,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Michael Rakowski <mrak@gmx.de>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -45,12 +45,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Edytuj"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Edytuj"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/pt_PT.po setup-0.3.1-zulu-edition/po/pt_PT.po
+--- setup-0.3.1-zulu-edition-old/po/pt_PT.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/pt_PT.po	2008-06-18 09:55:33.000000000 +0200
+@@ -7,7 +7,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Paulo Lopes <pmml@netvita.pt>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -45,12 +45,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Modificar"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Modificar"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/ro_RO.po setup-0.3.1-zulu-edition/po/ro_RO.po
+--- setup-0.3.1-zulu-edition-old/po/ro_RO.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/ro_RO.po	2008-06-18 09:55:33.000000000 +0200
+@@ -8,7 +8,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Lucian Muresan <lucianm@users.sourceforge.net>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -46,12 +46,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Modific"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Modific"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/ru_RU.po setup-0.3.1-zulu-edition/po/ru_RU.po
+--- setup-0.3.1-zulu-edition-old/po/ru_RU.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/ru_RU.po	2008-06-18 09:55:33.000000000 +0200
+@@ -7,7 +7,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Vyacheslav Dikonov <sdiconov@mail.ru>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -45,12 +45,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr ""
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr ""
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/sl_SI.po setup-0.3.1-zulu-edition/po/sl_SI.po
+--- setup-0.3.1-zulu-edition-old/po/sl_SI.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/sl_SI.po	2008-06-18 09:55:33.000000000 +0200
+@@ -8,7 +8,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Matjaz Thaler <matjaz.thaler@guest.arnes.si>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -46,12 +46,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "Uredi"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "Uredi"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/sv_SE.po setup-0.3.1-zulu-edition/po/sv_SE.po
+--- setup-0.3.1-zulu-edition-old/po/sv_SE.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/sv_SE.po	2008-06-18 09:55:33.000000000 +0200
+@@ -8,7 +8,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Tomas Prybil <tomas@prybil.se>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -46,12 +46,44 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Plugin"
++msgstr "ndra"
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++#, fuzzy
++msgid "Edit Menu"
++msgstr "ndra"
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/po/tr_TR.po setup-0.3.1-zulu-edition/po/tr_TR.po
+--- setup-0.3.1-zulu-edition-old/po/tr_TR.po	2008-01-30 12:03:26.000000000 +0100
++++ setup-0.3.1-zulu-edition/po/tr_TR.po	2008-06-18 09:55:33.000000000 +0200
+@@ -7,7 +7,7 @@
+ msgstr ""
+ "Project-Id-Version: VDR 1.5.7\n"
+ "Report-Msgid-Bugs-To: <see README>\n"
+-"POT-Creation-Date: 2008-01-27 20:01+0100\n"
++"POT-Creation-Date: 2008-06-17 19:53+0200\n"
+ "PO-Revision-Date: 2008-01-27 18:38+0100\n"
+ "Last-Translator: Oktay Yolgeen <oktay_73@yahoo.de>\n"
+ "Language-Team: <vdr@linuxtv.org>\n"
+@@ -45,12 +45,42 @@
+ msgid "Move"
+ msgstr ""
+ 
++msgid "Title"
++msgstr ""
++
++msgid "Edit Plugin"
++msgstr ""
++
++msgid "Command"
++msgstr ""
++
++msgid "Has to confirm"
++msgstr ""
++
++msgid "Execute as thread"
++msgstr ""
++
++msgid "Edit Command"
++msgstr ""
++
++msgid "Edit Menu"
++msgstr ""
++
++msgid "Create Menu"
++msgstr ""
++
++msgid "Create Command"
++msgstr ""
++
+ msgid "Delete Menu?"
+ msgstr ""
+ 
+ msgid "Up/Dn for new location - color key to move"
+ msgstr ""
+ 
++msgid "Menu"
++msgstr ""
++
+ msgid "Into"
+ msgstr ""
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/README setup-0.3.1-zulu-edition/README
+--- setup-0.3.1-zulu-edition-old/README	2008-01-22 18:18:56.000000000 +0100
++++ setup-0.3.1-zulu-edition/README	2008-06-19 10:07:10.000000000 +0200
+@@ -4,7 +4,10 @@
+ 
+ Project's homepage:          www.vdrtools.de
+ 
+-Latest version available at: www.vdrtools.de
++Latest original version available at: www.vdrtools.de
++
++Latest hacked version available at:
++www.zulu-entertainment.de/files/vdr-setup/vdr-setup-0.3.1-zulu-edition.tgz
+ 
+ See the file COPYING for license information.
+ 
+@@ -34,8 +37,11 @@
+ ============
+ It is required to apply the patch to VDR included with the plugin.
+ 
++For vdr-setup-0.3.1-zulu-edition the VDR-Extensions-Patch => 63 or
++VDR-Extensions-Patch 62 + vdr-ext62_setup-custom-plugin-title.diff is required
++
+ 
+-Also please make shure, that the file specified with the parameter "sysconfigFile"
++Also please make sure, that the file specified with the parameter "sysconfigFile"
+  (see vdr-setup.xml) exists.
+ The Plugin will save the configured parameters in this file in the form of:
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/setupmenu.c setup-0.3.1-zulu-edition/setupmenu.c
+--- setup-0.3.1-zulu-edition-old/setupmenu.c	2008-01-27 17:56:16.000000000 +0100
++++ setup-0.3.1-zulu-edition/setupmenu.c	2008-06-19 09:36:48.000000000 +0200
+@@ -1,12 +1,12 @@
+ /****************************************************************************
+- * DESCRIPTION: 
++ * DESCRIPTION:
+  *             Creates VDR Menus
+  *
+  * $Id: setupmenu.cpp,v 1.21 2006/03/05 09:47:26 ralf Exp $
+  *
+- * Contact:    ranga@vdrtools.de        
++ * Contact:    ranga@vdrtools.de
+  *
+- * Copyright (C) 2004 by Ralf Dotzert 
++ * Copyright (C) 2005 by Ralf Dotzert
+  ****************************************************************************/
+ 
+ #include <stdlib.h>
+@@ -29,15 +29,14 @@
+ //#################################################################################################
+ cSetupPluginMenu::cSetupPluginMenu(Config  *config) : cOsdMenu(tr("Plugins activate / deactivate"), 42)
+ {
+-  _moveMode=false;
+-  _sortMode=false;
++  _moveMode = false;
++  _sortMode = false;
+ 
+-  if( config != NULL && config->GetPlugins() != NULL )
+-  {
+-    _config  = config;
+-    _plugins = config->GetPlugins();
+-    Set();
+-  }
++  if (config != NULL && config->GetPlugins() != NULL) {
++     _config  = config;
++     _plugins = config->GetPlugins();
++     Set();
++    }
+ }
+ 
+ cSetupPluginMenu::~cSetupPluginMenu()
+@@ -51,29 +50,28 @@
+ {
+ 
+   int current = Current();
+-  
++
+   Clear();
+-  for(int i=0; i<_plugins->GetNr(); i++)
+-  {
+-    if(_plugins->Get(i)->GetProtect())
+-    {
+-        char *title = NULL;
+-
+-        asprintf(&title, "%s:\t%s", _plugins->Get(i)->GetInfo(),tr("protected")); 
+-        Add(new cOsdItem (title));
+-        free(title);
+-    }
+-    else
+-       Add(new cMenuEditBoolItem(_plugins->Get(i)->GetInfo(), _plugins->Get(i)->GetActiveRef(), trVDR("no"), trVDR("yes")));
+-  }
+-  if( current == -1 && _plugins->GetNr() >0)
+-    current=0;
+ 
++  for (int i=0; i<_plugins->GetNr(); i++) {
++      if (_plugins->Get(i)->GetProtect()) {
++         char *title = NULL;
++         asprintf(&title, "%s:\t%s", _plugins->Get(i)->GetInfo(),tr("protected")); 
++         Add(new cOsdItem (title));
++         free(title);
++         }
++      else
++         Add(new cMenuEditBoolItem(_plugins->Get(i)->GetInfo(), _plugins->Get(i)->GetActiveRef(), trVDR("no"), trVDR("yes")));
++      }
++
++  if (current == -1 && _plugins->GetNr() > 0)
++     current = 0;
+   SetCurrent(Get(current));
+-  if( _moveMode)
+-    SetHelp(tr("PageUp"),  tr("PageDown"), tr("Before"), tr("After"));
++
++  if (_moveMode)
++     SetHelp(tr("PageUp"),  tr("PageDown"), tr("Before"), tr("After"));
+   else
+-    SetHelp(tr("PageUp"),  tr("PageDown"), trVDR("Parameters"), tr("Move"));
++     SetHelp(tr("PageUp"),  tr("PageDown"), trVDR("Parameters"), tr("Move"));
+ 
+   setHelp();
+   Display();
+@@ -83,78 +81,71 @@
+ {
+   bool HadSubMenu = HasSubMenu();
+   eOSState state = cOsdMenu::ProcessKey(Key);
+-  if(HasSubMenu() || HadSubMenu)
+-    return state;
++  if (HasSubMenu() || HadSubMenu)
++     return state;
+ 
+-  switch(Key)
+-    {
+-            case kOk :
+-                        _config->SaveFile();
+-                        return osBack;
+-                        break;
+-
+-            case kRed:   PageUp();
+-                         Set();
+-                         break;
+-
+-            case kGreen: PageDown();
+-                         Set();
+-                         break;
+-            case kYellow:
+-
+-                      if(_moveMode)
+-                      {
+-                        _plugins->MovePlugin(_startIndex, Current(), Plugins::BEFORE);
+-                        _moveMode = !_moveMode;
+-                        Set();
++  switch (Key) {
++    case kOk :
++                   _config->SaveFile();
++                   return osBack;
++                   break;
++
++    case kRed:
++                   PageUp();
++                   Set();
++                   break;
++
++    case kGreen:
++                   PageDown();
++                   Set();
++                   break;
++    case kYellow:
++                   if (_moveMode) {
++                      _plugins->MovePlugin(_startIndex, Current(), Plugins::BEFORE);
++                      _moveMode = !_moveMode;
++                      Set();
+                       }
+-                      else // Edit Parameter
+-                      {
+-                        char *tmp=NULL;
+-                        asprintf(&tmp, "%s-%s", trVDR("Plugin"), trVDR("Parameters"));
+-                        return(AddSubMenu(new cSetupPluginParameter(tmp, _plugins->Get(Current()))));
+-                        free(tmp);
++                   else { // Edit Parameter
++                      char *tmp=NULL;
++                      asprintf(&tmp, "%s-%s", trVDR("Plugin"), trVDR("Parameters"));
++                      return(AddSubMenu(new cSetupPluginParameter(tmp, _plugins->Get(Current()))));
++                      free(tmp);
+                       }
+-                      break;
+-            case kBlue:
+-                      if(_moveMode)
+-                      {
+-                        _plugins->MovePlugin(_startIndex, Current(), Plugins::BEHIND);
++                   break;
++    case kBlue:
++                   if (_moveMode) {
++                      _plugins->MovePlugin(_startIndex, Current(), Plugins::BEHIND);
+                       }
+-                      else
+-                      {
+-                        _startIndex = Current();
++                   else {
++                      _startIndex = Current();
+                       }
+-                      _moveMode = !_moveMode;
+-                      Set();
+-                      break;
+-            case kDown:
+-            case kUp:
+-                    setHelp();
+-                    break;
+-            default : break;
++                   _moveMode = !_moveMode;
++                   Set();
++                   break;
++    case kDown:
++    case kUp:
++                   setHelp();
++                   break;
++    default:       break;
+     }
+-    return state;
++  return state;
+ }
+ 
+ void cSetupPluginMenu::setHelp()
+ {
+-  char *tmp=NULL;
++  char *tmp = NULL;
+   int  current = Current();
+-  if(current >= 0 )
+-  {
+-    asprintf(&tmp, "%s: %s", trVDR("Plugin"), _plugins->Get(current)->GetName());
+-    SetStatus(tmp);
+-    free(tmp);
+-  }
+-
++  if (current >= 0 ) {
++     asprintf(&tmp, "%s: %s", trVDR("Plugin"), _plugins->Get(current)->GetName());
++     SetStatus(tmp);
++     free(tmp);
++     }
+ }
+ 
+ 
+ //#################################################################################################
+ //  Edit Plugin Parameter
+ //################################################################################################
+-static char *ALLOW_ALL_PARAM_CHARS =" abcdefghijklmnopqrstuvwxyz0123456789+-={}[]().,;#*?!@/~\"\'";
+ 
+ cSetupPluginParameter::cSetupPluginParameter( const char *title, Plugin * plugin ) : cOsdMenu(title, 25)
+ {
+@@ -169,18 +160,17 @@
+ 
+ void cSetupPluginParameter::Set( )
+ {
+-  char *tmp=NULL;
++  char *tmp = NULL;
+   const char *param = _plugin->GetParameter();
+   Clear();
+-  if( param == NULL)
+-    _editParameter[0]='\0';
+-  else
+-  {
+-    strncpy(_editParameter, param, sizeof(_editParameter));
+-    _editParameter[sizeof(_editParameter)]='\0';
+-  }
++  if (param == NULL)
++     _editParameter[0] = '\0';
++  else {
++     strncpy(_editParameter, param, sizeof(_editParameter));
++     _editParameter[sizeof(_editParameter)] = '\0';
++     }
+   asprintf(&tmp, "%s-%s", trVDR("Plugin"), trVDR("Parameters"));
+-  Add(new cMenuEditStrItem(tmp, _editParameter, sizeof(_editParameter), ALLOW_ALL_PARAM_CHARS));
++  Add(new cMenuEditStrItem(tmp, _editParameter, sizeof(_editParameter), trVDR(FileNameChars)));
+ 
+   asprintf(&tmp, "%s: %s", trVDR("Plugin"), _plugin->GetName());
+   SetStatus(tmp);
+@@ -193,21 +183,21 @@
+ 
+   eOSState state = cOsdMenu::ProcessKey(Key);
+ 
+-  switch(Key)
+-  {
+-     case kOk :
+-                if(!_edit)
+-                  return osBack;
+-                else
+-                {
+-                  _plugin->SetParameter(_editParameter);
+-                  _edit=false;
+-                }
+-                break;
+-    case kRight:_edit = true;
+-                break;
+-     default : break;
+-  }
++  switch (Key) {
++    case kOk:
++              if (!_edit)
++                 return osBack;
++              else {
++                 _plugin->SetParameter(_editParameter);
++                 _edit=false;
++                 }
++              break;
++    case kRight:
++              _edit = true;
++              break;
++    default:
++              break;
++    }
+   return state;
+ }
+ 
+@@ -215,13 +205,12 @@
+ //#################################################################################################
+ //  cSetupVdrMenu
+ //################################################################################################
+-//static char *ALLOW_ALL_CHARS =" abcdefghijklmnopqrstuvwxyz0123456789-.";
+ 
+ cSetupVdrMenu::cSetupVdrMenu(const char *title): cOsdMenu(title, 25)
+ {
+-  _startIndex           =0;
+-  _createEditNodeIndex  =0;
+-  
++  _startIndex           = 0;
++  _createEditNodeIndex  = 0;
++
+   // Load Menu Configuration
+   char *menuXML = NULL;
+ #if VDRVERSNUM < 10507
+@@ -249,47 +238,103 @@
+   cSubMenuNode *node = NULL;
+   int nr = _vdrSubMenu.GetNrOfNodes();
+ 
+-
+   Clear();
+ 
+-  switch(_menuState)
+-  {
++  switch (_menuState) {
+     case UNDEFINED:
+-    case MOVE     :
+-                for( int i=0; i<nr; i++)
+-                {
+-                    if((node = _vdrSubMenu.GetAbsNode(i)) != NULL)
+-                    {
+-                        char *tmp=createMenuName(node);
+-                        Add(new cOsdItem(tmp));
+-                        free(tmp);
++                SetTitle(tr("Menu Edit"));
++    case MOVE:
++                for (int i=0; i<nr; i++) {
++                    if ((node = _vdrSubMenu.GetAbsNode(i)) != NULL) {
++                       char *tmp = createMenuName(node);
++                       Add(new cOsdItem(tmp));
++                       free(tmp);
++                       }
+                     }
+-                }
+-                current=_createEditNodeIndex;
+-                if( current >= nr)
+-                    current = nr-1;
++                current = _createEditNodeIndex;
++                if (current >= nr)
++                   current = nr-1;
+                 break;
+-     case EDIT:
+-                strncpy(_editTitle, _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetName(), sizeof(_editTitle));
+-                _editTitle[sizeof(_editTitle)]='\0';
+-//                Add(new cMenuEditStrItem(trVDR("Name"), _editTitle, sizeof(_editTitle), ALLOW_ALL_CHARS));
++    case EDIT:
++                if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::PLUGIN) {
++/*
++                   char *name = NULL;
++                   asprintf(&name, "%s:\t%s", trVDR("Name"), _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetName());
++                   Add(new cOsdItem(name));
++                   free(name);
++*/
++                   if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetCustomTitle() != NULL)
++                      strncpy(_editTitle, _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetCustomTitle(), sizeof(_editTitle));
++                   else
++                      strncpy(_editTitle, "", sizeof(_editTitle));
++                   _editTitle[sizeof(_editTitle)] = '\0';
++                   Add(new cMenuEditStrItem(tr("Title"), _editTitle, sizeof(_editTitle), trVDR(FileNameChars)));
++
++                   char *menutitle = NULL;
++                   asprintf(&menutitle, "%s '%s'", tr("Edit Plugin"), _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetName());
++                   SetTitle(menutitle);
++                   free(menutitle);
++                   }
++                else if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::COMMAND ||
++                         _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::THREAD) {
++                   strncpy(_editTitle, _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetName(), sizeof(_editTitle));
++                   _editTitle[sizeof(_editTitle)] = '\0';
++                   Add(new cMenuEditStrItem(trVDR("Name"), _editTitle, sizeof(_editTitle), trVDR(FileNameChars)));
++
++                   strncpy(_editCommand, _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetCommand(), sizeof(_editCommand));
++                   _editTitle[sizeof(_editCommand)] = '\0';
++                   Add(new cMenuEditStrItem(tr("Command"), _editCommand, sizeof(_editCommand), trVDR(FileNameChars)));
++
++                   if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->CommandConfirm())
++                      _hasToConfirm = 1;
++                   else
++                      _hasToConfirm = 0;
++                   Add(new cMenuEditBoolItem(tr("Has to confirm"), &_hasToConfirm));
++
++                   if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::THREAD)
++                      _isThread = 1;
++                   else
++                      _isThread = 0;
++                   Add(new cMenuEditBoolItem(tr("Execute as thread"), &_isThread));
++
++                   SetTitle(tr("Edit Command"));
++                   }
++                else { // MENU
++                   strncpy(_editTitle, _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetName(), sizeof(_editTitle));
++                   _editTitle[sizeof(_editTitle)] = '\0';
++                   Add(new cMenuEditStrItem(trVDR("Name"), _editTitle, sizeof(_editTitle), trVDR(FileNameChars)));
++
++                   SetTitle(tr("Edit Menu"));
++                   }
++
++                setHelp();
++                break;
++    case CREATE:
++                strncpy(_editTitle, "", sizeof(_editTitle));
+                 Add(new cMenuEditStrItem(trVDR("Name"), _editTitle, sizeof(_editTitle), trVDR(FileNameChars)));
++                SetTitle(tr("Create Menu"));
++                setHelp();
+                 break;
+-     case CREATE:
++    case CREATECMD:
+                 strncpy(_editTitle, "", sizeof(_editTitle));
+-//                Add(new cMenuEditStrItem(trVDR("Name"), _editTitle, sizeof(_editTitle), ALLOW_ALL_CHARS));
+                 Add(new cMenuEditStrItem(trVDR("Name"), _editTitle, sizeof(_editTitle), trVDR(FileNameChars)));
++                strncpy(_editCommand, "", sizeof(_editCommand));
++                Add(new cMenuEditStrItem(tr("Command"), _editCommand, sizeof(_editCommand), trVDR(FileNameChars)));
++
++                _hasToConfirm = 1;
++                Add(new cMenuEditBoolItem(tr("Has to confirm"), &_hasToConfirm));
++
++                _isThread = 0;
++                Add(new cMenuEditBoolItem(tr("Execute as thread"), &_isThread));
++                SetTitle(tr("Create Command"));
++                setHelp();
+                 break;
+-     default:
++    default:
+                 break;
+-  }
+-
++    }
+ 
+   SetCurrent(Get(current));
+-
+   setHelp();
+-  
+-
+   Display();
+ }
+ 
+@@ -300,177 +345,226 @@
+ {
+     cSubMenuNode *node = NULL;
+     eOSState state = cOsdMenu::ProcessKey(Key);
+-    if( HasSubMenu())
+-      return state;
+-
+-    switch(Key)
+-    {
+-            case kRed:
+-                      if(_menuState == UNDEFINED )
+-                      {
++    if (HasSubMenu())
++       return state;
++//    isyslog("setup: %d", state); // osUnknown=0, osContinue=1, osBack=16
++    if (state == osUnknown || state == osBack) {
++       switch (Key) {
++         case k0:
++                       if (_menuState == UNDEFINED) {
++                          _menuState = CREATECMD;
++                          _createEditNodeIndex = Current();
++                          Set();
++                          }
++                       break;
++         case kRed:
++                      if (_menuState == CREATE) {
++                          _menuState = CREATECMD;
++                          Set();
++                          }
++                       else if (_menuState == CREATECMD) {
++                          _menuState = CREATE;
++                          Set();
++                          }
++                       else if (_menuState == UNDEFINED) {
+                           _menuState = CREATE;
+                           _createEditNodeIndex = Current();
+                           Set();
+-                      }
+-                      break;
+-            case kGreen:
+-                      if(_menuState == MOVE )
+-                      {
+-                        if( (node= _vdrSubMenu.GetAbsNode(Current()))!= NULL && node->GetType()== cSubMenuNode::MENU)
+-                        {
+-                          _vdrSubMenu.MoveMenu(_startIndex, Current(), cSubMenu::INTO);
++                          }
++                       break;
++         case kGreen:
++                       if (_menuState == MOVE) {
++                          if ((node = _vdrSubMenu.GetAbsNode(Current())) != NULL && node->GetType() == cSubMenuNode::MENU) {
++                             _vdrSubMenu.MoveMenu(_startIndex, Current(), cSubMenu::INTO);
++                             _menuState = UNDEFINED;
++                             _createEditNodeIndex = Current();
++                             SetStatus(NULL);
++                             Set();
++                             }
++                          }
++                       else if (_menuState == UNDEFINED) {
++                          if ((node = _vdrSubMenu.GetAbsNode(Current())) != NULL && (node->GetType() == cSubMenuNode::MENU ||
++                                                                                     node->GetType() == cSubMenuNode::PLUGIN ||
++                                                                                     node->GetType() == cSubMenuNode::COMMAND ||
++                                                                                     node->GetType() == cSubMenuNode::THREAD)) {
++                             _menuState = EDIT;
++                             _createEditNodeIndex = Current();
++                             Set();
++                             }
++                          }
++                       setHelp();
++                       break;
++         case kYellow:
++                       if (_menuState == MOVE) {
++                          _vdrSubMenu.MoveMenu(_startIndex, Current(), cSubMenu::BEFORE);
+                           _menuState = UNDEFINED;
+                           _createEditNodeIndex = Current();
+                           SetStatus(NULL);
+                           Set();
+-                        }
+-                      }
+-                      else
+-                      if(_menuState == UNDEFINED )
+-                      {
+-                        if( (node= _vdrSubMenu.GetAbsNode(Current()))!= NULL && node->GetType()== cSubMenuNode::MENU)
+-                        {
+-                            _menuState = EDIT;
+-                            _createEditNodeIndex = Current();
+-                            Set();
+-                        }
+-                      }
+-                      setHelp();
+-                      break;
+-           case kYellow:
+-                      if(_menuState == MOVE )
+-                      {
+-                        _vdrSubMenu.MoveMenu(_startIndex, Current(), cSubMenu::BEFORE);
+-                        _menuState = UNDEFINED;
+-                        _createEditNodeIndex =Current();
+-                        SetStatus(NULL);
+-                        Set();
+-                      }
+-                      else
+-                      if(_menuState == UNDEFINED )
+-                      {
+-                        if(Interface->Confirm(tr("Delete Menu?")))
+-                        {
+-                         _createEditNodeIndex = Current();
+-                         _vdrSubMenu.DeleteMenu(_createEditNodeIndex);
++                          }
++                       else if (_menuState == UNDEFINED) {
++                          if (Interface->Confirm(tr("Delete Menu?"))) {
++                             _createEditNodeIndex = Current();
++                             _vdrSubMenu.DeleteMenu(_createEditNodeIndex);
++                             _menuState = UNDEFINED;
++                             Set();
++                             }
++                          }
++                       break;
++         case kBlue:
++                       if (_menuState == MOVE) {
++                          _vdrSubMenu.MoveMenu(_startIndex, Current(), cSubMenu::BEHIND);
++                          _createEditNodeIndex = Current();
+                           _menuState = UNDEFINED;
+-                          Set();
+-                        }
+-                      }
+-                      break;
+-           case kBlue:
+-                      if(_menuState == MOVE )
+-                      {
+-                        _vdrSubMenu.MoveMenu(_startIndex, Current(), cSubMenu::BEHIND);
+-                         _createEditNodeIndex =Current();
+-                        _menuState = UNDEFINED;
+-                        SetStatus(NULL);
+-                      }
+-                      else
+-                      if(_menuState == UNDEFINED )
+-                      {
+-                        _startIndex = Current();
+-                         _createEditNodeIndex = _startIndex;
+-                        _menuState = MOVE;
+-                        SetStatus(tr("Up/Dn for new location - color key to move"));
+-                      }
+-                      Set();
+-                      setHelp();
+-                      break;
++                          SetStatus(NULL);
++                          }
++                       else if (_menuState == UNDEFINED) {
++                          _startIndex = Current();
++                          _createEditNodeIndex = _startIndex;
++                          _menuState = MOVE;
++                          SetStatus(tr("Up/Dn for new location - color key to move"));
++                          }
++                       Set();
++                       break;
+ 
+-          case kOk :
+-                       switch (_menuState)
+-                       {
+-                        case UNDEFINED:
++         case kOk:
++                       switch (_menuState) {
++                         case UNDEFINED:
+                                     // Save Menus to file and exit submenu
+-                                     state=osBack;
++                                     state = osBack;
+                                     _vdrSubMenu.SetMenuSuffix(setupSetup._menuSuffix);
+                                     _vdrSubMenu.SaveXml();
+                                     break;
+-                        case CREATE:
++                         case CREATE:
+                                     _vdrSubMenu.CreateMenu(_createEditNodeIndex, _editTitle);
+                                     _menuState = UNDEFINED;
+                                     Set();
+                                     break;
+-                        case EDIT:
+-                                    _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetName(_editTitle);
++                         case CREATECMD:
++                                    if (_isThread == 1)
++                                       _vdrSubMenu.CreateThread(_createEditNodeIndex, _editTitle, _editCommand, _hasToConfirm);
++                                    else
++                                       _vdrSubMenu.CreateCommand(_createEditNodeIndex, _editTitle, _editCommand, _hasToConfirm);
++                                    _menuState = UNDEFINED;
++                                    Set();
++                                    break;
++                         case EDIT:
++                                    if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::PLUGIN)
++                                       _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetCustomTitle(_editTitle);
++                                    else if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::COMMAND ||
++                                             _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::THREAD) {
++                                       _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetName(_editTitle);
++                                       if (_isThread == 1)
++                                          _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetType(cSubMenuNode::THREAD);
++                                       else
++                                          _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetType(cSubMenuNode::COMMAND);
++                                       _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetCommand(_editCommand);
++                                       _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetCommandConfirm(_hasToConfirm);
++                                       }
++                                    else
++                                       _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetName(_editTitle);
+                                     _menuState = UNDEFINED;
+                                     Set();
+                                     break;
+ 
+-                        default:
++                         default:
+                                     break;
+-                       }
++                         }
+                        break;
+-            case kBack:
+-                       if( _menuState == CREATE || _menuState==EDIT)
+-                       {
+-                         _menuState=UNDEFINED;
+-                         Set();
+-                         state=osContinue;
+-                       }
++         case kBack:
++                       state = osBack;
++                       if (_menuState == CREATE || _menuState == CREATECMD || _menuState == EDIT) {
++                          _menuState = UNDEFINED;
++                          Set();
++                          state = osContinue;
++                          }
++                       break;
++         case kDown:
++         case kUp:
++         case kRight:
++         case kLeft:
++                       if (_menuState == MOVE)
++                          setHelp();
++                       break;
++         default:
++                       break;
++         }
++      }
++   else if (state == osContinue) {
++       switch (Key) {
++         case kBack:
++                      setHelp();
++                      break;
++         case kDown:
++         case kUp:
++         case kRight:
++         case kLeft:
++                       if (_menuState == MOVE)
++                          setHelp();
++                       break;
++         default:
++                       break;
++         }
++      }
+ 
+-            case kDown:
+-            case kUp:
+-            case kRight:
+-            case kLeft:
+-                     if(_menuState == MOVE)
+-                        setHelp();
+-                     break;
+-            default :
+-                     break;
+-    }
+-    return state;
++   return state;
+ }
++
+ // --------------- Private Methods ---------------------
+ void cSetupVdrMenu::setHelp( )
+ {
+   cSubMenuNode *node = NULL;
+-  
+-  if( _menuState == MOVE)
+-  {
+-    if( (node= _vdrSubMenu.GetAbsNode(Current()))!= NULL && node->GetType()== cSubMenuNode::MENU)
+-      SetHelp(NULL, tr("Into"), tr("Before"), tr("After"));
+-    else
+-      SetHelp(NULL, NULL, tr("Before"), tr("After"));
+-  }
++
++   if (_menuState == CREATE)
++     SetHelp(tr("Command"), NULL, NULL, NULL);
++  else if (_menuState == CREATECMD)
++     SetHelp(tr("Menu"), NULL, NULL, NULL);
++  else if (_menuState == EDIT)
++     SetHelp(NULL, NULL, NULL, NULL);
++  else if (_menuState == MOVE) {
++     if ((node= _vdrSubMenu.GetAbsNode(Current())) != NULL && node->GetType() == cSubMenuNode::MENU)
++        SetHelp(NULL, tr("Into"), tr("Before"), tr("After"));
++     else
++        SetHelp(NULL, NULL, tr("Before"), tr("After"));
++     }
+   else
+-    SetHelp(tr("Create"), tr("Edit"), tr("Delete"), tr("Move"));
++     SetHelp(tr("Create"), tr("Edit"), tr("Delete"), tr("Move"));
+ }
+ 
+ char * cSetupVdrMenu::createMenuName( cSubMenuNode *node )
+ {
+   char *prefix = NULL;
+-  char *tmp=NULL;
++  char *tmp = NULL;
+   int   level = node->GetLevel();
+ 
+   // Set Prefix
+   prefix = (char*) malloc(1);
+   prefix[0] = '\0';
+-  for(int i=0; i<level; i++)
+-    asprintf(&prefix, "|   %s", prefix);
++  for (int i=0; i<level; i++)
++      asprintf(&prefix, "|   %s", prefix);
+ 
+-  
+-  cSubMenuNode::Type type =node->GetType();
+-  
+-  if( type == cSubMenuNode::MENU)
+-    asprintf(&tmp, "%s+%s", prefix, node->GetName());
++  cSubMenuNode::Type type = node->GetType();
++
++  if (type == cSubMenuNode::MENU)
++     asprintf(&tmp, "%s+%s", prefix, node->GetName());
++  else if (type == cSubMenuNode::SYSTEM)
++     asprintf(&tmp, "%s %s", prefix, trVDR(node->GetName()));
++  else if (type == cSubMenuNode::PLUGIN)
++     if (node->GetCustomTitle() != NULL && strcmp(node->GetCustomTitle(), "") != 0)
++        asprintf(&tmp, "%s %s  (%s)", prefix, node->GetCustomTitle(), node->GetName());
++     else
++        asprintf(&tmp, "%s %s  (%s)", prefix, node->GetPluginMainMenuEntry(), node->GetName());
+   else
+-   if( type == cSubMenuNode::SYSTEM)
+-    asprintf(&tmp, "%s %s",  prefix, trVDR(node->GetName()));
+-   else
+-    asprintf(&tmp, "%s %s",  prefix, node->GetName());
++     asprintf(&tmp, "%s %s",  prefix, node->GetName());
+ 
+   free(prefix);
+-  
++
+   return(tmp);
+ }
+ 
+ //#################################################################################################//  cSetupGenericMenu
+ //################################################################################################
+ cSetupGenericMenu::cSetupGenericMenu(const char *title, MenuNode *node, Config  *config)  : cSetupMenu()
+-
+-
+ {
+   _node     = node;
+   _editItem = false;
+@@ -480,9 +574,8 @@
+   SetTitle(title);
+   SetCols(25);
+ 
+-  
+-  if( _node != NULL)
+-    Set();
++  if (_node != NULL)
++     Set();
+ }
+ 
+ 
+@@ -495,14 +588,13 @@
+   static std::string tmp;
+   tmp = setupSetup._entryPrefix;
+ 
+-  if( strlen(setupSetup._entryPrefix)==0 || setupSetup._entryPrefix[0] == ' ')
+-    tmp = "      ";
+-  else
+-  {
+-    tmp =  "  ";
+-    tmp += setupSetup._entryPrefix;
+-    tmp += "  ";
+-  }
++  if (strlen(setupSetup._entryPrefix) == 0 || setupSetup._entryPrefix[0] == ' ')
++     tmp = "      ";
++  else {
++     tmp =  "  ";
++     tmp += setupSetup._entryPrefix;
++     tmp += "  ";
++     }
+ 
+   tmp += str;
+   return(tmp.c_str());
+@@ -516,182 +608,161 @@
+   int current = Current();
+   Clear();
+   SetHasHotkeys();
+-  for(int i=0; i< _node->GetNr(); i++)
+-  {
+-    MenuNode::Type type = _node->GetNode(i)->GetType();
+-    
+-    if( type == MenuNode::ENTRY )
+-    {
+-
+-      MenuEntry *e = _node->GetNode(i)->GetMenuEntry();
+-      switch( e->GetType() )
+-      {
+-        case Util::BOOL:
+-          Add(new cMenuEditBoolItem(nohk(e->GetName()), e->GetValueBoolRef(), trVDR("no"), trVDR("yes")));
++  for (int i=0; i< _node->GetNr(); i++) {
++      MenuNode::Type type = _node->GetNode(i)->GetType();
++
++     if (type == MenuNode::ENTRY) {
++        MenuEntry *e = _node->GetNode(i)->GetMenuEntry();
++
++        switch (e->GetType()) {
++          case Util::BOOL:
++             Add(new cMenuEditBoolItem(nohk(e->GetName()), e->GetValueBoolRef(), trVDR("no"), trVDR("yes")));
+              break;
+-        case Util::NUMBER:
+-          Add(new cMenuEditIntItem(nohk(e->GetName()), e->GetValueNumberRef(), 0, 999999999));
++          case Util::NUMBER:
++             Add(new cMenuEditIntItem(nohk(e->GetName()), e->GetValueNumberRef(), 0, 999999999));
+              break;
+-        case Util::TEXT:
+-          Add(new cMenuEditStrItem(nohk((char*)e->GetName()), (char*)e->GetValue(), e->GetValueTextMaxLen(), " abcdefghijklmnopqrstuvwxyz0123456789-.#~_"));
++          case Util::TEXT:
++             Add(new cMenuEditStrItem(nohk((char*)e->GetName()), (char*)e->GetValue(), e->GetValueTextMaxLen(), " abcdefghijklmnopqrstuvwxyz0123456789-.#~_"));
+              break;
+-         case Util::NUMBER_TEXT:
+-           Add(new cMenuEditStrItem(nohk((char*)e->GetName()), (char*)e->GetValue(), e->GetValueTextMaxLen(), "0123456789"));
++          case Util::NUMBER_TEXT:
++             Add(new cMenuEditStrItem(nohk((char*)e->GetName()), (char*)e->GetValue(), e->GetValueTextMaxLen(), "0123456789"));
+              break;
+-        case Util::IP:
+-
+-          Add(new cMenuEditStrItem(nohk((char*)e->GetName()), (char*)e->GetValueIp(), e->GetValueIpMaxLen(), ".0123456789"));
+-          break;
+-        case Util::HEX:
+-          Add(new cMenuEditStrItem(nohk((char*)e->GetName()), (char*)e->GetValue(), e->GetValueTextMaxLen(), "0123456789ABCDEF:"));
++          case Util::IP:
++             Add(new cMenuEditStrItem(nohk((char*)e->GetName()), (char*)e->GetValueIp(), e->GetValueIpMaxLen(), ".0123456789"));
+              break;
+-        case Util::SELECTION:
+-        {
+-              if(  e->GetNrOfSelectionValues() == 0 )
+-              {
+-                char *txt=NULL;
+-                asprintf(&txt, "%s:\t%s", nohk(e->GetName()), tr("missing channels/xxx.conf"));
+-                Add(new cOsdItem (txt));
+-                free(txt);
+-              }
+-              else
+-                Add(new cMenuEditStraItem(nohk(e->GetName()), e->GetReferenceSelection(),
+-                                       e->GetNrOfSelectionValues(),
+-                                       e->GetSelectionValues()) );
+-        }
++          case Util::HEX:
++             Add(new cMenuEditStrItem(nohk((char*)e->GetName()), (char*)e->GetValue(), e->GetValueTextMaxLen(), "0123456789ABCDEF:"));
+              break;
+-        default:
+-                break;
+-      }
+-    }
+-    else if( type == MenuNode::MENUSYSTEM )
+-    {
+-       char *tmp = NULL;
+-       asprintf(&tmp, "%s", _node->GetNode(i)->GetMenu()->GetSystem());
+-       if ((strcmp(tmp, "ActPlugins") == 0) || (strcmp(tmp, "VDRMenu") == 0))
+-          asprintf(&tmp, "%s%s", tr(_node->GetNode(i)->GetName()), setupSetup._menuSuffix);
+-       else
+-          asprintf(&tmp, "%s%s", trVDR(_node->GetNode(i)->GetName()), setupSetup._menuSuffix);
+-       Add(new cOsdItem(hk(tmp)));
+-       free(tmp);
+-    }
+-    else
+-    {
+-       char *tmp = NULL;
+-       asprintf(&tmp, "%s%s", _node->GetNode(i)->GetName(), setupSetup._menuSuffix);
+-       Add(new cOsdItem(hk(tmp)));
+-       free(tmp);
+-    }
+-  }
++          case Util::SELECTION:
++             {
++               if (e->GetNrOfSelectionValues() == 0) {
++                  char *txt = NULL;
++                  asprintf(&txt, "%s:\t%s", nohk(e->GetName()), tr("missing channels/xxx.conf"));
++                  Add(new cOsdItem (txt));
++                  free(txt);
++                  }
++               else
++                  Add(new cMenuEditStraItem(nohk(e->GetName()), e->GetReferenceSelection(),
++                                                                e->GetNrOfSelectionValues(),
++                                                                e->GetSelectionValues()) );
++             }
++             break;
++          default:
++             break;
++          }
++        }
++     else if (type == MenuNode::MENUSYSTEM) {
++        char *tmp = NULL;
++        asprintf(&tmp, "%s", _node->GetNode(i)->GetMenu()->GetSystem());
++        if ((strcmp(tmp, "ActPlugins") == 0) || (strcmp(tmp, "VDRMenu") == 0))
++           asprintf(&tmp, "%s%s", tr(_node->GetNode(i)->GetName()), setupSetup._menuSuffix);
++        else
++           asprintf(&tmp, "%s%s", trVDR(_node->GetNode(i)->GetName()), setupSetup._menuSuffix);
++        Add(new cOsdItem(hk(tmp)));
++        free(tmp);
++        }
++     else {
++        char *tmp = NULL;
++        asprintf(&tmp, "%s%s", _node->GetNode(i)->GetName(), setupSetup._menuSuffix);
++        Add(new cOsdItem(hk(tmp)));
++        free(tmp);
++        }
++     }
+   SetCurrent(Get(current));
+   Display();
+ }
+ 
+ eOSState cSetupGenericMenu::ProcessKey( eKeys Key )
+-{  
+-    bool HadSubMenu = HasSubMenu();
+-    eOSState state = cOsdMenu::ProcessKey(Key);
++{
++  bool HadSubMenu = HasSubMenu();
++  eOSState state = cOsdMenu::ProcessKey(Key);
+ 
+-    if(HasSubMenu() || HadSubMenu)
+-      return state;
++  if (HasSubMenu() || HadSubMenu)
++     return state;
+ 
+-    MenuNode *n = _node->GetNode(Current());
++  MenuNode *n = _node->GetNode(Current());
+ 
+-      
+-      switch(Key)
+-      {
+-        case kOk : 
+-                       if( n!= NULL &&
+-                           (n->GetType() == MenuNode::MENU ||
+-                            n->GetType() == MenuNode::MENUSYSTEM) )
+-                     {
+-                        if(n->GetType() == MenuNode::MENU)
++  switch (Key) {
++    case kOk :
++                    if (n != NULL && (n->GetType() == MenuNode::MENU || n->GetType() == MenuNode::MENUSYSTEM)) {
++                       if (n->GetType() == MenuNode::MENU)
+                           return(AddSubMenu(new cSetupGenericMenu(n->GetName(), n,  _config)));
+-                        else
+-                        {  // Menu "system"
++                       else {  // Menu "system"
+                           cOsdMenu *menu = cSetupSystemMenu::GetSystemMenu(n->GetMenu()->GetSystem(), _config);
+-                           if(menu != NULL)
++                          if (menu != NULL)
+                              return(AddSubMenu(menu));
+-                        }
+-                      }
+-                      else
+-                      {
+-                        if(!_editItem) //close submenu only if we do not have edited an textitem
+-                        {
+-                          state=osBack;
++                          }
++                       }
++                    else {
++                       if (!_editItem) { //close submenu only if we do not have edited an textitem
++                          state = osBack;
+                           _config->SaveFile(); // Write New Configurationfile
+ 
+-                          for(int i=0;  i < _node->GetNr(); i++)
+-                          {
+-                            n = _node->GetNode(i);
+-                            if( n->GetType() == MenuNode::ENTRY)
+-                              ExecuteCommand(n->GetMenuEntry()->GetCommand());
+-                          }
++                          for (int i=0;  i < _node->GetNr(); i++) {
++                              n = _node->GetNode(i);
++                              if ( n->GetType() == MenuNode::ENTRY)
++                                 ExecuteCommand(n->GetMenuEntry()->GetCommand());
++                              }
+                           ExecuteCommand(_node->GetMenu()->GetCommand());
+-                        }
+-  
+-                        _editItem=false;
+-                      }
+-                      break;
+-              case kRed:
+-                        {
+-                          char *help = NULL;
+-                          if(n->GetType() == MenuNode::ENTRY)
+-                            help = GetLongHelp(n->GetMenuEntry()->GetHelp2());
+-                          else
+-                            help = GetLongHelp(n->GetMenu()->GetHelp2());
++                          }
+ 
+-                          if( help != NULL )
+-                          {
+-                            eOSState newState = AddSubMenu(new cMenuText(tr("Help"), help, fontFix));
+-                            free(help);
+-                            return(newState);
++                       _editItem = false;
++                       }
++                    break;
++     case kRed:
++                    {
++                       char *help = NULL;
++                       if (n->GetType() == MenuNode::ENTRY)
++                          help = GetLongHelp(n->GetMenuEntry()->GetHelp2());
++                       else
++                          help = GetLongHelp(n->GetMenu()->GetHelp2());
++
++                       if (help != NULL) {
++                          eOSState newState = AddSubMenu(new cMenuText(tr("Help"), help, fontFix));
++                          free(help);
++                          return(newState);
+                           }
++                       }
++                    break;
++     case kGreen:
++                    break;
++     case kYellow:
++                    break;
++     case kBlue:
++                    break;
++     case kRight:
++                    if (n!= NULL &&
++                        n->GetType() == MenuNode::ENTRY &&
++                       (n->GetMenuEntry()->GetType() == Util::TEXT ||
++                        n->GetMenuEntry()->GetType() == Util::NUMBER_TEXT ||
++                        n->GetMenuEntry()->GetType() == Util::HEX ||
++                        n->GetMenuEntry()->GetType() == Util::NUMBER)
++                        )
++                        _editItem = true;
++                    break;
+ 
+-                        }
+-                        break;
+-              case kGreen:
+-                        break;
+-              case kYellow:
+-                        break;
+-              case kBlue:
+-                        break;
+-              case kRight:
+-                        if( n!= NULL &&
+-                            n->GetType() == MenuNode::ENTRY &&
+-                            (n->GetMenuEntry()->GetType() == Util::TEXT ||
+-                            n->GetMenuEntry()->GetType() == Util::NUMBER_TEXT ||
+-                            n->GetMenuEntry()->GetType() == Util::HEX ||
+-                            n->GetMenuEntry()->GetType() == Util::NUMBER 
+-                            )
+-                          )
+-                           _editItem = true;
+-                        break;
+-
+-                default :if( n!= NULL)
+-                         {
+-                          if( n->GetType() == MenuNode::ENTRY)
+-                          {
+-                            SetStatus( n->GetMenuEntry()->GetHelp1());
+-                            if( n->GetMenuEntry()->GetHelp2() != NULL)
+-                              SetHelp(tr("Help"), NULL, NULL, NULL);
+-                            else
+-                              SetHelp(NULL, NULL, NULL, NULL);
++     default:
++                    if (n!= NULL) {
++                       if (n->GetType() == MenuNode::ENTRY) {
++                          SetStatus(n->GetMenuEntry()->GetHelp1());
++                          if (n->GetMenuEntry()->GetHelp2() != NULL)
++                             SetHelp(tr("Help"), NULL, NULL, NULL);
++                          else
++                             SetHelp(NULL, NULL, NULL, NULL);
+                           }
++                       else {
++                          SetStatus(n->GetMenu()->GetHelp1());
++                          if (n->GetMenu()->GetHelp2() != NULL)
++                             SetHelp(tr("Help"), NULL, NULL, NULL);
+                           else
+-                          {
+-                            SetStatus( n->GetMenu()->GetHelp1());
+-                            if( n->GetMenu()->GetHelp2() != NULL)
+-                              SetHelp(tr("Help"), NULL, NULL, NULL);
+-                            else
+-                              SetHelp(NULL, NULL, NULL, NULL);
++                             SetHelp(NULL, NULL, NULL, NULL);
+                           }
+-                         }
+-                        else
+-                            SetStatus(NULL);
+-                      break;
+-      }
+-    return state;
++                       }
++                    else
++                       SetStatus(NULL);
++                    break;
++     }
++   return state;
+ }
+ 
+ void cSetupGenericMenu::ExecuteCommand( const char * cmd )
+@@ -699,20 +770,18 @@
+   char *tmp=NULL;
+   int   status=0;
+ 
+-  if( cmd != NULL)
+-  {
+-    asprintf(&tmp, "%s: %s", tr("Execute"), cmd);
+-    SetStatus(tmp);
+-    free(tmp);
+-    status=system(cmd);
+-    if( status == -1 )
+-      DEBUG3("%s: fork of command %s failed\n", DBG_PREFIX, cmd);
+-    else
+-    {
+-      if( WEXITSTATUS(status) != 0)
+-        DEBUG4("%s: executing of command %s returned=%d\n", DBG_PREFIX, cmd, WEXITSTATUS(status));
+-    }
+-  }
++  if (cmd != NULL) {
++     asprintf(&tmp, "%s: %s", tr("Execute"), cmd);
++     SetStatus(tmp);
++     free(tmp);
++     status=system(cmd);
++     if (status == -1)
++        DEBUG3("%s: fork of command %s failed\n", DBG_PREFIX, cmd);
++     else {
++       if (WEXITSTATUS(status) != 0)
++          DEBUG4("%s: executing of command %s returned=%d\n", DBG_PREFIX, cmd, WEXITSTATUS(status));
++       }
++     }
+ }
+ 
+ 
+@@ -746,33 +815,30 @@
+   _childLockEntered = NULL;
+   _childLockEnteredHidden = NULL;
+ 
+-  if( _config!= NULL && _config->LoadFile() == true)
+-  {
+-    if(_config->GetChildLock() != NULL && strcmp(_config->GetChildLock(), "0000") != 0)
+-    {
+-       _childLock = true;
+-       _childLockEntered          = Util::Strdupnew(_config->GetChildLock());
+-       _childLockEntered[0]       = '\0';
+-        _childLockEnteredHidden   = Util::Strdupnew(_config->GetChildLock());
+-       _childLockEnteredHidden[0] ='\0';
+-       SetAskChildCode();
+-    }
+-    else
+-      Set();
+-  }
+-  else
+-  {
+-    SetStatus(tr("Error in configuration files"));
+-    _error = true;
+-  }
++  if (_config != NULL && _config->LoadFile() == true) {
++     if (_config->GetChildLock() != NULL && strcmp(_config->GetChildLock(), "0000") != 0) {
++        _childLock = true;
++        _childLockEntered          = Util::Strdupnew(_config->GetChildLock());
++        _childLockEntered[0]       = '\0';
++        _childLockEnteredHidden    = Util::Strdupnew(_config->GetChildLock());
++        _childLockEnteredHidden[0] = '\0';
++        SetAskChildCode();
++        }
++     else
++        Set();
++     }
++  else {
++     SetStatus(tr("Error in configuration files"));
++     _error = true;
++     }
+ }
+ 
+ 
+ cSetupMenu::~cSetupMenu()
+ {
+-    delete _config;
+-    delete []_childLockEntered;
+-    delete [] _childLockEnteredHidden;
++  delete _config;
++  delete []_childLockEntered;
++  delete [] _childLockEnteredHidden;
+ }
+ 
+ /**
+@@ -780,25 +846,24 @@
+  */
+ void cSetupMenu::Set( )
+ {
+-  int current = Current();
+-  Menus     *m=_config->GetMenus();
++  int current  = Current();
++  Menus     *m = _config->GetMenus();
+   MenuNode  *n = NULL;
+-  
++
+   Clear();
+   SetHasHotkeys();
+ 
+   // Customized Setup Menus
+-  for(int i=0; i< m->GetNr(); i++)
+-  {
+-    n = m->GetMenuNode(i);
+-    char *tmp = NULL;
+-    asprintf(&tmp, "%s%s", n->GetName(), setupSetup._menuSuffix);
+-    Add(new cOsdItem (hk(tmp)));
+-    free(tmp);
+-  }
++  for (int i=0; i< m->GetNr(); i++) {
++      n = m->GetMenuNode(i);
++      char *tmp = NULL;
++      asprintf(&tmp, "%s%s", n->GetName(), setupSetup._menuSuffix);
++      Add(new cOsdItem (hk(tmp)));
++      free(tmp);
++      }
+   SetCurrent(Get(current));
+-  SetHelp(NULL,  NULL, trVDR("Restart"), tr("Reboot"));
+-  
++  SetHelp(NULL, NULL, trVDR("Restart"), tr("Reboot"));
++
+   Display();
+ }
+ 
+@@ -807,12 +872,12 @@
+  */
+ void cSetupMenu::SetAskChildCode( )
+ {
+-    Clear();
+-    char * tmp= NULL;
+-    asprintf(&tmp, "%s%s", tr("Enter Pin: "), _childLockEnteredHidden);
+-    Add( new cOsdItem (tmp));
+-    free(tmp);
+-    Display();
++  Clear();
++  char *tmp = NULL;
++  asprintf(&tmp, "%s%s", tr("Enter Pin: "), _childLockEnteredHidden);
++  Add(new cOsdItem (tmp));
++  free(tmp);
++  Display();
+ }
+ 
+ 
+@@ -825,10 +890,10 @@
+  */
+ eOSState cSetupMenu::ProcessKey( eKeys Key )
+ {
+-  if(_childLock)
+-    return(GetCodeProcessKey(Key));
++  if (_childLock)
++     return(GetCodeProcessKey(Key));
+   else
+-    return(StandardProcessKey(Key));
++     return(StandardProcessKey(Key));
+ }
+ 
+ /**
+@@ -842,100 +907,89 @@
+ 
+     eOSState state = cOsdMenu::ProcessKey(Key);
+ 
+-    if(HasSubMenu() || HadSubMenu)
+-      return(state);
+-    
++    if (HasSubMenu() || HadSubMenu)
++       return(state);
++
+     int current = Current();
+     MenuNode *node = _config->GetMenus()->GetMenuNode(current);
+-    switch(Key)
+-    {
+-            case kOk :
+-                 if(node != NULL)
+-                 {
+-                    if( node->GetType() == MenuNode::MENU )
+-                    {
+-                      return AddSubMenu(new cSetupGenericMenu(node->GetName(), node, _config));
+-                    }
+-                    else
+-                      if(node->GetType() == MenuNode::MENUSYSTEM )
+-                      {
+-                        cOsdMenu * menu =cSetupSystemMenu::GetSystemMenu (hk(node->GetMenu()->GetSystem()), _config);
+-                        if(menu != NULL)
+-                          AddSubMenu(menu);
+-                      }
+-                      SetCurrent(Get(current));
+-                      return(osContinue);
+-                 }
++    switch (Key) {
++      case kOk :
++                      if (node != NULL) {
++                         if (node->GetType() == MenuNode::MENU) {
++                            return AddSubMenu(new cSetupGenericMenu(node->GetName(), node, _config));
++                            }
++                         else if (node->GetType() == MenuNode::MENUSYSTEM) {
++                            cOsdMenu * menu =cSetupSystemMenu::GetSystemMenu (hk(node->GetMenu()->GetSystem()), _config);
++                            if (menu != NULL)
++                               AddSubMenu(menu);
++                            }
++                         SetCurrent(Get(current));
++                         return(osContinue);
++                         }
+                       break;
+-            case kRed:
+-                    {
+-                      char *help = NULL;
+-                      if(node->GetType() == MenuNode::ENTRY)
+-                        help = GetLongHelp(node->GetMenuEntry()->GetHelp2());
+-                      else
+-                        help = GetLongHelp(node->GetMenu()->GetHelp2());
+-
+-                      if( help != NULL )
++      case kRed:
+                       {
+-                        eOSState newState = AddSubMenu(new cMenuText(tr("Help"), help, fontFix));
+-                        free(help);
+-                        return(newState);
+-                      }
++                         char *help = NULL;
++                         if (node->GetType() == MenuNode::ENTRY)
++                            help = GetLongHelp(node->GetMenuEntry()->GetHelp2());
++                         else
++                            help = GetLongHelp(node->GetMenu()->GetHelp2());
+ 
+-                    }
++                         if (help != NULL) {
++                            eOSState newState = AddSubMenu(new cMenuText(tr("Help"), help, fontFix));
++                            free(help);
++                            return(newState);
++                            }
++
++                         }
+                       break;
+-            case kYellow:
+-                        if (Interface->Confirm(cRecordControls::Active() ? trVDR("Recording - restart anyway?") : trVDR("Really restart?")))
+-                        {
++      case kYellow:
++                      if (Interface->Confirm(cRecordControls::Active() ? trVDR("Recording - restart anyway?") : trVDR("Really restart?"))) {
+ #if APIVERSNUM >= 10501
+-                          ShutdownHandler.RequestEmergencyExit();
++                         ShutdownHandler.RequestEmergencyExit();
+ #else
+-                          cThread::EmergencyExit(true);
++                         cThread::EmergencyExit(true);
+ #endif
+-                          return osEnd;
+-                        }
+-                        return osContinue;
++                         return osEnd;
++                         }
++                      return osContinue;
+                       break;
+-            case kBlue:
+-                        if (Interface->Confirm(cRecordControls::Active() ? trVDR("Recording - restart anyway?") : tr("Really reboot?")))
+-                        {
++      case kBlue:
++                      if (Interface->Confirm(cRecordControls::Active() ? trVDR("Recording - restart anyway?") : tr("Really reboot?"))) {
+ #if APIVERSNUM >= 10501
+-                          ShutdownHandler.RequestEmergencyExit();
++                         ShutdownHandler.RequestEmergencyExit();
+ #else
+-                          cThread::EmergencyExit(true);
++                         cThread::EmergencyExit(true);
+ #endif
+-                          system(_config->GetBootLinux());
+-                        }
+-                        return osContinue;
++                         system(_config->GetBootLinux());
++                         }
++                      return osContinue;
+                       break;
+ 
+-            case kNone:
++      case kNone:
+                       break;
+ 
+-              default :if( node!= NULL)
+-              {
+-                if( node->GetType() == MenuNode::ENTRY)
+-                {
+-                  SetStatus( node->GetMenuEntry()->GetHelp1());
+-                  if( node->GetMenuEntry()->GetHelp2() != NULL)
+-                    SetHelp(tr("Help"), NULL, trVDR("Restart"), tr("Reboot"));
+-                  else
+-                    SetHelp(NULL, NULL,  trVDR("Restart"), tr("Reboot"));
+-                }
+-                else
+-                {
+-                  SetStatus( node->GetMenu()->GetHelp1());
+-                  if( node->GetMenu()->GetHelp2() != NULL)
+-                    SetHelp(tr("Help"), NULL,  trVDR("Restart"), tr("Reboot"));
+-                  else
+-                    SetHelp(NULL, NULL,  trVDR("Restart"), tr("Reboot"));
+-                }
+-              }
+-              else
+-                SetStatus(NULL);
+-              break;
+-    }
+-
++      default:
++                      if (node!= NULL) {
++                         if (node->GetType() == MenuNode::ENTRY) {
++                            SetStatus(node->GetMenuEntry()->GetHelp1());
++                            if (node->GetMenuEntry()->GetHelp2() != NULL)
++                               SetHelp(tr("Help"), NULL, trVDR("Restart"), tr("Reboot"));
++                            else
++                               SetHelp(NULL, NULL, trVDR("Restart"), tr("Reboot"));
++                            }
++                         else {
++                            SetStatus( node->GetMenu()->GetHelp1());
++                            if (node->GetMenu()->GetHelp2() != NULL)
++                               SetHelp(tr("Help"), NULL, trVDR("Restart"), tr("Reboot"));
++                            else
++                               SetHelp(NULL, NULL, trVDR("Restart"), tr("Reboot"));
++                            }
++                         }
++                      else
++                         SetStatus(NULL);
++                      break;
++      }
+     return state;
+ 
+ }
+@@ -951,77 +1005,70 @@
+ {
+   int num;
+   eOSState state = cOsdMenu::ProcessKey(Key);
+-    
+-    switch(Key)
+-    {
+-            case k0 ... k9:
++
++  switch (Key) {
++    case k0 ... k9:
+                 num = Key - k0;
+                 sprintf(_childLockEntered, "%s%d", _childLockEntered, num);
+                 sprintf(_childLockEnteredHidden, "%s*", _childLockEnteredHidden);
+                 SetAskChildCode();
+-                if(strlen(_childLockEntered) == strlen(_config->GetChildLock()))
+-                {
+-                  if(strcmp(_childLockEntered,_config->GetChildLock())==0)
+-                  {
+-                    _childLock=false;
+-                    Set();
+-                  }
+-                  else
+-                  {
+-                    _childLockEntered[0]='\0';
+-                    _childLockEnteredHidden[0]='\0';
+-                    SetStatus(tr("Invalid Pin!"));
+-                  }
+-                }
+-                else
+-                {
+-                  SetStatus(NULL);
+-                }
+-
++                if (strlen(_childLockEntered) == strlen(_config->GetChildLock())) {
++                   if (strcmp(_childLockEntered,_config->GetChildLock()) == 0) {
++                      _childLock=false;
++                      Set();
++                      }
++                   else {
++                      _childLockEntered[0] = '\0';
++                      _childLockEnteredHidden[0] = '\0';
++                      SetStatus(tr("Invalid Pin!"));
++                      }
++                   }
++                else {
++                   SetStatus(NULL);
++                   }
+                 break;
+ 
+ 
+-             case kBack:
+-                      return osBack;
+-                      break;
+-             case kNone:
+-                      break;
+-            default : SetStatus(NULL);
+-                      break;
++    case kBack:
++                return osBack;
++                break;
++    case kNone:
++                break;
++    default:
++                SetStatus(NULL);
++                break;
+     }
+-    return state;
++  return state;
+ }
+ 
+ //
+ char * cSetupMenu::GetLongHelp( const char * help )
+ {
+-  char *helpfile    = NULL;
++  char *helpfile = NULL;
+   char *result = NULL;
+ 
+-  if( help != NULL)
+-  {
+-    asprintf(&helpfile, "%s/setup/help/%s", cPlugin::ConfigDirectory(), help);
+-    FILE *fp = fopen(helpfile, "r");
+-    if(fp != NULL )
+-    {
+-      fseek(fp, 0L, SEEK_END);
+-    
+-      long len = ftell(fp);
+-      fseek(fp, 0L, SEEK_SET);
+-      int byteRead=0;
+-      if( (result=(char*) malloc(len+1)) == NULL)
+-        DEBUG3("%s: can not allocate buffer for Helpfile: %s\n", DBG_PREFIX, helpfile );
+-      else
+-        if( (byteRead=fread(result, 1, len, fp)) == -1)
+-          DEBUG3("%s: can not read file: Helpfile: %s\n", DBG_PREFIX, helpfile);
+-      else
+-        result[byteRead] = '\0';
+-      fclose(fp);
+-    }
+-    else
+-      DEBUG4("%s: can not open Helpfile: %s, %s\n", DBG_PREFIX, helpfile, strerror(errno));
+-    free(helpfile);
+-  }
++  if (help != NULL) {
++     asprintf(&helpfile, "%s/setup/help/%s", cPlugin::ConfigDirectory(), help);
++     FILE *fp = fopen(helpfile, "r");
++     if (fp != NULL) {
++        fseek(fp, 0L, SEEK_END);
++
++        long len = ftell(fp);
++        fseek(fp, 0L, SEEK_SET);
++        int byteRead = 0;
++        if ((result = (char*) malloc(len+1)) == NULL)
++           DEBUG3("%s: can not allocate buffer for Helpfile: %s\n", DBG_PREFIX, helpfile );
++        else
++        if ((byteRead = fread(result, 1, len, fp)) == -1)
++           DEBUG3("%s: can not read file: Helpfile: %s\n", DBG_PREFIX, helpfile);
++        else
++           result[byteRead] = '\0';
++        fclose(fp);
++        }
++     else
++        DEBUG4("%s: can not open Helpfile: %s, %s\n", DBG_PREFIX, helpfile, strerror(errno));
++     free(helpfile);
++     }
+   return(result);
+ }
+ 
+diff -ruN setup-0.3.1-zulu-edition-old/setupmenu.h setup-0.3.1-zulu-edition/setupmenu.h
+--- setup-0.3.1-zulu-edition-old/setupmenu.h	2005-10-12 15:44:14.000000000 +0200
++++ setup-0.3.1-zulu-edition/setupmenu.h	2008-06-17 19:10:41.000000000 +0200
+@@ -36,11 +36,11 @@
+ class cSetupPluginMenu : public cOsdMenu
+ {
+ private:
+-   Config  *_config;
+-   Plugins *_plugins;
+-   int      _startIndex;
+-   bool     _moveMode;
+-   bool     _sortMode;
++    Config  *_config;
++    Plugins *_plugins;
++    int      _startIndex;
++    bool     _moveMode;
++    bool     _sortMode;
+ public:
+     cSetupPluginMenu(Config  *config);
+     ~cSetupPluginMenu();
+@@ -54,19 +54,22 @@
+ class cSetupVdrMenu : public cOsdMenu
+ {
+ private:
+-    enum MenuState { UNDEFINED, MOVE, CREATE, EDIT, DELETE};
+-    cSubMenu _vdrSubMenu;
+-    char     *createMenuName(cSubMenuNode *node);
++    enum MenuState { UNDEFINED, MOVE, CREATE, CREATECMD, EDIT, DELETE};
++    cSubMenu  _vdrSubMenu;
++    char      *createMenuName(cSubMenuNode *node);
+     void      setHelp();
+     MenuState _menuState;
+-    
++
+     int       _startIndex;
+     int       _createEditNodeIndex;
+ 
+-    char      _editTitle[35];
++    char      _editTitle[50];
++    char      _editCommand[999];
++    int       _hasToConfirm;
++    int       _isThread;
+ public:
+     cSetupVdrMenu(const char *title);
+-   
++
+     ~cSetupVdrMenu();
+     void  Set();
+     eOSState ProcessKey(eKeys Key);
+@@ -77,23 +80,23 @@
+ {
+ private:
+ 
+-   int      _number;
+-   bool     _error;
+-   bool     _childLock;
++   int  _number;
++   bool _error;
++   bool _childLock;
+    char *_childLockEntered;
+    char *_childLockEnteredHidden;
+ 
+ protected:
+-   Config  *_config;
++   Config *_config;
+ public:
+     cSetupMenu();
+     ~cSetupMenu();
+-    void  Set();
+-    void  SetAskChildCode();
++    void Set();
++    void SetAskChildCode();
+     eOSState ProcessKey(eKeys Key);
+     eOSState StandardProcessKey(eKeys Key);
+     eOSState GetCodeProcessKey(eKeys Key);
+-    char     *GetLongHelp(const char* help);
++    char *GetLongHelp(const char* help);
+ };
+ 
+ class cSetupGenericMenu : public cSetupMenu
+@@ -107,7 +110,7 @@
+   public:
+     cSetupGenericMenu(const char *title, MenuNode *node, Config  *config);
+     ~cSetupGenericMenu();
+-    void       Set();
++    void      Set();
+     eOSState  ProcessKey(eKeys Key);
+     void      ExecuteCommand(const char* cmd);
+ };
Index: vdr-2.2.0/PLUGINS/src/setup/patches/vdr-1.4.7-ext_setup_lang.diff
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/patches/vdr-1.4.7-ext_setup_lang.diff	2015-12-24 15:16:31.688279566 +0100
@@ -0,0 +1,14 @@
+diff -ruNp vdr-1.4.7-ext~/menu.c vdr-1.4.7-ext/menu.c
+--- vdr-1.4.7-ext~/menu.c	2008-01-22 15:00:36.000000000 +0100
++++ vdr-1.4.7-ext/menu.c	2008-01-22 14:58:55.000000000 +0100
+@@ -3999,7 +3999,9 @@ cMenuMain::cMenuMain(eOSState State)
+ #ifdef USE_SETUP
+   // Load Menu Configuration
+   char *menuXML = NULL;
+-  asprintf(&menuXML, "%s/setup/vdr-menu.xml", cPlugin::ConfigDirectory());
++  asprintf(&menuXML, "%s/setup/vdr-menu.%i.xml", cPlugin::ConfigDirectory(), Setup.OSDLanguage);
++  if (access(menuXML, 04) == -1)
++     asprintf(&menuXML, "%s/setup/vdr-menu.xml", cPlugin::ConfigDirectory());
+   subMenu.LoadXml(menuXML);
+   free(menuXML);
+   nrDynamicMenuEntries=0;
Index: vdr-2.2.0/PLUGINS/src/setup/patches/vdr-1.5.13-ext_setup_lang.diff
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/patches/vdr-1.5.13-ext_setup_lang.diff	2015-12-24 15:16:31.688279566 +0100
@@ -0,0 +1,14 @@
+diff -ruNp vdr-1.5.13-ext~/menu.c vdr-1.5.13-ext/menu.c
+--- vdr-1.5.13-ext~/menu.c	2008-01-22 15:00:36.000000000 +0100
++++ vdr-1.5.13-ext/menu.c	2008-01-22 14:58:55.000000000 +0100
+@@ -3913,7 +3913,9 @@ cMenuMain::cMenuMain(eOSState State)
+ #ifdef USE_SETUP
+   // Load Menu Configuration
+   char *menuXML = NULL;
+-  asprintf(&menuXML, "%s/setup/vdr-menu.xml", cPlugin::ConfigDirectory());
++  asprintf(&menuXML, "%s/setup/vdr-menu.%s.xml", cPlugin::ConfigDirectory(), Setup.OSDLanguage);
++  if (access(menuXML, 04) == -1)
++     asprintf(&menuXML, "%s/setup/vdr-menu.xml", cPlugin::ConfigDirectory());
+   subMenu.LoadXml(menuXML);
+   free(menuXML);
+   nrDynamicMenuEntries=0;
Index: vdr-2.2.0/PLUGINS/src/setup/patches/vdr-1.6.0-2_setup-zulu-edition.diff
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/patches/vdr-1.6.0-2_setup-zulu-edition.diff	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,6280 @@
+diff -ruNp vdr-1.6.0-2/Make.config.template vdr-1.6.0-2-setup-zulu-edition/Make.config.template
+--- vdr-1.6.0-2/Make.config.template	2008-01-13 13:54:09.000000000 +0100
++++ vdr-1.6.0-2-setup-zulu-edition/Make.config.template	2009-01-19 10:02:02.000000000 +0100
+@@ -41,8 +41,15 @@ RCU_DEVICE  = /dev/ttyS1
+ ## Define if you want vdr to not run as root
+ #VDR_USER = vdr
+ 
++### Define if you want use the setup-plugin
++SETUP = 1
++
+ ### You don't need to touch the following:
+ 
+ ifdef DVBDIR
+ INCLUDES += -I$(DVBDIR)/include
+ endif
++
++ifdef SETUP
++DEFINES += -DUSE_SETUP
++endif
+diff -ruNp vdr-1.6.0-2/Makefile vdr-1.6.0-2-setup-zulu-edition/Makefile
+--- vdr-1.6.0-2/Makefile	2008-02-29 22:43:03.000000000 +0100
++++ vdr-1.6.0-2-setup-zulu-edition/Makefile	2009-01-19 10:00:10.000000000 +0100
+@@ -43,6 +43,10 @@ OBJS = audio.o channels.o ci.o config.o 
+        skinclassic.o skins.o skinsttng.o sources.o spu.o status.o svdrp.o themes.o thread.o\
+        timers.o tools.o transfer.o vdr.o videodir.o
+ 
++ifdef SETUP
++OBJS += tinystr.o tinyxml.o tinyxmlerror.o tinyxmlparser.o submenu.o
++endif
++
+ ifndef NO_KBD
+ DEFINES += -DREMOTE_KBD
+ endif
+diff -ruNp vdr-1.6.0-2/menu.c vdr-1.6.0-2-setup-zulu-edition/menu.c
+--- vdr-1.6.0-2/menu.c	2008-03-16 12:15:28.000000000 +0100
++++ vdr-1.6.0-2-setup-zulu-edition/menu.c	2009-01-19 09:43:52.000000000 +0100
+@@ -2964,6 +2964,16 @@ cOsdObject *cMenuMain::pluginOsdObject =
+ cMenuMain::cMenuMain(eOSState State)
+ :cOsdMenu("")
+ {
++#ifdef USE_SETUP
++  // Load Menu Configuration
++  char *menuXML = NULL;
++  asprintf(&menuXML, "%s/setup/vdr-menu.%s.xml", cPlugin::ConfigDirectory(), Setup.OSDLanguage);
++  if (access(menuXML, 04) == -1)
++     asprintf(&menuXML, "%s/setup/vdr-menu.xml", cPlugin::ConfigDirectory());
++  subMenu.LoadXml(menuXML);
++  free(menuXML);
++  nrDynamicMenuEntries=0;
++#endif /* SETUP */
+   replaying = false;
+   stopReplayItem = NULL;
+   cancelEditingItem = NULL;
+@@ -2991,12 +3001,59 @@ cOsdObject *cMenuMain::PluginOsdObject(v
+   return o;
+ }
+ 
++#ifdef USE_SETUP
++void cMenuMain::Set(int current)
++#else
+ void cMenuMain::Set(void)
++#endif /* SETUP */
+ {
+   Clear();
+   SetTitle("VDR");
+   SetHasHotkeys();
+ 
++#ifdef USE_SETUP
++  stopReplayItem = NULL;
++  cancelEditingItem = NULL;
++  stopRecordingItem = NULL;
++
++  // remember initial dynamic MenuEntries added
++  nrDynamicMenuEntries = Count();
++  for (cSubMenuNode *node = subMenu.GetMenuTree()->First(); node; node = subMenu.GetMenuTree()->Next(node)) {
++      cSubMenuNode::Type type = node->GetType();
++      if (type==cSubMenuNode::PLUGIN) {
++         const char *item = node->GetPluginMainMenuEntry();
++         if (item)
++            Add(new cMenuPluginItem(hk(item), node->GetPluginIndex()));
++         }
++      else if (type==cSubMenuNode::MENU) {
++         cString item = cString::sprintf("%s%s", node->GetName(), subMenu.GetMenuSuffix());
++            Add(new cOsdItem(hk(item)));
++         }
++      else if ((type==cSubMenuNode::COMMAND) || (type==cSubMenuNode::THREAD)) {
++            Add(new cOsdItem(hk(node->GetName())));
++         }
++      else if (type==cSubMenuNode::SYSTEM) {
++         const char *item = node->GetName();
++         if (strcmp(item, "Schedule") == 0)
++            Add(new cOsdItem(hk(tr("Schedule")), osSchedule));
++         else if (strcmp(item, "Channels") == 0)
++            Add(new cOsdItem(hk(tr("Channels")), osChannels));
++         else if (strcmp(item, "Timers") == 0)
++            Add(new cOsdItem(hk(tr("Timers")), osTimers));
++         else if (strcmp(item, "Recordings") == 0)
++            Add(new cOsdItem(hk(tr("Recordings")), osRecordings));
++         else if (strcmp(item, "Setup") == 0)
++            Add(new cOsdItem(hk(tr("Setup")), osSetup));
++         else if (strcmp(item, "Commands") == 0 && Commands.Count()>0)
++            Add(new cOsdItem(hk(tr("Commands")), osCommands));
++         }
++     }
++  if (current >=0 && current<Count()) {
++     SetCurrent(Get(current));
++     }
++
++#else /* NO SETUP */
++
+   // Basic menu items:
+ 
+   Add(new cOsdItem(hk(tr("Schedule")),   osSchedule));
+@@ -3023,6 +3080,8 @@ void cMenuMain::Set(void)
+   if (Commands.Count())
+      Add(new cOsdItem(hk(tr("Commands")),  osCommands));
+ 
++#endif /* SETUP */
++
+   Update(true);
+ 
+   Display();
+@@ -3032,12 +3091,28 @@ bool cMenuMain::Update(bool Force)
+ {
+   bool result = false;
+ 
++#ifdef USE_SETUP
++  cOsdItem *fMenu = NULL;
++  if (Force && subMenu.isTopMenu()) {
++     fMenu = First();
++     nrDynamicMenuEntries = 0;
++     }
++
++  if (subMenu.isTopMenu()) {
++#endif /* SETUP */
+   // Title with disk usage:
+   if (FreeDiskSpace.HasChanged(Force)) {
+      //XXX -> skin function!!!
+      SetTitle(cString::sprintf("%s  -  %s", tr("VDR"), FreeDiskSpace.FreeDiskSpaceString()));
+      result = true;
+      }
++#ifdef USE_SETUP
++     }
++  else {
++     SetTitle(cString::sprintf("%s  -  %s", tr("VDR"), subMenu.GetParentMenuTitel()));
++     result = true;
++     }
++#endif /* SETUP */
+ 
+   bool NewReplaying = cControl::Control() != NULL;
+   if (Force || NewReplaying != replaying) {
+@@ -3086,6 +3161,12 @@ bool cMenuMain::Update(bool Force)
+      result = true;
+      }
+ 
++#ifdef USE_SETUP
++  // adjust nrDynamicMenuEntries
++  if (fMenu != NULL)
++     nrDynamicMenuEntries = fMenu->Index();
++#endif /* SETUP */
++
+   return result;
+ }
+ 
+@@ -3135,6 +3216,18 @@ eOSState cMenuMain::ProcessKey(eKeys Key
+                          state = osEnd;
+                        }
+                        break;
++#ifdef USE_SETUP
++    case osBack:       {
++                         int newCurrent = 0;
++                         if (subMenu.Up(&newCurrent)) {
++                            Set(newCurrent);
++                            return osContinue;
++                            }
++                         else
++                            return osEnd;
++                       }
++                       break;
++#endif /* SETUP */
+     default: switch (Key) {
+                case kRecord:
+                case kRed:    if (!HadSubMenu)
+@@ -3151,6 +3244,52 @@ eOSState cMenuMain::ProcessKey(eKeys Key
+                case kBlue:   if (!HadSubMenu)
+                                 state = replaying ? osStopReplay : cReplayControl::LastReplayed() ? osReplay : osContinue;
+                              break;
++#ifdef USE_SETUP
++               case kOk:     if (state == osUnknown) {
++                                cString buffer;
++                                int index = Current()-nrDynamicMenuEntries;
++                                cSubMenuNode *node = subMenu.GetNode(index);
++
++                                if (node != NULL) {
++                                   if (node->GetType() == cSubMenuNode::MENU) {
++                                      subMenu.Down(index);
++                                      }
++                                   else if (node->GetType() == cSubMenuNode::COMMAND) {
++                                      bool confirmed = true;
++                                      if (node->CommandConfirm()) {
++                                         buffer = cString::sprintf("%s?", node->GetName());
++                                         confirmed = Interface->Confirm(buffer);
++                                         }
++                                      if (confirmed) {
++                                         const char *Result = subMenu.ExecuteCommand(node->GetCommand());
++                                         if (Result)
++                                            return AddSubMenu(new cMenuText(node->GetName(), Result, fontFix));
++                                         return osEnd;
++                                         }
++                                      }
++                                   else if (node->GetType() == cSubMenuNode::THREAD) {
++                                      bool confirmed = true;
++                                      if (node->CommandConfirm()) {
++                                         buffer = cString::sprintf("%s?", node->GetName());
++                                         confirmed = Interface->Confirm(buffer);
++                                         }
++                                      if (confirmed) {
++                                         buffer = cString::sprintf("%s", node->GetCommand());
++                                         cExecCmdThread *execcmd = new cExecCmdThread(node->GetCommand());
++                                         if (execcmd->Start())
++                                            dsyslog("executing command '%s'", *buffer);
++                                         else
++                                            esyslog("ERROR: can't execute command '%s'", *buffer);
++                                         return osEnd;
++                                         }
++                                      }
++                                   }
++
++                                Set();
++                                return osContinue;
++                                }
++                             break;
++#endif /* SETUP */
+                default:      break;
+                }
+     }
+diff -ruNp vdr-1.6.0-2/menu.h vdr-1.6.0-2-setup-zulu-edition/menu.h
+--- vdr-1.6.0-2/menu.h	2008-02-10 17:01:53.000000000 +0100
++++ vdr-1.6.0-2-setup-zulu-edition/menu.h	2009-01-19 09:43:52.000000000 +0100
+@@ -18,6 +18,9 @@
+ #include "menuitems.h"
+ #include "recorder.h"
+ #include "skins.h"
++#ifdef USE_SETUP
++#include "submenu.h"
++#endif /* SETUP */
+ 
+ class cMenuText : public cOsdMenu {
+ private:
+@@ -56,14 +59,23 @@ public:
+ 
+ class cMenuMain : public cOsdMenu {
+ private:
++#ifdef USE_SETUP
++  int    nrDynamicMenuEntries;
++#endif /* SETUP */
+   bool replaying;
+   cOsdItem *stopReplayItem;
+   cOsdItem *cancelEditingItem;
+   cOsdItem *stopRecordingItem;
+   int recordControlsState;
+   static cOsdObject *pluginOsdObject;
++#ifdef USE_SETUP
++  void Set(int current=0);
++  bool Update(bool Force = false);
++  cSubMenu subMenu;
++#else
+   void Set(void);
+   bool Update(bool Force = false);
++#endif /* SETUP */
+ public:
+   cMenuMain(eOSState State = osUnknown);
+   virtual eOSState ProcessKey(eKeys Key);
+diff -ruNp vdr-1.6.0-2/submenu.c vdr-1.6.0-2-setup-zulu-edition/submenu.c
+--- vdr-1.6.0-2/submenu.c	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0-2-setup-zulu-edition/submenu.c	2009-01-19 09:43:52.000000000 +0100
+@@ -0,0 +1,928 @@
++#ifdef USE_SETUP
++/****************************************************************************
++ * DESCRIPTION:
++ *             Submenu
++ *
++ * $Id: vdr-1.3.44-Setup-0.3.0.diff,v 1.1 2006/03/04 09:58:47 ralf Exp $
++ *
++ * Contact:    ranga@teddycats.de
++ *
++ * Copyright (C) 2004, 2005 by Ralf Dotzert
++ *
++ * modified for the VDR Extensions Patch by zulu @vdr-portal
++ *
++ ****************************************************************************/
++
++#ifndef SUBMENU_H
++#include "submenu.h"
++#include "plugin.h"
++
++static const char* TAG_SYSTEM      = "system";
++static const char* TAG_PLUGIN      = "plugin";
++static const char* TAG_COMMAND     = "command";
++static const char* TAG_THREAD      = "thread";
++static const char* TAG_MENU        = "menu";
++static const char* TAG_UNDEFINED   = "undefined";
++static const char* TRUE_STR        = "yes";
++
++
++//################################################################################
++//# SubMenuNode
++//################################################################################
++
++cSubMenuNode::cSubMenuNode(TiXmlElement * xml, int level,  cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu)
++{
++  init();
++  _parentMenu  = parentMenu;
++  _currentMenu = currentMenu;
++  _level       = level;
++
++  if (xml != NULL && xml->Type() == TiXmlNode::ELEMENT) {
++     const char *tag = xml->Value();
++
++     if (cSubMenuNode::IsType(tag) != cSubMenuNode::UNDEFINED) {
++        SetType(tag);
++        SetName(xml->Attribute("name"));
++        if ((_type == COMMAND) || (_type == THREAD)) {
++           SetCommand(xml->Attribute("execute"));
++           const char * confirmStr = xml->Attribute("confirm");
++           if (confirmStr != NULL && strcmp(confirmStr, TRUE_STR) == 0)
++              _commandConfirm = true;
++           }
++        else if (_type == PLUGIN) { // Add Plugin Index
++           SetCustomTitle(xml->Attribute("title"));
++           SetPlugin();
++           }
++        else if (_type == MENU && xml->NoChildren() == false) {
++           xml = xml->FirstChildElement();
++           do {
++              cSubMenuNode *node = new cSubMenuNode(xml, level+1, &_subMenus, currentMenu);
++              _subMenus.Add(node);
++              } while ((xml=xml->NextSiblingElement()) != NULL);
++           }
++        }
++     }
++  else
++     throw "Invalid XML Node";
++}
++
++/**
++ * Construct new Node empty Node
++ *
++ *
++ */
++cSubMenuNode::cSubMenuNode(cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu)
++{
++  init();
++  _parentMenu  = parentMenu;
++  _currentMenu = currentMenu;
++
++}
++
++
++/**
++ *
++ */
++void cSubMenuNode::init()
++{
++  _name                = NULL;
++  _command             = NULL;
++  _title               = NULL;
++  _pluginMainMenuEntry = NULL;
++  _type                = UNDEFINED;
++  _level               = 0;
++  _parentMenu          = NULL;
++  _currentMenu         = NULL;
++  _pluginIndex         = 0;
++  _commandConfirm      = false;
++}
++
++
++cSubMenuNode::~ cSubMenuNode()
++{
++  if (_name != NULL)
++     free((void*)_name);
++  if (_command != NULL)
++     free((void*)_command);
++  if (_title != NULL)
++     free((void*)_title);
++  if (_pluginMainMenuEntry != NULL)
++     free((void*)_pluginMainMenuEntry);
++}
++
++/**
++ *
++ */
++void cSubMenuNode::SetPlugin()
++{
++  bool found = false;
++  for (int i = 0; ; i++) {
++      cPlugin *p = cPluginManager::GetPlugin(i);
++      if (p) {
++         if (strcmp(_name, p->Name()) == 0 && p->MainMenuEntry() != NULL) {
++            SetPluginMainMenuEntry(p->MainMenuEntry());
++            _pluginIndex = i;
++            found = true;
++            break;
++            }
++         }
++      else
++         break;
++      }
++
++      if (!found)
++         _type = UNDEFINED;
++}
++
++
++bool cSubMenuNode::SaveXml(TiXmlElement * root)
++{
++  bool ok = true;
++
++  if (root!=NULL) {
++     TiXmlElement *e = NULL;
++     switch(_type) {
++        case SYSTEM:
++           e = new TiXmlElement(TAG_SYSTEM);
++           e->SetAttribute("name", GetName());
++           break;
++        case COMMAND:
++           e = new TiXmlElement(TAG_COMMAND);
++           e->SetAttribute("name", GetName());
++           e->SetAttribute("execute", GetCommand());
++           if (_commandConfirm)
++              e->SetAttribute("confirm", TRUE_STR);
++           break;
++        case THREAD:
++           e = new TiXmlElement(TAG_THREAD);
++           e->SetAttribute("name", GetName());
++           e->SetAttribute("execute", GetCommand());
++           if (_commandConfirm)
++              e->SetAttribute("confirm", TRUE_STR);
++           break;
++        case PLUGIN:
++           e = new TiXmlElement(TAG_PLUGIN);
++           e->SetAttribute("name", GetName());
++           if (GetCustomTitle() != NULL && strcmp(GetCustomTitle(), "") != 0)
++              e->SetAttribute("title", GetCustomTitle());
++           break;
++        case MENU:
++           e = new TiXmlElement(TAG_MENU);
++           e->SetAttribute("name", GetName());
++           break;
++        case UNDEFINED:
++        default:
++           ok = false;
++           break;
++        }
++        if (ok) {
++           root->LinkEndChild(e);
++           if (HasSubMenus())
++              for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
++                  node->SaveXml(e);
++           }
++     }
++
++  return(ok);
++}
++
++
++cSubMenuNode::Type cSubMenuNode::IsType(const char *name)
++{
++  Type type = UNDEFINED;
++
++  if (strcmp(name ,TAG_SYSTEM) == 0)
++     type = cSubMenuNode::SYSTEM;
++  else if (strcmp(name ,TAG_PLUGIN) == 0)
++     type = cSubMenuNode::PLUGIN;
++  else if (strcmp(name ,TAG_COMMAND) == 0)
++     type = cSubMenuNode::COMMAND;
++  else if (strcmp(name ,TAG_THREAD) == 0)
++     type = cSubMenuNode::THREAD;
++  else if (strcmp(name ,TAG_MENU) == 0)
++     type = cSubMenuNode::MENU;
++
++  return(type);
++}
++
++void cSubMenuNode::SetType(const char * name)
++{
++   _type = IsType(name);
++}
++
++void cSubMenuNode::SetType(enum Type type)
++{
++  _type = type;
++}
++
++
++cSubMenuNode::Type cSubMenuNode::GetType()
++{
++  return(_type);
++}
++
++const char * cSubMenuNode::GetTypeAsString()
++{
++  const char *str=NULL;
++  switch(_type) {
++     case SYSTEM:
++        str = TAG_SYSTEM;
++        break;
++     case COMMAND:
++        str = TAG_COMMAND;
++        break;
++     case THREAD:
++        str = TAG_THREAD;
++        break;
++     case PLUGIN:
++        str = TAG_PLUGIN;
++        break;
++     case MENU:
++        str = TAG_MENU;
++        break;
++     case UNDEFINED:
++        str = TAG_UNDEFINED;
++     default:
++        break;
++    }
++
++  return(str);
++}
++
++void cSubMenuNode::SetCommand(const char * command)
++{
++  if (_command != NULL)
++     free((void*)_command);
++
++  if (command != NULL)
++     _command = strdup(command);
++  else
++     _command = NULL;
++}
++
++const char * cSubMenuNode::GetCommand()
++{
++  return(_command);
++}
++
++bool cSubMenuNode::CommandConfirm()
++{
++  return(_commandConfirm);
++}
++
++void cSubMenuNode::SetCommandConfirm(int val)
++{
++  if (val == 1)
++     _commandConfirm = true;
++  else
++     _commandConfirm = false;
++}
++
++void cSubMenuNode::SetCustomTitle(const char * title)
++{
++  if (_title != NULL)
++     free((void*)_title);
++
++  if (title != NULL)
++     _title = strdup(title);
++  else
++     _title = NULL;
++}
++
++const char * cSubMenuNode::GetCustomTitle()
++{
++  return(_title);
++}
++
++void cSubMenuNode::SetName(const char * name)
++{
++  if (_name)
++     free ((void*)_name);
++
++  if (name != NULL)
++     _name = strdup(name);
++  else
++     _name = NULL;
++}
++
++const char * cSubMenuNode::GetName()
++{
++  return(_name);
++}
++
++int cSubMenuNode::GetLevel()
++{
++  return(_level);
++}
++
++void cSubMenuNode::SetLevel(int level)
++{
++  _level = level;
++  if (HasSubMenus()) { //Adjust Levels of Subnodes
++     for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
++         node->SetLevel(level+1);
++     }
++}
++
++int cSubMenuNode::GetPluginIndex()
++{
++  return(_pluginIndex);
++}
++
++void cSubMenuNode::SetPluginIndex(int index)
++{
++  _pluginIndex = index;
++}
++
++void cSubMenuNode::SetPluginMainMenuEntry(const char * mainMenuEntry)
++{
++  if (_pluginMainMenuEntry != NULL)
++     free((void*)_pluginMainMenuEntry);
++
++  if (_title != NULL && strcmp(_title, "") != 0)
++     _pluginMainMenuEntry = strdup(_title);
++  else if (mainMenuEntry != NULL)
++     _pluginMainMenuEntry = strdup(mainMenuEntry);
++  else
++     _pluginMainMenuEntry = NULL;
++}
++
++const char * cSubMenuNode::GetPluginMainMenuEntry()
++{
++  return(_pluginMainMenuEntry);
++}
++
++
++
++cSubMenuNodes * cSubMenuNode::GetParentMenu()
++{
++  return(_parentMenu);
++}
++
++void cSubMenuNode::SetParentMenu(cSubMenuNodes * parent)
++{
++  _parentMenu = parent;
++}
++
++cSubMenuNodes * cSubMenuNode::GetCurrentMenu()
++{
++  return(_currentMenu);
++}
++
++void cSubMenuNode::SetCurrentMenu(cSubMenuNodes * current)
++{
++  _currentMenu = current;
++}
++
++
++cSubMenuNodes * cSubMenuNode::GetSubMenus()
++{
++  return(&_subMenus);
++}
++
++bool cSubMenuNode::HasSubMenus()
++{
++  if (_subMenus.Count() > 0)
++     return(true);
++  else
++     return(false);
++}
++
++
++void cSubMenuNode::Print(int index)
++{
++  for (int i = 0; i < index; i++)
++      printf(" ");
++
++  printf("Name=%s Type=%s Level=%d", _name, GetTypeAsString(), _level);
++  if (_type == COMMAND || _type == THREAD)
++     printf(" Command=%s", _command);
++  else if (_type == PLUGIN && _title != NULL)
++     printf(" Title=%s", _title);
++  printf("\n");
++
++  for (cSubMenuNode *node = _subMenus.First(); node; node = _subMenus.Next(node))
++      node->Print(index+4);
++}
++
++
++//################################################################################
++//#
++//################################################################################
++cSubMenu::cSubMenu()
++{
++  _menuSuffix            = NULL;
++  _fname                 = NULL;
++  _commandResult         = NULL;
++  _currentMenuTree       = &_menuTree;
++  _currentParentMenuTree = NULL;
++  _nodeArray             = NULL;
++  _nrNodes               = 0;
++}
++
++
++cSubMenu::~cSubMenu()
++{
++  if (_menuSuffix)
++     free(_menuSuffix);
++  if (_fname)
++     free(_fname);
++  if (_commandResult)
++     free(_commandResult);
++  if (_nodeArray)
++     free(_nodeArray);
++  _nrNodes = 0;
++}
++
++
++bool cSubMenu::LoadXml(char *fname)
++{
++  TiXmlDocument  xmlDoc = TiXmlDocument(fname);
++  TiXmlElement  *root   = NULL;
++  cSubMenuNode  *node   = NULL;
++
++  bool  ok = true;
++  //Clear previously loaded Menu
++  if (_fname != NULL)
++     free(_fname);
++  _menuTree.Clear();
++  _fname = strdup(fname);
++
++  if ((ok = xmlDoc.LoadFile())) {
++     if ((root = xmlDoc.FirstChildElement("menus")) != NULL) {
++        char *tmp = NULL;
++        if ((tmp = (char*)root->Attribute("suffix")) == NULL)
++           asprintf(&_menuSuffix, " "); // set default menuSuffix // asprintf(&_menuSuffix, " ...");
++        else
++           asprintf(&_menuSuffix, tmp);
++
++        if ((root = root->FirstChildElement()) != NULL) {
++           do {
++              try {
++                 node = new cSubMenuNode(root, 0,  &_menuTree, NULL);
++                 _menuTree.Add(node);
++                 }
++              catch (char *message) {
++                 esyslog("ERROR: while decoding XML Node");
++                 ok = false;
++                 }
++              } while (ok == true && (root = root->NextSiblingElement()) != NULL);
++           addMissingPlugins();
++           removeUndefinedNodes();
++           }
++        }
++     else {
++        esyslog("ERROR: in %s, missing Tag <menus>\n", fname);
++        ok = false;
++        }
++     }
++  else {
++     esyslog("ERROR: in %s : %s  Col=%d Row=%d\n",
++            fname,
++            xmlDoc.ErrorDesc(),
++            xmlDoc.ErrorCol(),
++            xmlDoc.ErrorRow());
++     ok = false;
++     }
++
++  return(ok);
++}
++
++
++bool cSubMenu::SaveXml()
++{
++  return(SaveXml(_fname));
++}
++
++
++bool cSubMenu::SaveXml(char *fname)
++{
++  bool ok = true;
++
++  if (_fname != NULL) {
++     TiXmlDocument xml = TiXmlDocument(fname);
++     TiXmlComment  comment;
++     comment.SetValue("\n\
++-    VDR Menu-Configuration File\n\
++-\n\
++-\n\
++-   Example:\n\
++-\n\
++ <menus>\n\
++    <system name=\"Schedule\" />\n\
++    <system name=\"Channels\" />\n\
++    <system name=\"Timers\" />\n\
++    <system name=\"Recordings\" />\n\
++    <menu name=\"System\">\n\
++        <system name=\"Setup\" />\n\
++        <system name=\"Commands\" />\n\
++        <plugin name=\"setup\" title=\"My Setup\" />\n\
++        <command name=\"myCommand1\" execute=\"/usr/bin/mycommand1\" />\n\
++        <command name=\"myCommand2\" execute=\"/usr/bin/mycommand2\" confirm=\"yes\" />\n\
++        <thread name=\"myCommand3\" execute=\"/usr/bin/mycommand3\" confirm=\"yes\" />\n\
++        <plugin name=\"epgsearch\" title=\"myProgram\" />\n\
++        <menu name=\"mySubSubMenu\">\n\
++            ...\n\
++        </menu>\n\
++    </menu>\n\
++     <menu name=\"Suche\">\n\
++        <plugin name=\"epgsearch\" />\n\
++        ...\n\
++    </menu>\n\
++ </menus>\n\
++");
++
++     TiXmlElement root("menus");
++     root.SetAttribute("suffix", _menuSuffix);
++     for (cSubMenuNode *node = _menuTree.First(); node; node = _menuTree.Next(node))
++         node->SaveXml(&root);
++
++         if (xml.InsertEndChild(comment) != NULL && xml.InsertEndChild(root) != NULL)
++            ok = xml.SaveFile(fname);
++     }
++  else
++     ok = false;
++
++  return(ok);
++}
++
++
++
++cSubMenuNodes * cSubMenu::GetMenuTree()
++{
++  return(_currentMenuTree);
++}
++
++
++void cSubMenu::PrintMenuTree()
++{
++  for (cSubMenuNode *node = _menuTree.First(); node; node = _menuTree.Next(node))
++      node->Print();
++}
++
++
++int cSubMenu::GetNrOfNodes()
++{
++  if (_nrNodes == 0) {
++     if ((_nrNodes = countNodes(&_menuTree)) > 0) {
++        _nodeArray = (cSubMenuNode**) malloc(sizeof(cSubMenuNode*)*_nrNodes);
++        int index = 0;
++        tree2Array(&_menuTree, index);
++        }
++     }
++
++  return(_nrNodes);
++}
++
++
++/**
++ * returns the specified node within the current menu
++ * @param index position in the current menu
++ * @return node or null if not found
++ */
++cSubMenuNode * cSubMenu::GetNode(int index)
++{
++  cSubMenuNode *node = NULL;
++  if (_currentMenuTree == NULL || (node=_currentMenuTree->Get(index)) == NULL)
++     esyslog("ERROR: illegal call of cSubMenu::GetNode(%d)", index);
++
++  return(node);
++}
++
++
++/**
++ * Get the specified Node
++ * @param index specfies the absolut indes in the list of all nodes
++ * @return node or NULL if not found
++ */
++cSubMenuNode * cSubMenu::GetAbsNode(int index)
++{
++  cSubMenuNode *node = NULL;
++  GetNrOfNodes();
++  if (_nrNodes > 0 && index >= 0 && index < _nrNodes)
++     node = _nodeArray[index];
++
++  return(node);
++}
++
++
++bool cSubMenu::Down(int index)
++{
++  bool ok = true;
++  cSubMenuNode *node = NULL;
++
++  if (_currentMenuTree != NULL && (node=_currentMenuTree->Get(index)) != NULL && node->GetType() == cSubMenuNode::MENU) {
++     _currentParentMenuTree = _currentMenuTree;
++     _currentMenuTree = node->GetSubMenus();
++     }
++  else {
++     ok = false;
++     esyslog("ERROR: illegal call of cSubMenu::Down(%d)", index);
++     }
++
++  return(ok);
++}
++
++bool cSubMenu::Up(int *parentIndex)
++{
++  bool ok = true;
++
++  if (_currentMenuTree != NULL && parentIndex != NULL) {
++     cSubMenuNode *node = NULL;
++     *parentIndex = 0;
++     if (_currentParentMenuTree != NULL)
++        for (int i = 0; (node = _currentParentMenuTree->Get(i)) != NULL; i++) {
++            if (_currentMenuTree == node->GetSubMenus()) {
++               *parentIndex = i;
++               break;
++               }
++            }
++
++     _currentMenuTree = _currentParentMenuTree;
++     if (_currentMenuTree != NULL)
++        _currentParentMenuTree = _currentMenuTree->Get(0)->GetParentMenu();
++     else
++        ok = false;
++     }
++  else {
++     ok = false;
++     esyslog("ERROR: illegal call of cSubMenu::Up()");
++     }
++
++  return(ok);
++}
++
++const char * cSubMenu::ExecuteCommand(const char * cmd)
++{
++  free(_commandResult);
++  _commandResult = NULL;
++
++  dsyslog("executing command '%s'", cmd);
++  FILE *p = popen(cmd, "r");
++  if (p) {
++     int l = 0;
++     int c;
++     while ((c = fgetc(p)) != EOF) {
++           if (l % 20 == 0)
++              _commandResult = (char *)realloc(_commandResult, l + 21);
++           _commandResult[l++] = c;
++           }
++     if (_commandResult)
++        _commandResult[l] = 0;
++     pclose(p);
++     }
++  else
++     esyslog("ERROR: can't open pipe for command '%s'", cmd);
++
++  return _commandResult;
++}
++
++/**
++ * Move Menu Entry to new Position
++ * @param index  index of menu entry to move 
++ * @param toIndex index of destination
++ * @param where After ore before the destination index
++ */
++void cSubMenu::MoveMenu(int index, int toIndex, enum Where where)
++{
++  if (index < 0 || index > _nrNodes || // invalid index is ignored
++     toIndex < 0 || toIndex > _nrNodes || index == toIndex)
++     return;
++
++  cSubMenuNode *srcNode  = GetAbsNode(index);
++  cSubMenuNode *destNode = GetAbsNode(toIndex);
++
++  if (where == cSubMenu::INTO && destNode->GetType() != cSubMenuNode::MENU)
++     return;
++
++  if (where == cSubMenu::INTO) {
++     if (destNode->GetType() == cSubMenuNode::MENU) {
++        srcNode->GetCurrentMenu()->Del(srcNode, false);
++        srcNode->SetLevel(destNode->GetLevel()+1);
++        srcNode->SetParentMenu(destNode->GetCurrentMenu());
++        srcNode->SetCurrentMenu(destNode->GetSubMenus());
++
++        destNode->GetSubMenus()->Add(srcNode);
++        reloadNodeArray();
++        }
++     }
++  else {
++     srcNode->GetCurrentMenu()->Del(srcNode, false);
++     srcNode->SetLevel(destNode->GetLevel());
++     srcNode->SetParentMenu(destNode->GetParentMenu());
++     srcNode->SetCurrentMenu(destNode->GetCurrentMenu());
++
++     if (where == cSubMenu::BEHIND) {
++        destNode->GetCurrentMenu()->Add(srcNode, GetAbsNode(toIndex));
++        reloadNodeArray();
++        }
++     else {
++        destNode->GetCurrentMenu()->Ins(srcNode, GetAbsNode(toIndex));
++        reloadNodeArray();
++        }
++     }
++}
++
++/**
++ * Create a new Menu Entry
++ * @param index index of destination
++ * @param menuTitle  Titel of new Menu entry
++ */
++void cSubMenu::CreateMenu(int index, const char * menuTitle)
++{
++  if (index >= 0 && index < _nrNodes) {
++     cSubMenuNode *srcNode  = GetAbsNode(index);
++     if (srcNode != NULL) {
++        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
++        newNode->SetLevel(srcNode->GetLevel());
++        newNode->SetName(menuTitle);
++        newNode->SetType(cSubMenuNode::MENU);
++        newNode->SetParentMenu(srcNode->GetParentMenu());
++        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
++
++        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
++        reloadNodeArray();
++        }
++     }
++}
++
++/**
++ * delete the specified entry, or subtree if the specified entry is a menu
++ * @param index destion index 
++ */
++void cSubMenu::DeleteMenu(int index)
++{
++  if (index >= 0 && index < _nrNodes) {
++     cSubMenuNode *srcNode = GetAbsNode(index);
++     srcNode->GetCurrentMenu()->Del(srcNode, true);
++     reloadNodeArray();
++     }
++}
++
++
++// Private Methods
++
++int cSubMenu::countNodes(cSubMenuNodes * tree)
++{
++  int count = 0;
++  if (tree != NULL) {
++     for (cSubMenuNode *node = tree->First(); node; node = tree->Next(node)) {
++         count++;
++         if (node->HasSubMenus())
++            count += countNodes(node->GetSubMenus());
++         }
++     }
++  return(count);
++}
++
++
++void cSubMenu::tree2Array(cSubMenuNodes * tree, int &index)
++{
++  if (tree != NULL) {
++     for (cSubMenuNode *node = tree->First(); node; node = tree->Next(node)) {
++         _nodeArray[index++]=node;
++         if (node->HasSubMenus())
++            tree2Array(node->GetSubMenus(), index);
++         }
++     }
++
++}
++
++bool cSubMenu::IsPluginInMenu(const char * name)
++{
++  bool found = false;
++  for (int i = 0; i < _nrNodes && found == false; i++) {
++      cSubMenuNode *node = GetAbsNode(i);
++      if (node != NULL && node->GetType() == cSubMenuNode::PLUGIN && strcmp(name, node->GetName()) == 0)
++         found = true;
++      }
++  return(found);
++}
++
++/**
++ * Adds the given plugin to the Menu-Tree if not allready in List
++ * @param name specifies the name of the plugin
++ */
++void cSubMenu::AddPlugin(const char * name)
++{
++  if (! IsPluginInMenu(name)) {
++     cSubMenuNode *node = new  cSubMenuNode(&_menuTree, NULL);
++     node->SetName(name);
++     node->SetType("plugin");
++     node->SetPlugin();
++     _menuTree.Add(node);
++     }
++}
++
++void cSubMenu::addMissingPlugins()
++{
++  _nrNodes = GetNrOfNodes();
++  for (int i = 0; ; i++) {
++      cPlugin *p = cPluginManager::GetPlugin(i);
++      if (p)
++         AddPlugin(p->Name());
++      else
++         break;
++      }
++  reloadNodeArray();
++}
++
++/**
++ * Adds the given command to the Menu-Tree
++ * @param name specifies the name of the command
++ */
++void cSubMenu::CreateCommand(int index, const char * name, const char * execute, int confirm)
++{
++  if (index >= 0 && index < _nrNodes) {
++     cSubMenuNode *srcNode  = GetAbsNode(index);
++     if (srcNode != NULL) {
++        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
++        newNode->SetLevel(srcNode->GetLevel());
++        newNode->SetName(name);
++        newNode->SetType("command");
++        newNode->SetCommand(execute);
++        newNode->SetCommandConfirm(confirm);
++        newNode->SetParentMenu(srcNode->GetParentMenu());
++        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
++
++        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
++        reloadNodeArray();
++        }
++     }
++}
++
++void cSubMenu::CreateThread(int index, const char * name, const char * execute, int confirm)
++{
++  if (index >= 0 && index < _nrNodes) {
++     cSubMenuNode *srcNode  = GetAbsNode(index);
++     if (srcNode != NULL) {
++        cSubMenuNode *newNode = new cSubMenuNode(srcNode->GetParentMenu(), srcNode->GetCurrentMenu());
++        newNode->SetLevel(srcNode->GetLevel());
++        newNode->SetName(name);
++        newNode->SetType("thread");
++        newNode->SetCommand(execute);
++        newNode->SetCommandConfirm(confirm);
++        newNode->SetParentMenu(srcNode->GetParentMenu());
++        newNode->SetCurrentMenu(srcNode->GetCurrentMenu());
++
++        srcNode->GetCurrentMenu()->Add(newNode, GetAbsNode(index));
++        reloadNodeArray();
++        }
++     }
++}
++
++/**
++ * reloads the internal Array of Nodes
++ */
++void cSubMenu::reloadNodeArray()
++{
++  if (_nrNodes > 0)
++     free(_nodeArray);
++  _nodeArray = NULL;
++  _nrNodes = 0;
++  _nrNodes = GetNrOfNodes();
++}
++
++/**
++ * remove Undefined Nodes
++ */
++void cSubMenu::removeUndefinedNodes()
++{
++  bool remove = false;
++
++  reloadNodeArray();
++  for (int i = 0; i < _nrNodes; i++) {
++      cSubMenuNode *node = GetAbsNode(i);
++      if (node != NULL && node->GetType() == cSubMenuNode::UNDEFINED) {
++         cSubMenuNodes *pMenu = node->GetCurrentMenu();
++         pMenu->Del(node, true);
++         remove = true;
++         }
++      }
++  if (remove)
++     reloadNodeArray();
++}
++
++
++/**
++* Retrieves the Menutitel of the parent Menu
++*/
++const char *cSubMenu::GetParentMenuTitel()
++{
++  const char * result = "";
++
++  if (_currentMenuTree != NULL && _currentParentMenuTree != NULL) {
++     cSubMenuNode *node = NULL;
++     for (int i = 0; (node = _currentParentMenuTree->Get(i)) != NULL; i++) {
++         if (_currentMenuTree == node->GetSubMenus()) {
++            result = node->GetName();
++            break;
++            }
++         }
++     }
++
++  return(result);
++}
++
++#endif
++#endif /* SETUP */
+diff -ruNp vdr-1.6.0-2/submenu.h vdr-1.6.0-2-setup-zulu-edition/submenu.h
+--- vdr-1.6.0-2/submenu.h	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0-2-setup-zulu-edition/submenu.h	2009-01-19 09:43:52.000000000 +0100
+@@ -0,0 +1,154 @@
++#ifdef USE_SETUP
++/****************************************************************************
++ * DESCRIPTION:
++ *             Submenu
++ *
++ * $Id: vdr-1.3.44-Setup-0.3.0.diff,v 1.1 2006/03/04 09:58:47 ralf Exp $
++ *
++ * Contact:    ranga@teddycats.de
++ *
++ * Copyright (C) 2004, 2005 by Ralf Dotzert
++ *
++ * modified for the VDR Extensions Patch by zulu @vdr-portal
++ *
++ ****************************************************************************/
++
++#ifndef SUBMENU_H
++#define SUBMENU_H
++
++#include "thread.h"
++#include "tools.h"
++#include "tinystr.h"
++
++class cSubMenuNode;
++class cSubMenuNodes;
++class cSubMenu;
++
++
++class cSubMenuNodes : public cList<cSubMenuNode> {};
++
++// execute cmd thread
++class cExecCmdThread : public cThread {
++private:
++  char *ExecCmd;
++protected:
++  virtual void Action(void) {
++     if (system(ExecCmd) == 0)
++        esyslog("%s - finished", ExecCmd);
++     delete(this);
++     };
++public:
++  cExecCmdThread(char *cmd) {
++     asprintf(&ExecCmd, "%s", cmd);
++     }
++  cExecCmdThread(const char *cmd) {
++     asprintf(&ExecCmd, "%s", cmd);
++     }
++  ~cExecCmdThread() {
++     free(ExecCmd);
++     };
++  };
++
++//################################################################################
++//# SubMenuNode
++//################################################################################
++class cSubMenuNode : public cListObject {
++public:
++  enum Type { UNDEFINED, SYSTEM, COMMAND, THREAD, PLUGIN, MENU };
++  cSubMenuNode(TiXmlElement * xml, int level, cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu);
++  cSubMenuNode(cSubMenuNodes *currentMenu, cSubMenuNodes *parentMenu);
++  ~cSubMenuNode();
++  bool SaveXml(TiXmlElement * root);
++  static cSubMenuNode::Type IsType(const char *name);
++  void  SetType(const char *name);
++  void  SetType(enum Type type);
++  void  SetPlugin();
++  cSubMenuNode::Type GetType();
++  const char *GetTypeAsString();
++  void SetCommand(const char *command);
++  bool CommandConfirm();
++  void SetCommandConfirm(int val);
++  const char *GetCommand();
++  void SetCustomTitle(const char *title);
++  const char *GetCustomTitle();
++  void SetName(const char *name);
++  const char*GetName();
++  int  GetLevel();
++  void SetLevel(int level);
++  int  GetPluginIndex();
++  void SetPluginIndex(int index);
++  void SetPluginMainMenuEntry(const char *mainMenuEntry);
++  const char *GetPluginMainMenuEntry();
++  cSubMenuNodes *GetParentMenu();
++  void SetParentMenu(cSubMenuNodes *parent);
++  cSubMenuNodes *GetCurrentMenu();
++  void SetCurrentMenu(cSubMenuNodes *current);
++  cSubMenuNodes *GetSubMenus();
++  bool HasSubMenus();
++  void Print(int index = 0);
++private:
++  Type _type;
++  int _level;
++  // Plugin Variables
++  int _pluginIndex;
++  const char *_pluginMainMenuEntry;
++  // common
++  const char *_name;
++  const char *_command;
++  bool _commandConfirm;
++  const char *_title;
++  cSubMenuNodes _subMenus;
++  cSubMenuNodes *_parentMenu;
++  cSubMenuNodes *_currentMenu;
++  void init();
++  };
++
++
++//################################################################################
++//# SubMenu Class
++//################################################################################
++class cSubMenu {
++public:
++  cSubMenu();
++  ~cSubMenu();
++  enum Where { BEFORE, BEHIND, INTO};
++  bool LoadXml(char *fname);
++  bool SaveXml(char *fname);
++  bool SaveXml();
++  cSubMenuNodes *GetMenuTree();
++  bool Up(int *ParentIndex);
++  bool Down(int index);
++  int  GetNrOfNodes();
++  cSubMenuNode* GetAbsNode(int index);
++  cSubMenuNode* GetNode(int index);
++  void PrintMenuTree();
++  bool IsPluginInMenu(const char *name);
++  void AddPlugin(const char *name);
++  void CreateCommand(int index, const char *name, const char *execute, int confirm);
++  void CreateThread(int index, const char *name, const char *execute, int confirm);
++  const char *ExecuteCommand(const char *command);
++  void MoveMenu(int index, int toindex, enum Where);
++  void CreateMenu(int index, const char *menuTitle);
++  void DeleteMenu(int index);
++  char *GetMenuSuffix() { return _menuSuffix; }
++  void SetMenuSuffix(char *suffix) { if (_menuSuffix) free(_menuSuffix); asprintf(&_menuSuffix, suffix); }
++  bool isTopMenu() { return (_currentParentMenuTree == NULL); }
++  const char *GetParentMenuTitel();
++private:
++  cSubMenuNodes _menuTree;
++  cSubMenuNodes *_currentMenuTree;
++  cSubMenuNodes *_currentParentMenuTree;
++  char *_fname;
++  char *_commandResult;
++  int _nrNodes;
++  cSubMenuNode **_nodeArray;
++  char *_menuSuffix;
++  int countNodes(cSubMenuNodes *tree);
++  void tree2Array(cSubMenuNodes *tree, int &index);
++  void addMissingPlugins();
++  void reloadNodeArray();
++  void removeUndefinedNodes();
++  };
++
++#endif //__SUBMENU_H
++#endif /* SETUP */
+diff -ruNp vdr-1.6.0-2/tinystr.c vdr-1.6.0-2-setup-zulu-edition/tinystr.c
+--- vdr-1.6.0-2/tinystr.c	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0-2-setup-zulu-edition/tinystr.c	2009-01-19 09:43:52.000000000 +0100
+@@ -0,0 +1,301 @@
++#ifdef USE_SETUP
++/*
++www.sourceforge.net/projects/tinyxml
++Original file by Yves Berquin.
++
++This software is provided 'as-is', without any express or implied 
++warranty. In no event will the authors be held liable for any 
++damages arising from the use of this software.
++
++Permission is granted to anyone to use this software for any 
++purpose, including commercial applications, and to alter it and 
++redistribute it freely, subject to the following restrictions:
++
++1. The origin of this software must not be misrepresented; you must 
++not claim that you wrote the original software. If you use this 
++software in a product, an acknowledgment in the product documentation 
++would be appreciated but is not required.
++
++2. Altered source versions must be plainly marked as such, and
++must not be misrepresented as being the original software.
++
++3. This notice may not be removed or altered from any source 
++distribution.
++*/
++
++#include "tinyxml.h"
++
++#ifndef TIXML_USE_STL
++
++
++#include <stdlib.h>
++#include <string.h>
++#include <ctype.h>
++
++#include "tinystr.h"
++
++// TiXmlString constructor, based on a C string
++TiXmlString::TiXmlString (const char* instring)
++{
++    unsigned newlen;
++    char * newstring;
++
++    if (!instring)
++    {
++        allocated = 0;
++        cstring = NULL;
++        current_length = 0;
++        return;
++    }
++    newlen = strlen (instring) + 1;
++    newstring = new char [newlen];
++    memcpy (newstring, instring, newlen);
++    // strcpy (newstring, instring);
++    allocated = newlen;
++    cstring = newstring;
++    current_length = newlen - 1;
++}
++
++// TiXmlString copy constructor
++TiXmlString::TiXmlString (const TiXmlString& copy)
++{
++    unsigned newlen;
++    char * newstring;
++
++	// Prevent copy to self!
++	if ( &copy == this )
++		return;
++
++    if (! copy . allocated)
++    {
++        allocated = 0;
++        cstring = NULL;
++        current_length = 0;
++        return;
++    }
++    newlen = copy . length () + 1;
++    newstring = new char [newlen];
++    // strcpy (newstring, copy . cstring);
++    memcpy (newstring, copy . cstring, newlen);
++    allocated = newlen;
++    cstring = newstring;
++    current_length = newlen - 1;
++}
++
++// TiXmlString = operator. Safe when assign own content
++void TiXmlString ::operator = (const char * content)
++{
++    unsigned newlen;
++    char * newstring;
++
++    if (! content)
++    {
++        empty_it ();
++        return;
++    }
++    newlen = strlen (content) + 1;
++    newstring = new char [newlen];
++    // strcpy (newstring, content);
++    memcpy (newstring, content, newlen);
++    empty_it ();
++    allocated = newlen;
++    cstring = newstring;
++    current_length = newlen - 1;
++}
++
++// = operator. Safe when assign own content
++void TiXmlString ::operator = (const TiXmlString & copy)
++{
++    unsigned newlen;
++    char * newstring;
++
++    if (! copy . length ())
++    {
++        empty_it ();
++        return;
++    }
++    newlen = copy . length () + 1;
++    newstring = new char [newlen];
++    // strcpy (newstring, copy . c_str ());
++    memcpy (newstring, copy . c_str (), newlen);
++    empty_it ();
++    allocated = newlen;
++    cstring = newstring;
++    current_length = newlen - 1;
++}
++
++
++// append a const char * to an existing TiXmlString
++void TiXmlString::append( const char* str, int len )
++{
++    char * new_string;
++    unsigned new_alloc, new_size, size_suffix;
++	
++	// don't use strlen - it can overrun the len passed in!
++	const char* p = str;
++	size_suffix = 0;
++
++	while ( *p && size_suffix < (unsigned)len )
++	{
++		++p;
++		++size_suffix;
++	}
++    if ( !size_suffix)
++        return;
++
++    new_size = length () + size_suffix + 1;
++    // check if we need to expand
++    if (new_size > allocated)
++    {
++        // compute new size
++        new_alloc = assign_new_size (new_size);
++
++        // allocate new buffer
++        new_string = new char [new_alloc];        
++        new_string [0] = 0;
++
++        // copy the previous allocated buffer into this one
++        if (allocated && cstring)
++            // strcpy (new_string, cstring);
++            memcpy (new_string, cstring, length ());
++
++        // append the suffix. It does exist, otherwize we wouldn't be expanding 
++        // strncat (new_string, str, len);
++        memcpy (new_string + length (), 
++                str,
++                size_suffix);
++
++        // return previsously allocated buffer if any
++        if (allocated && cstring)
++            delete [] cstring;
++
++        // update member variables
++        cstring = new_string;
++        allocated = new_alloc;
++    }
++    else
++    {
++        // we know we can safely append the new string
++        // strncat (cstring, str, len);
++        memcpy (cstring + length (), 
++                str,
++                size_suffix);
++    }
++    current_length = new_size - 1;
++    cstring [current_length] = 0;
++}
++
++
++// append a const char * to an existing TiXmlString
++void TiXmlString::append( const char * suffix )
++{
++    char * new_string;
++    unsigned new_alloc, new_size;
++
++    new_size = length () + strlen (suffix) + 1;
++    // check if we need to expand
++    if (new_size > allocated)
++    {
++        // compute new size
++        new_alloc = assign_new_size (new_size);
++
++        // allocate new buffer
++        new_string = new char [new_alloc];        
++        new_string [0] = 0;
++
++        // copy the previous allocated buffer into this one
++        if (allocated && cstring)
++            memcpy (new_string, cstring, 1 + length ());
++            // strcpy (new_string, cstring);
++
++        // append the suffix. It does exist, otherwize we wouldn't be expanding 
++        // strcat (new_string, suffix);
++        memcpy (new_string + length (), 
++                suffix,
++                strlen (suffix) + 1);
++
++        // return previsously allocated buffer if any
++        if (allocated && cstring)
++            delete [] cstring;
++
++        // update member variables
++        cstring = new_string;
++        allocated = new_alloc;
++    }
++    else
++    {
++        // we know we can safely append the new string
++        // strcat (cstring, suffix);
++        memcpy (cstring + length (), 
++                suffix, 
++                strlen (suffix) + 1);
++    }
++    current_length = new_size - 1;
++}
++
++// Check for TiXmlString equuivalence
++//bool TiXmlString::operator == (const TiXmlString & compare) const
++//{
++//    return (! strcmp (c_str (), compare . c_str ()));
++//}
++
++//unsigned TiXmlString::length () const
++//{
++//    if (allocated)
++//        // return strlen (cstring);
++//        return current_length;
++//    return 0;
++//}
++
++
++unsigned TiXmlString::find (char tofind, unsigned offset) const
++{
++    char * lookup;
++
++    if (offset >= length ())
++        return (unsigned) notfound;
++    for (lookup = cstring + offset; * lookup; lookup++)
++        if (* lookup == tofind)
++            return lookup - cstring;
++    return (unsigned) notfound;
++}
++
++
++bool TiXmlString::operator == (const TiXmlString & compare) const
++{
++	if ( allocated && compare.allocated )
++	{
++		assert( cstring );
++		assert( compare.cstring );
++		return ( strcmp( cstring, compare.cstring ) == 0 );
++ 	}
++	return false;
++}
++
++
++bool TiXmlString::operator < (const TiXmlString & compare) const
++{
++	if ( allocated && compare.allocated )
++	{
++		assert( cstring );
++		assert( compare.cstring );
++		return ( strcmp( cstring, compare.cstring ) > 0 );
++ 	}
++	return false;
++}
++
++
++bool TiXmlString::operator > (const TiXmlString & compare) const
++{
++	if ( allocated && compare.allocated )
++	{
++		assert( cstring );
++		assert( compare.cstring );
++		return ( strcmp( cstring, compare.cstring ) < 0 );
++ 	}
++	return false;
++}
++
++
++#endif	// TIXML_USE_STL
++#endif /* SETUP */
+diff -ruNp vdr-1.6.0-2/tinystr.h vdr-1.6.0-2-setup-zulu-edition/tinystr.h
+--- vdr-1.6.0-2/tinystr.h	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0-2-setup-zulu-edition/tinystr.h	2009-01-19 09:43:52.000000000 +0100
+@@ -0,0 +1,244 @@
++#ifdef USE_SETUP
++/*
++www.sourceforge.net/projects/tinyxml
++Original file by Yves Berquin.
++
++This software is provided 'as-is', without any express or implied 
++warranty. In no event will the authors be held liable for any 
++damages arising from the use of this software.
++
++Permission is granted to anyone to use this software for any 
++purpose, including commercial applications, and to alter it and 
++redistribute it freely, subject to the following restrictions:
++
++1. The origin of this software must not be misrepresented; you must 
++not claim that you wrote the original software. If you use this 
++software in a product, an acknowledgment in the product documentation 
++would be appreciated but is not required.
++
++2. Altered source versions must be plainly marked as such, and
++must not be misrepresented as being the original software.
++
++3. This notice may not be removed or altered from any source 
++distribution.
++*/
++
++#include "tinyxml.h"
++
++
++#ifndef TIXML_USE_STL
++
++#ifndef TIXML_STRING_INCLUDED
++#define TIXML_STRING_INCLUDED
++
++#ifdef _MSC_VER
++#pragma warning( disable : 4786 )	// Debugger truncating names.
++#endif
++
++#include <assert.h>
++
++/*
++   TiXmlString is an emulation of the std::string template.
++   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.
++   Only the member functions relevant to the TinyXML project have been implemented.
++   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase
++   a string and there's no more room, we allocate a buffer twice as big as we need.
++*/
++class TiXmlString
++{
++  public :
++    // TiXmlString constructor, based on a string
++    TiXmlString (const char * instring);
++
++    // TiXmlString empty constructor
++    TiXmlString ()
++    {
++        allocated = 0;
++        cstring = NULL;
++        current_length = 0;
++    }
++
++    // TiXmlString copy constructor
++    TiXmlString (const TiXmlString& copy);
++
++    // TiXmlString destructor
++    ~ TiXmlString ()
++    {
++        empty_it ();
++    }
++
++    // Convert a TiXmlString into a classical char *
++    const char * c_str () const
++    {
++        if (allocated)
++            return cstring;
++        return "";
++    }
++
++    // Return the length of a TiXmlString
++    unsigned length () const
++	{
++		return ( allocated ) ? current_length : 0;
++	}
++
++    // TiXmlString = operator
++    void operator = (const char * content);
++
++    // = operator
++    void operator = (const TiXmlString & copy);
++
++    // += operator. Maps to append
++    TiXmlString& operator += (const char * suffix)
++    {
++        append (suffix);
++		return *this;
++    }
++
++    // += operator. Maps to append
++    TiXmlString& operator += (char single)
++    {
++        append (single);
++		return *this;
++    }
++
++    // += operator. Maps to append
++    TiXmlString& operator += (TiXmlString & suffix)
++    {
++        append (suffix);
++		return *this;
++    }
++    bool operator == (const TiXmlString & compare) const;
++    bool operator < (const TiXmlString & compare) const;
++    bool operator > (const TiXmlString & compare) const;
++
++    // Checks if a TiXmlString is empty
++    bool empty () const
++    {
++        return length () ? false : true;
++    }
++
++    // single char extraction
++    const char& at (unsigned index) const
++    {
++        assert( index < length ());
++        return cstring [index];
++    }
++
++    // find a char in a string. Return TiXmlString::notfound if not found
++    unsigned find (char lookup) const
++    {
++        return find (lookup, 0);
++    }
++
++    // find a char in a string from an offset. Return TiXmlString::notfound if not found
++    unsigned find (char tofind, unsigned offset) const;
++
++    /*	Function to reserve a big amount of data when we know we'll need it. Be aware that this
++		function clears the content of the TiXmlString if any exists.
++    */
++    void reserve (unsigned size)
++    {
++        empty_it ();
++        if (size)
++        {
++            allocated = size;
++            cstring = new char [size];
++            cstring [0] = 0;
++            current_length = 0;
++        }
++    }
++
++    // [] operator 
++    char& operator [] (unsigned index) const
++    {
++        assert( index < length ());
++        return cstring [index];
++    }
++
++    // Error value for find primitive 
++    enum {	notfound = 0xffffffff,
++            npos = notfound };
++
++    void append (const char *str, int len );
++
++  protected :
++
++    // The base string
++    char * cstring;
++    // Number of chars allocated
++    unsigned allocated;
++    // Current string size
++    unsigned current_length;
++
++    // New size computation. It is simplistic right now : it returns twice the amount
++    // we need
++    unsigned assign_new_size (unsigned minimum_to_allocate)
++    {
++        return minimum_to_allocate * 2;
++    }
++
++    // Internal function that clears the content of a TiXmlString
++    void empty_it ()
++    {
++        if (cstring)
++            delete [] cstring;
++        cstring = NULL;
++        allocated = 0;
++        current_length = 0;
++    }
++
++    void append (const char *suffix );
++
++    // append function for another TiXmlString
++    void append (const TiXmlString & suffix)
++    {
++        append (suffix . c_str ());
++    }
++
++    // append for a single char.
++    void append (char single)
++    {
++        if ( cstring && current_length < (allocated-1) )
++		{
++			cstring[ current_length ] = single;
++			++current_length;
++			cstring[ current_length ] = 0;
++		}
++		else
++		{
++			char smallstr [2];
++			smallstr [0] = single;
++			smallstr [1] = 0;
++			append (smallstr);
++		}
++    }
++
++} ;
++
++/* 
++   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.
++   Only the operators that we need for TinyXML have been developped.
++*/
++class TiXmlOutStream : public TiXmlString
++{
++public :
++    TiXmlOutStream () : TiXmlString () {}
++
++    // TiXmlOutStream << operator. Maps to TiXmlString::append
++    TiXmlOutStream & operator << (const char * in)
++    {
++        append (in);
++        return (* this);
++    }
++
++    // TiXmlOutStream << operator. Maps to TiXmlString::append
++    TiXmlOutStream & operator << (const TiXmlString & in)
++    {
++        append (in . c_str ());
++        return (* this);
++    }
++} ;
++
++#endif	// TIXML_STRING_INCLUDED
++#endif	// TIXML_USE_STL
++#endif /* SETUP */
+diff -ruNp vdr-1.6.0-2/tinyxml.c vdr-1.6.0-2-setup-zulu-edition/tinyxml.c
+--- vdr-1.6.0-2/tinyxml.c	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0-2-setup-zulu-edition/tinyxml.c	2009-01-19 09:43:52.000000000 +0100
+@@ -0,0 +1,1429 @@
++#ifdef USE_SETUP
++/*
++www.sourceforge.net/projects/tinyxml
++Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
++
++This software is provided 'as-is', without any express or implied
++warranty. In no event will the authors be held liable for any
++damages arising from the use of this software.
++
++Permission is granted to anyone to use this software for any
++purpose, including commercial applications, and to alter it and
++redistribute it freely, subject to the following restrictions:
++
++1. The origin of this software must not be misrepresented; you must
++not claim that you wrote the original software. If you use this
++software in a product, an acknowledgment in the product documentation
++would be appreciated but is not required.
++
++2. Altered source versions must be plainly marked as such, and
++must not be misrepresented as being the original software.
++
++3. This notice may not be removed or altered from any source
++distribution.
++*/
++
++#include <ctype.h>
++#include "tinyxml.h"
++
++#ifdef TIXML_USE_STL
++#include <sstream>
++#endif
++
++
++bool TiXmlBase::condenseWhiteSpace = true;
++
++void TiXmlBase::PutString( const TIXML_STRING& str, TIXML_OSTREAM* stream )
++{
++	TIXML_STRING buffer;
++	PutString( str, &buffer );
++	(*stream) << buffer;
++}
++
++void TiXmlBase::PutString( const TIXML_STRING& str, TIXML_STRING* outString )
++{
++	int i=0;
++
++	while( i<(int)str.length() )
++	{
++		unsigned char c = (unsigned char) str[i];
++
++		if (    c == '&' 
++		     && i < ( (int)str.length() - 2 )
++			 && str[i+1] == '#'
++			 && str[i+2] == 'x' )
++		{
++			// Hexadecimal character reference.
++			// Pass through unchanged.
++			// &#xA9;	-- copyright symbol, for example.
++			//
++			// The -1 is a bug fix from Rob Laveaux. It keeps
++			// an overflow from happening if there is no ';'.
++			// There are actually 2 ways to exit this loop -
++			// while fails (error case) and break (semicolon found).
++			// However, there is no mechanism (currently) for
++			// this function to return an error.
++			while ( i<(int)str.length()-1 )
++			{
++				outString->append( str.c_str() + i, 1 );
++				++i;
++				if ( str[i] == ';' )
++					break;
++			}
++		}
++		else if ( c == '&' )
++		{
++			outString->append( entity[0].str, entity[0].strLength );
++			++i;
++		}
++		else if ( c == '<' )
++		{
++			outString->append( entity[1].str, entity[1].strLength );
++			++i;
++		}
++		else if ( c == '>' )
++		{
++			outString->append( entity[2].str, entity[2].strLength );
++			++i;
++		}
++		else if ( c == '\"' )
++		{
++			outString->append( entity[3].str, entity[3].strLength );
++			++i;
++		}
++		else if ( c == '\'' )
++		{
++			outString->append( entity[4].str, entity[4].strLength );
++			++i;
++		}
++		else if ( c < 32 )
++		{
++			// Easy pass at non-alpha/numeric/symbol
++			// Below 32 is symbolic.
++			char buf[ 32 ];
++			sprintf( buf, "&#x%02X;", (unsigned) ( c & 0xff ) );
++			outString->append( buf, strlen( buf ) );
++			++i;
++		}
++		else
++		{
++			//char realc = (char) c;
++			//outString->append( &realc, 1 );
++			*outString += (char) c;	// somewhat more efficient function call.
++			++i;
++		}
++	}
++}
++
++
++// <-- Strange class for a bug fix. Search for STL_STRING_BUG
++TiXmlBase::StringToBuffer::StringToBuffer( const TIXML_STRING& str )
++{
++	buffer = new char[ str.length()+1 ];
++	if ( buffer )
++	{
++		strcpy( buffer, str.c_str() );
++	}
++}
++
++
++TiXmlBase::StringToBuffer::~StringToBuffer()
++{
++	delete [] buffer;
++}
++// End strange bug fix. -->
++
++
++TiXmlNode::TiXmlNode( NodeType _type ) : TiXmlBase()
++{
++	parent = 0;
++	type = _type;
++	firstChild = 0;
++	lastChild = 0;
++	prev = 0;
++	next = 0;
++}
++
++
++TiXmlNode::~TiXmlNode()
++{
++	TiXmlNode* node = firstChild;
++	TiXmlNode* temp = 0;
++
++	while ( node )
++	{
++		temp = node;
++		node = node->next;
++		delete temp;
++	}	
++}
++
++
++void TiXmlNode::CopyTo( TiXmlNode* target ) const
++{
++	target->SetValue (value.c_str() );
++	target->userData = userData; 
++}
++
++
++void TiXmlNode::Clear()
++{
++	TiXmlNode* node = firstChild;
++	TiXmlNode* temp = 0;
++
++	while ( node )
++	{
++		temp = node;
++		node = node->next;
++		delete temp;
++	}	
++
++	firstChild = 0;
++	lastChild = 0;
++}
++
++
++TiXmlNode* TiXmlNode::LinkEndChild( TiXmlNode* node )
++{
++	node->parent = this;
++
++	node->prev = lastChild;
++	node->next = 0;
++
++	if ( lastChild )
++		lastChild->next = node;
++	else
++		firstChild = node;			// it was an empty list.
++
++	lastChild = node;
++	return node;
++}
++
++
++TiXmlNode* TiXmlNode::InsertEndChild( const TiXmlNode& addThis )
++{
++	TiXmlNode* node = addThis.Clone();
++	if ( !node )
++		return 0;
++
++	return LinkEndChild( node );
++}
++
++
++TiXmlNode* TiXmlNode::InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis )
++{	
++	if ( !beforeThis || beforeThis->parent != this )
++		return 0;
++
++	TiXmlNode* node = addThis.Clone();
++	if ( !node )
++		return 0;
++	node->parent = this;
++
++	node->next = beforeThis;
++	node->prev = beforeThis->prev;
++	if ( beforeThis->prev )
++	{
++		beforeThis->prev->next = node;
++	}
++	else
++	{
++		assert( firstChild == beforeThis );
++		firstChild = node;
++	}
++	beforeThis->prev = node;
++	return node;
++}
++
++
++TiXmlNode* TiXmlNode::InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis )
++{
++	if ( !afterThis || afterThis->parent != this )
++		return 0;
++
++	TiXmlNode* node = addThis.Clone();
++	if ( !node )
++		return 0;
++	node->parent = this;
++
++	node->prev = afterThis;
++	node->next = afterThis->next;
++	if ( afterThis->next )
++	{
++		afterThis->next->prev = node;
++	}
++	else
++	{
++		assert( lastChild == afterThis );
++		lastChild = node;
++	}
++	afterThis->next = node;
++	return node;
++}
++
++
++TiXmlNode* TiXmlNode::ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis )
++{
++	if ( replaceThis->parent != this )
++		return 0;
++
++	TiXmlNode* node = withThis.Clone();
++	if ( !node )
++		return 0;
++
++	node->next = replaceThis->next;
++	node->prev = replaceThis->prev;
++
++	if ( replaceThis->next )
++		replaceThis->next->prev = node;
++	else
++		lastChild = node;
++
++	if ( replaceThis->prev )
++		replaceThis->prev->next = node;
++	else
++		firstChild = node;
++
++	delete replaceThis;
++	node->parent = this;
++	return node;
++}
++
++
++bool TiXmlNode::RemoveChild( TiXmlNode* removeThis )
++{
++	if ( removeThis->parent != this )
++	{	
++		assert( 0 );
++		return false;
++	}
++
++	if ( removeThis->next )
++		removeThis->next->prev = removeThis->prev;
++	else
++		lastChild = removeThis->prev;
++
++	if ( removeThis->prev )
++		removeThis->prev->next = removeThis->next;
++	else
++		firstChild = removeThis->next;
++
++	delete removeThis;
++	return true;
++}
++
++TiXmlNode* TiXmlNode::FirstChild( const char * _value ) const
++{
++	TiXmlNode* node;
++	for ( node = firstChild; node; node = node->next )
++	{
++		if ( node->SValue() == TIXML_STRING( _value ))
++			return node;
++	}
++	return 0;
++}
++
++TiXmlNode* TiXmlNode::LastChild( const char * _value ) const
++{
++	TiXmlNode* node;
++	for ( node = lastChild; node; node = node->prev )
++	{
++		if ( node->SValue() == TIXML_STRING (_value))
++			return node;
++	}
++	return 0;
++}
++
++TiXmlNode* TiXmlNode::IterateChildren( TiXmlNode* previous ) const
++{
++	if ( !previous )
++	{
++		return FirstChild();
++	}
++	else
++	{
++		assert( previous->parent == this );
++		return previous->NextSibling();
++	}
++}
++
++TiXmlNode* TiXmlNode::IterateChildren( const char * val, TiXmlNode* previous ) const
++{
++	if ( !previous )
++	{
++		return FirstChild( val );
++	}
++	else
++	{
++		assert( previous->parent == this );
++		return previous->NextSibling( val );
++	}
++}
++
++TiXmlNode* TiXmlNode::NextSibling( const char * _value ) const
++{
++	TiXmlNode* node;
++	for ( node = next; node; node = node->next )
++	{
++		if ( node->SValue() == TIXML_STRING (_value))
++			return node;
++	}
++	return 0;
++}
++
++
++TiXmlNode* TiXmlNode::PreviousSibling( const char * _value ) const
++{
++	TiXmlNode* node;
++	for ( node = prev; node; node = node->prev )
++	{
++		if ( node->SValue() == TIXML_STRING (_value))
++			return node;
++	}
++	return 0;
++}
++
++void TiXmlElement::RemoveAttribute( const char * name )
++{
++	TiXmlAttribute* node = attributeSet.Find( name );
++	if ( node )
++	{
++		attributeSet.Remove( node );
++		delete node;
++	}
++}
++
++TiXmlElement* TiXmlNode::FirstChildElement() const
++{
++	TiXmlNode* node;
++
++	for (	node = FirstChild();
++			node;
++			node = node->NextSibling() )
++	{
++		if ( node->ToElement() )
++			return node->ToElement();
++	}
++	return 0;
++}
++
++TiXmlElement* TiXmlNode::FirstChildElement( const char * _value ) const
++{
++	TiXmlNode* node;
++
++	for (	node = FirstChild( _value );
++			node;
++			node = node->NextSibling( _value ) )
++	{
++		if ( node->ToElement() )
++			return node->ToElement();
++	}
++	return 0;
++}
++
++
++TiXmlElement* TiXmlNode::NextSiblingElement() const
++{
++	TiXmlNode* node;
++
++	for (	node = NextSibling();
++	node;
++	node = node->NextSibling() )
++	{
++		if ( node->ToElement() )
++			return node->ToElement();
++	}
++	return 0;
++}
++
++TiXmlElement* TiXmlNode::NextSiblingElement( const char * _value ) const
++{
++	TiXmlNode* node;
++
++	for (	node = NextSibling( _value );
++	node;
++	node = node->NextSibling( _value ) )
++	{
++		if ( node->ToElement() )
++			return node->ToElement();
++	}
++	return 0;
++}
++
++
++
++TiXmlDocument* TiXmlNode::GetDocument() const
++{
++	const TiXmlNode* node;
++
++	for( node = this; node; node = node->parent )
++	{
++		if ( node->ToDocument() )
++			return node->ToDocument();
++	}
++	return 0;
++}
++
++
++TiXmlElement::TiXmlElement (const char * _value)
++	: TiXmlNode( TiXmlNode::ELEMENT )
++{
++	firstChild = lastChild = 0;
++	value = _value;
++}
++
++
++#ifdef TIXML_USE_STL
++TiXmlElement::TiXmlElement( const std::string& _value ) 
++	: TiXmlNode( TiXmlNode::ELEMENT )
++{
++	firstChild = lastChild = 0;
++	value = _value;
++}
++#endif
++
++
++TiXmlElement::TiXmlElement( const TiXmlElement& copy)
++	: TiXmlNode( TiXmlNode::ELEMENT )
++{
++	firstChild = lastChild = 0;
++	copy.CopyTo( this );	
++}
++
++
++void TiXmlElement::operator=( const TiXmlElement& base )
++{
++	ClearThis();
++	base.CopyTo( this );
++}
++
++
++TiXmlElement::~TiXmlElement()
++{
++	ClearThis();
++}
++
++
++void TiXmlElement::ClearThis()
++{
++	Clear();
++	while( attributeSet.First() )
++	{
++		TiXmlAttribute* node = attributeSet.First();
++		attributeSet.Remove( node );
++		delete node;
++	}
++}
++
++
++const char * TiXmlElement::Attribute( const char * name ) const
++{
++	TiXmlAttribute* node = attributeSet.Find( name );
++
++	if ( node )
++		return node->Value();
++
++	return 0;
++}
++
++
++const char * TiXmlElement::Attribute( const char * name, int* i ) const
++{
++	const char * s = Attribute( name );
++	if ( i )
++	{
++		if ( s )
++			*i = atoi( s );
++		else
++			*i = 0;
++	}
++	return s;
++}
++
++
++const char * TiXmlElement::Attribute( const char * name, double* d ) const
++{
++	const char * s = Attribute( name );
++	if ( d )
++	{
++		if ( s )
++			*d = atof( s );
++		else
++			*d = 0;
++	}
++	return s;
++}
++
++
++int TiXmlElement::QueryIntAttribute( const char* name, int* ival ) const
++{
++	TiXmlAttribute* node = attributeSet.Find( name );
++	if ( !node )
++		return TIXML_NO_ATTRIBUTE;
++
++	return node->QueryIntValue( ival );
++}
++
++
++int TiXmlElement::QueryDoubleAttribute( const char* name, double* dval ) const
++{
++	TiXmlAttribute* node = attributeSet.Find( name );
++	if ( !node )
++		return TIXML_NO_ATTRIBUTE;
++
++	return node->QueryDoubleValue( dval );
++}
++
++
++void TiXmlElement::SetAttribute( const char * name, int val )
++{	
++	char buf[64];
++	sprintf( buf, "%d", val );
++	SetAttribute( name, buf );
++}
++
++
++void TiXmlElement::SetDoubleAttribute( const char * name, double val )
++{	
++	char buf[128];
++	sprintf( buf, "%f", val );
++	SetAttribute( name, buf );
++}
++
++
++void TiXmlElement::SetAttribute( const char * name, const char * _value )
++{
++	TiXmlAttribute* node = attributeSet.Find( name );
++	if ( node )
++	{
++		node->SetValue( _value );
++		return;
++	}
++
++	TiXmlAttribute* attrib = new TiXmlAttribute( name, _value );
++	if ( attrib )
++	{
++		attributeSet.Add( attrib );
++	}
++	else
++	{
++		TiXmlDocument* document = GetDocument();
++		if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
++	}
++}
++
++void TiXmlElement::Print( FILE* cfile, int depth ) const
++{
++	int i;
++	for ( i=0; i<depth; i++ )
++	{
++		fprintf( cfile, "    " );
++	}
++
++	fprintf( cfile, "<%s", value.c_str() );
++
++	TiXmlAttribute* attrib;
++	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
++	{
++		fprintf( cfile, " " );
++		attrib->Print( cfile, depth );
++	}
++
++	// There are 3 different formatting approaches:
++	// 1) An element without children is printed as a <foo /> node
++	// 2) An element with only a text child is printed as <foo> text </foo>
++	// 3) An element with children is printed on multiple lines.
++	TiXmlNode* node;
++	if ( !firstChild )
++	{
++		fprintf( cfile, " />" );
++	}
++	else if ( firstChild == lastChild && firstChild->ToText() )
++	{
++		fprintf( cfile, ">" );
++		firstChild->Print( cfile, depth + 1 );
++		fprintf( cfile, "</%s>", value.c_str() );
++	}
++	else
++	{
++		fprintf( cfile, ">" );
++
++		for ( node = firstChild; node; node=node->NextSibling() )
++		{
++			if ( !node->ToText() )
++			{
++				fprintf( cfile, "\n" );
++			}
++			node->Print( cfile, depth+1 );
++		}
++		fprintf( cfile, "\n" );
++		for( i=0; i<depth; ++i )
++		fprintf( cfile, "    " );
++		fprintf( cfile, "</%s>", value.c_str() );
++	}
++}
++
++void TiXmlElement::StreamOut( TIXML_OSTREAM * stream ) const
++{
++	(*stream) << "<" << value;
++
++	TiXmlAttribute* attrib;
++	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
++	{	
++		(*stream) << " ";
++		attrib->StreamOut( stream );
++	}
++
++	// If this node has children, give it a closing tag. Else
++	// make it an empty tag.
++	TiXmlNode* node;
++	if ( firstChild )
++	{ 		
++		(*stream) << ">";
++
++		for ( node = firstChild; node; node=node->NextSibling() )
++		{
++			node->StreamOut( stream );
++		}
++		(*stream) << "</" << value << ">";
++	}
++	else
++	{
++		(*stream) << " />";
++	}
++}
++
++
++void TiXmlElement::CopyTo( TiXmlElement* target ) const
++{
++	// superclass:
++	TiXmlNode::CopyTo( target );
++
++	// Element class: 
++	// Clone the attributes, then clone the children.
++	TiXmlAttribute* attribute = 0;
++	for(	attribute = attributeSet.First();
++	attribute;
++	attribute = attribute->Next() )
++	{
++		target->SetAttribute( attribute->Name(), attribute->Value() );
++	}
++
++	TiXmlNode* node = 0;
++	for ( node = firstChild; node; node = node->NextSibling() )
++	{
++		target->LinkEndChild( node->Clone() );
++	}
++}
++
++
++TiXmlNode* TiXmlElement::Clone() const
++{
++	TiXmlElement* clone = new TiXmlElement( Value() );
++	if ( !clone )
++		return 0;
++
++	CopyTo( clone );
++	return clone;
++}
++
++
++TiXmlDocument::TiXmlDocument() : TiXmlNode( TiXmlNode::DOCUMENT )
++{
++	tabsize = 4;
++	ClearError();
++}
++
++TiXmlDocument::TiXmlDocument( const char * documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
++{
++	tabsize = 4;
++	value = documentName;
++	ClearError();
++}
++
++
++#ifdef TIXML_USE_STL
++TiXmlDocument::TiXmlDocument( const std::string& documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
++{
++	tabsize = 4;
++    value = documentName;
++	ClearError();
++}
++#endif
++
++
++TiXmlDocument::TiXmlDocument( const TiXmlDocument& copy ) : TiXmlNode( TiXmlNode::DOCUMENT )
++{
++	copy.CopyTo( this );
++}
++
++
++void TiXmlDocument::operator=( const TiXmlDocument& copy )
++{
++	Clear();
++	copy.CopyTo( this );
++}
++
++
++bool TiXmlDocument::LoadFile( TiXmlEncoding encoding )
++{
++	// See STL_STRING_BUG below.
++	StringToBuffer buf( value );
++
++	if ( buf.buffer && LoadFile( buf.buffer, encoding ) )
++		return true;
++
++	return false;
++}
++
++
++bool TiXmlDocument::SaveFile() const
++{
++	// See STL_STRING_BUG below.
++	StringToBuffer buf( value );
++
++	if ( buf.buffer && SaveFile( buf.buffer ) )
++		return true;
++
++	return false;
++}
++
++bool TiXmlDocument::LoadFile( const char* filename, TiXmlEncoding encoding )
++{
++	// Delete the existing data:
++	Clear();
++	location.Clear();
++
++	// There was a really terrifying little bug here. The code:
++	//		value = filename
++	// in the STL case, cause the assignment method of the std::string to
++	// be called. What is strange, is that the std::string had the same
++	// address as it's c_str() method, and so bad things happen. Looks
++	// like a bug in the Microsoft STL implementation.
++	// See STL_STRING_BUG above.
++	// Fixed with the StringToBuffer class.
++	value = filename;
++
++	FILE* file = fopen( value.c_str (), "r" );
++
++	if ( file )
++	{
++		// Get the file size, so we can pre-allocate the string. HUGE speed impact.
++		long length = 0;
++		fseek( file, 0, SEEK_END );
++		length = ftell( file );
++		fseek( file, 0, SEEK_SET );
++
++		// Strange case, but good to handle up front.
++		if ( length == 0 )
++		{
++			fclose( file );
++			return false;
++		}
++
++		// If we have a file, assume it is all one big XML file, and read it in.
++		// The document parser may decide the document ends sooner than the entire file, however.
++		TIXML_STRING data;
++		data.reserve( length );
++
++		const int BUF_SIZE = 2048;
++		char buf[BUF_SIZE];
++
++		while( fgets( buf, BUF_SIZE, file ) )
++		{
++			data += buf;
++		}
++		fclose( file );
++
++		Parse( data.c_str(), 0, encoding );
++
++		if (  Error() )
++            return false;
++        else
++			return true;
++	}
++	SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
++	return false;
++}
++
++bool TiXmlDocument::SaveFile( const char * filename ) const
++{
++	// The old c stuff lives on...
++	FILE* fp = fopen( filename, "w" );
++	if ( fp )
++	{
++		Print( fp, 0 );
++		fclose( fp );
++		return true;
++	}
++	return false;
++}
++
++
++void TiXmlDocument::CopyTo( TiXmlDocument* target ) const
++{
++	TiXmlNode::CopyTo( target );
++
++	target->error = error;
++	target->errorDesc = errorDesc.c_str ();
++
++	TiXmlNode* node = 0;
++	for ( node = firstChild; node; node = node->NextSibling() )
++	{
++		target->LinkEndChild( node->Clone() );
++	}	
++}
++
++
++TiXmlNode* TiXmlDocument::Clone() const
++{
++	TiXmlDocument* clone = new TiXmlDocument();
++	if ( !clone )
++		return 0;
++
++	CopyTo( clone );
++	return clone;
++}
++
++
++void TiXmlDocument::Print( FILE* cfile, int depth ) const
++{
++	TiXmlNode* node;
++	for ( node=FirstChild(); node; node=node->NextSibling() )
++	{
++		node->Print( cfile, depth );
++		fprintf( cfile, "\n" );
++	}
++}
++
++void TiXmlDocument::StreamOut( TIXML_OSTREAM * out ) const
++{
++	TiXmlNode* node;
++	for ( node=FirstChild(); node; node=node->NextSibling() )
++	{
++		node->StreamOut( out );
++
++		// Special rule for streams: stop after the root element.
++		// The stream in code will only read one element, so don't
++		// write more than one.
++		if ( node->ToElement() )
++			break;
++	}
++}
++
++
++TiXmlAttribute* TiXmlAttribute::Next() const
++{
++	// We are using knowledge of the sentinel. The sentinel
++	// have a value or name.
++	if ( next->value.empty() && next->name.empty() )
++		return 0;
++	return next;
++}
++
++
++TiXmlAttribute* TiXmlAttribute::Previous() const
++{
++	// We are using knowledge of the sentinel. The sentinel
++	// have a value or name.
++	if ( prev->value.empty() && prev->name.empty() )
++		return 0;
++	return prev;
++}
++
++
++void TiXmlAttribute::Print( FILE* cfile, int /*depth*/ ) const
++{
++	TIXML_STRING n, v;
++
++	PutString( name, &n );
++	PutString( value, &v );
++
++	if (value.find ('\"') == TIXML_STRING::npos)
++		fprintf (cfile, "%s=\"%s\"", n.c_str(), v.c_str() );
++	else
++		fprintf (cfile, "%s='%s'", n.c_str(), v.c_str() );
++}
++
++
++void TiXmlAttribute::StreamOut( TIXML_OSTREAM * stream ) const
++{
++	if (value.find( '\"' ) != TIXML_STRING::npos)
++	{
++		PutString( name, stream );
++		(*stream) << "=" << "'";
++		PutString( value, stream );
++		(*stream) << "'";
++	}
++	else
++	{
++		PutString( name, stream );
++		(*stream) << "=" << "\"";
++		PutString( value, stream );
++		(*stream) << "\"";
++	}
++}
++
++int TiXmlAttribute::QueryIntValue( int* ival ) const
++{
++	if ( sscanf( value.c_str(), "%d", ival ) == 1 )
++		return TIXML_SUCCESS;
++	return TIXML_WRONG_TYPE;
++}
++
++int TiXmlAttribute::QueryDoubleValue( double* dval ) const
++{
++	if ( sscanf( value.c_str(), "%lf", dval ) == 1 )
++		return TIXML_SUCCESS;
++	return TIXML_WRONG_TYPE;
++}
++
++void TiXmlAttribute::SetIntValue( int _value )
++{
++	char buf [64];
++	sprintf (buf, "%d", _value);
++	SetValue (buf);
++}
++
++void TiXmlAttribute::SetDoubleValue( double _value )
++{
++	char buf [64];
++	sprintf (buf, "%lf", _value);
++	SetValue (buf);
++}
++
++const int TiXmlAttribute::IntValue() const
++{
++	return atoi (value.c_str ());
++}
++
++const double  TiXmlAttribute::DoubleValue() const
++{
++	return atof (value.c_str ());
++}
++
++
++TiXmlComment::TiXmlComment( const TiXmlComment& copy ) : TiXmlNode( TiXmlNode::COMMENT )
++{
++	copy.CopyTo( this );
++}
++
++
++void TiXmlComment::operator=( const TiXmlComment& base )
++{
++	Clear();
++	base.CopyTo( this );
++}
++
++
++void TiXmlComment::Print( FILE* cfile, int depth ) const
++{
++	for ( int i=0; i<depth; i++ )
++	{
++		fputs( "    ", cfile );
++	}
++	fprintf( cfile, "<!--%s-->", value.c_str() );
++}
++
++void TiXmlComment::StreamOut( TIXML_OSTREAM * stream ) const
++{
++	(*stream) << "<!--";
++	//PutString( value, stream );
++	(*stream) << value;
++	(*stream) << "-->";
++}
++
++
++void TiXmlComment::CopyTo( TiXmlComment* target ) const
++{
++	TiXmlNode::CopyTo( target );
++}
++
++
++TiXmlNode* TiXmlComment::Clone() const
++{
++	TiXmlComment* clone = new TiXmlComment();
++
++	if ( !clone )
++		return 0;
++
++	CopyTo( clone );
++	return clone;
++}
++
++
++void TiXmlText::Print( FILE* cfile, int /*depth*/ ) const
++{
++	TIXML_STRING buffer;
++	PutString( value, &buffer );
++	fprintf( cfile, "%s", buffer.c_str() );
++}
++
++
++void TiXmlText::StreamOut( TIXML_OSTREAM * stream ) const
++{
++	PutString( value, stream );
++}
++
++
++void TiXmlText::CopyTo( TiXmlText* target ) const
++{
++	TiXmlNode::CopyTo( target );
++}
++
++
++TiXmlNode* TiXmlText::Clone() const
++{	
++	TiXmlText* clone = 0;
++	clone = new TiXmlText( "" );
++
++	if ( !clone )
++		return 0;
++
++	CopyTo( clone );
++	return clone;
++}
++
++
++TiXmlDeclaration::TiXmlDeclaration( const char * _version,
++									const char * _encoding,
++									const char * _standalone )
++	: TiXmlNode( TiXmlNode::DECLARATION )
++{
++	version = _version;
++	encoding = _encoding;
++	standalone = _standalone;
++}
++
++
++#ifdef TIXML_USE_STL
++TiXmlDeclaration::TiXmlDeclaration(	const std::string& _version,
++									const std::string& _encoding,
++									const std::string& _standalone )
++	: TiXmlNode( TiXmlNode::DECLARATION )
++{
++	version = _version;
++	encoding = _encoding;
++	standalone = _standalone;
++}
++#endif
++
++
++TiXmlDeclaration::TiXmlDeclaration( const TiXmlDeclaration& copy )
++	: TiXmlNode( TiXmlNode::DECLARATION )
++{
++	copy.CopyTo( this );	
++}
++
++
++void TiXmlDeclaration::operator=( const TiXmlDeclaration& copy )
++{
++	Clear();
++	copy.CopyTo( this );
++}
++
++
++void TiXmlDeclaration::Print( FILE* cfile, int /*depth*/ ) const
++{
++	fprintf (cfile, "<?xml ");
++
++	if ( !version.empty() )
++		fprintf (cfile, "version=\"%s\" ", version.c_str ());
++	if ( !encoding.empty() )
++		fprintf (cfile, "encoding=\"%s\" ", encoding.c_str ());
++	if ( !standalone.empty() )
++		fprintf (cfile, "standalone=\"%s\" ", standalone.c_str ());
++	fprintf (cfile, "?>");
++}
++
++void TiXmlDeclaration::StreamOut( TIXML_OSTREAM * stream ) const
++{
++	(*stream) << "<?xml ";
++
++	if ( !version.empty() )
++	{
++		(*stream) << "version=\"";
++		PutString( version, stream );
++		(*stream) << "\" ";
++	}
++	if ( !encoding.empty() )
++	{
++		(*stream) << "encoding=\"";
++		PutString( encoding, stream );
++		(*stream ) << "\" ";
++	}
++	if ( !standalone.empty() )
++	{
++		(*stream) << "standalone=\"";
++		PutString( standalone, stream );
++		(*stream) << "\" ";
++	}
++	(*stream) << "?>";
++}
++
++
++void TiXmlDeclaration::CopyTo( TiXmlDeclaration* target ) const
++{
++	TiXmlNode::CopyTo( target );
++
++	target->version = version;
++	target->encoding = encoding;
++	target->standalone = standalone;
++}
++
++
++TiXmlNode* TiXmlDeclaration::Clone() const
++{	
++	TiXmlDeclaration* clone = new TiXmlDeclaration();
++
++	if ( !clone )
++		return 0;
++
++	CopyTo( clone );
++	return clone;
++}
++
++
++void TiXmlUnknown::Print( FILE* cfile, int depth ) const
++{
++	for ( int i=0; i<depth; i++ )
++		fprintf( cfile, "    " );
++	fprintf( cfile, "<%s>", value.c_str() );
++}
++
++
++void TiXmlUnknown::StreamOut( TIXML_OSTREAM * stream ) const
++{
++	(*stream) << "<" << value << ">";		// Don't use entities here! It is unknown.
++}
++
++
++void TiXmlUnknown::CopyTo( TiXmlUnknown* target ) const
++{
++	TiXmlNode::CopyTo( target );
++}
++
++
++TiXmlNode* TiXmlUnknown::Clone() const
++{
++	TiXmlUnknown* clone = new TiXmlUnknown();
++
++	if ( !clone )
++		return 0;
++
++	CopyTo( clone );
++	return clone;
++}
++
++
++TiXmlAttributeSet::TiXmlAttributeSet()
++{
++	sentinel.next = &sentinel;
++	sentinel.prev = &sentinel;
++}
++
++
++TiXmlAttributeSet::~TiXmlAttributeSet()
++{
++	assert( sentinel.next == &sentinel );
++	assert( sentinel.prev == &sentinel );
++}
++
++
++void TiXmlAttributeSet::Add( TiXmlAttribute* addMe )
++{
++	assert( !Find( addMe->Name() ) );	// Shouldn't be multiply adding to the set.
++
++	addMe->next = &sentinel;
++	addMe->prev = sentinel.prev;
++
++	sentinel.prev->next = addMe;
++	sentinel.prev      = addMe;
++}
++
++void TiXmlAttributeSet::Remove( TiXmlAttribute* removeMe )
++{
++	TiXmlAttribute* node;
++
++	for( node = sentinel.next; node != &sentinel; node = node->next )
++	{
++		if ( node == removeMe )
++		{
++			node->prev->next = node->next;
++			node->next->prev = node->prev;
++			node->next = 0;
++			node->prev = 0;
++			return;
++		}
++	}
++	assert( 0 );		// we tried to remove a non-linked attribute.
++}
++
++TiXmlAttribute*	TiXmlAttributeSet::Find( const char * name ) const
++{
++	TiXmlAttribute* node;
++
++	for( node = sentinel.next; node != &sentinel; node = node->next )
++	{
++		if ( node->name == name )
++			return node;
++	}
++	return 0;
++}
++
++
++#ifdef TIXML_USE_STL	
++TIXML_ISTREAM & operator >> (TIXML_ISTREAM & in, TiXmlNode & base)
++{
++	TIXML_STRING tag;
++	tag.reserve( 8 * 1000 );
++	base.StreamIn( &in, &tag );
++
++	base.Parse( tag.c_str(), 0, TIXML_DEFAULT_ENCODING );
++	return in;
++}
++#endif
++
++
++TIXML_OSTREAM & operator<< (TIXML_OSTREAM & out, const TiXmlNode & base)
++{
++	base.StreamOut (& out);
++	return out;
++}
++
++
++#ifdef TIXML_USE_STL	
++std::string & operator<< (std::string& out, const TiXmlNode& base )
++{
++   std::ostringstream os_stream( std::ostringstream::out );
++   base.StreamOut( &os_stream );
++   
++   out.append( os_stream.str() );
++   return out;
++}
++#endif
++
++
++TiXmlHandle TiXmlHandle::FirstChild() const
++{
++	if ( node )
++	{
++		TiXmlNode* child = node->FirstChild();
++		if ( child )
++			return TiXmlHandle( child );
++	}
++	return TiXmlHandle( 0 );
++}
++
++
++TiXmlHandle TiXmlHandle::FirstChild( const char * value ) const
++{
++	if ( node )
++	{
++		TiXmlNode* child = node->FirstChild( value );
++		if ( child )
++			return TiXmlHandle( child );
++	}
++	return TiXmlHandle( 0 );
++}
++
++
++TiXmlHandle TiXmlHandle::FirstChildElement() const
++{
++	if ( node )
++	{
++		TiXmlElement* child = node->FirstChildElement();
++		if ( child )
++			return TiXmlHandle( child );
++	}
++	return TiXmlHandle( 0 );
++}
++
++
++TiXmlHandle TiXmlHandle::FirstChildElement( const char * value ) const
++{
++	if ( node )
++	{
++		TiXmlElement* child = node->FirstChildElement( value );
++		if ( child )
++			return TiXmlHandle( child );
++	}
++	return TiXmlHandle( 0 );
++}
++
++
++TiXmlHandle TiXmlHandle::Child( int count ) const
++{
++	if ( node )
++	{
++		int i;
++		TiXmlNode* child = node->FirstChild();
++		for (	i=0;
++				child && i<count;
++				child = child->NextSibling(), ++i )
++		{
++			// nothing
++		}
++		if ( child )
++			return TiXmlHandle( child );
++	}
++	return TiXmlHandle( 0 );
++}
++
++
++TiXmlHandle TiXmlHandle::Child( const char* value, int count ) const
++{
++	if ( node )
++	{
++		int i;
++		TiXmlNode* child = node->FirstChild( value );
++		for (	i=0;
++				child && i<count;
++				child = child->NextSibling( value ), ++i )
++		{
++			// nothing
++		}
++		if ( child )
++			return TiXmlHandle( child );
++	}
++	return TiXmlHandle( 0 );
++}
++
++
++TiXmlHandle TiXmlHandle::ChildElement( int count ) const
++{
++	if ( node )
++	{
++		int i;
++		TiXmlElement* child = node->FirstChildElement();
++		for (	i=0;
++				child && i<count;
++				child = child->NextSiblingElement(), ++i )
++		{
++			// nothing
++		}
++		if ( child )
++			return TiXmlHandle( child );
++	}
++	return TiXmlHandle( 0 );
++}
++
++
++TiXmlHandle TiXmlHandle::ChildElement( const char* value, int count ) const
++{
++	if ( node )
++	{
++		int i;
++		TiXmlElement* child = node->FirstChildElement( value );
++		for (	i=0;
++				child && i<count;
++				child = child->NextSiblingElement( value ), ++i )
++		{
++			// nothing
++		}
++		if ( child )
++			return TiXmlHandle( child );
++	}
++	return TiXmlHandle( 0 );
++}
++#endif /* SETUP */
+diff -ruNp vdr-1.6.0-2/tinyxmlerror.c vdr-1.6.0-2-setup-zulu-edition/tinyxmlerror.c
+--- vdr-1.6.0-2/tinyxmlerror.c	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0-2-setup-zulu-edition/tinyxmlerror.c	2009-01-19 09:43:52.000000000 +0100
+@@ -0,0 +1,53 @@
++#ifdef USE_SETUP
++/*
++www.sourceforge.net/projects/tinyxml
++Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
++
++This software is provided 'as-is', without any express or implied 
++warranty. In no event will the authors be held liable for any 
++damages arising from the use of this software.
++
++Permission is granted to anyone to use this software for any 
++purpose, including commercial applications, and to alter it and 
++redistribute it freely, subject to the following restrictions:
++
++1. The origin of this software must not be misrepresented; you must
++not claim that you wrote the original software. If you use this
++software in a product, an acknowledgment in the product documentation
++would be appreciated but is not required.
++
++2. Altered source versions must be plainly marked as such, and
++must not be misrepresented as being the original software.
++
++3. This notice may not be removed or altered from any source
++distribution.
++*/
++
++#include "tinyxml.h"
++
++// The goal of the seperate error file is to make the first
++// step towards localization. tinyxml (currently) only supports
++// latin-1, but at least the error messages could now be translated.
++//
++// It also cleans up the code a bit.
++//
++
++const char* TiXmlBase::errorString[ TIXML_ERROR_STRING_COUNT ] =
++{
++	"No error",
++	"Error",
++	"Failed to open file",
++	"Memory allocation failed.",
++	"Error parsing Element.",
++	"Failed to read Element name",
++	"Error reading Element value.",
++	"Error reading Attributes.",
++	"Error: empty tag.",
++	"Error reading end tag.",
++	"Error parsing Unknown.",
++	"Error parsing Comment.",
++	"Error parsing Declaration.",
++	"Error document empty.",
++	"Error null (0) or unexpected EOF found in input stream.",
++};
++#endif /* SETUP */
+diff -ruNp vdr-1.6.0-2/tinyxml.h vdr-1.6.0-2-setup-zulu-edition/tinyxml.h
+--- vdr-1.6.0-2/tinyxml.h	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0-2-setup-zulu-edition/tinyxml.h	2009-01-19 09:43:52.000000000 +0100
+@@ -0,0 +1,1372 @@
++#ifdef USE_SETUP
++/*
++www.sourceforge.net/projects/tinyxml
++Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
++
++This software is provided 'as-is', without any express or implied
++warranty. In no event will the authors be held liable for any
++damages arising from the use of this software.
++
++Permission is granted to anyone to use this software for any
++purpose, including commercial applications, and to alter it and
++redistribute it freely, subject to the following restrictions:
++
++1. The origin of this software must not be misrepresented; you must
++not claim that you wrote the original software. If you use this
++software in a product, an acknowledgment in the product documentation
++would be appreciated but is not required.
++
++2. Altered source versions must be plainly marked as such, and
++must not be misrepresented as being the original software.
++
++3. This notice may not be removed or altered from any source
++distribution.
++*/
++
++
++#ifndef TINYXML_INCLUDED
++#define TINYXML_INCLUDED
++
++#ifdef _MSC_VER
++#pragma warning( disable : 4530 )
++#pragma warning( disable : 4786 )
++#endif
++
++#include <ctype.h>
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#include <assert.h>
++
++// Help out windows:
++#if defined( _DEBUG ) && !defined( DEBUG )
++#define DEBUG
++#endif
++
++#if defined( DEBUG ) && defined( _MSC_VER )
++#include <windows.h>
++#define TIXML_LOG OutputDebugString
++#else
++#define TIXML_LOG printf
++#endif
++
++#ifdef TIXML_USE_STL
++	#include <string>
++ 	#include <iostream>
++	#define TIXML_STRING	std::string
++	#define TIXML_ISTREAM	std::istream
++	#define TIXML_OSTREAM	std::ostream
++#else
++	#include "tinystr.h"
++	#define TIXML_STRING	TiXmlString
++	#define TIXML_OSTREAM	TiXmlOutStream
++#endif
++
++class TiXmlDocument;
++class TiXmlElement;
++class TiXmlComment;
++class TiXmlUnknown;
++class TiXmlAttribute;
++class TiXmlText;
++class TiXmlDeclaration;
++class TiXmlParsingData;
++
++const int TIXML_MAJOR_VERSION = 2;
++const int TIXML_MINOR_VERSION = 3;
++const int TIXML_PATCH_VERSION = 2;
++
++/*	Internal structure for tracking location of items 
++	in the XML file.
++*/
++struct TiXmlCursor
++{
++	TiXmlCursor()		{ Clear(); }
++	void Clear()		{ row = col = -1; }
++
++	int row;	// 0 based.
++	int col;	// 0 based.
++};
++
++
++// Only used by Attribute::Query functions
++enum 
++{ 
++	TIXML_SUCCESS,
++	TIXML_NO_ATTRIBUTE,
++	TIXML_WRONG_TYPE
++};
++
++
++// Used by the parsing routines.
++enum TiXmlEncoding
++{
++	TIXML_ENCODING_UNKNOWN,
++	TIXML_ENCODING_UTF8,
++	TIXML_ENCODING_LEGACY
++};
++
++const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
++
++/** TiXmlBase is a base class for every class in TinyXml.
++	It does little except to establish that TinyXml classes
++	can be printed and provide some utility functions.
++
++	In XML, the document and elements can contain
++	other elements and other types of nodes.
++
++	@verbatim
++	A Document can contain:	Element	(container or leaf)
++							Comment (leaf)
++							Unknown (leaf)
++							Declaration( leaf )
++
++	An Element can contain:	Element (container or leaf)
++							Text	(leaf)
++							Attributes (not on tree)
++							Comment (leaf)
++							Unknown (leaf)
++
++	A Decleration contains: Attributes (not on tree)
++	@endverbatim
++*/
++class TiXmlBase
++{
++	friend class TiXmlNode;
++	friend class TiXmlElement;
++	friend class TiXmlDocument;
++
++public:
++	TiXmlBase()	:	userData(0) {}
++	virtual ~TiXmlBase()					{}
++
++	/**	All TinyXml classes can print themselves to a filestream.
++		This is a formatted print, and will insert tabs and newlines.
++		
++		(For an unformatted stream, use the << operator.)
++	*/
++	virtual void Print( FILE* cfile, int depth ) const = 0;
++
++	/**	The world does not agree on whether white space should be kept or
++		not. In order to make everyone happy, these global, static functions
++		are provided to set whether or not TinyXml will condense all white space
++		into a single space or not. The default is to condense. Note changing this
++		values is not thread safe.
++	*/
++	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }
++
++	/// Return the current white space setting.
++	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }
++
++	/** Return the position, in the original source file, of this node or attribute.
++		The row and column are 1-based. (That is the first row and first column is
++		1,1). If the returns values are 0 or less, then the parser does not have
++		a row and column value.
++
++		Generally, the row and column value will be set when the TiXmlDocument::Load(),
++		TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
++		when the DOM was created from operator>>.
++
++		The values reflect the initial load. Once the DOM is modified programmatically
++		(by adding or changing nodes and attributes) the new values will NOT update to
++		reflect changes in the document.
++
++		There is a minor performance cost to computing the row and column. Computation
++		can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.
++
++		@sa TiXmlDocument::SetTabSize()
++	*/
++	int Row() const			{ return location.row + 1; }
++	int Column() const		{ return location.col + 1; }	///< See Row()
++
++	void  SetUserData( void* user )			{ userData = user; }
++	void* GetUserData()						{ return userData; }
++
++	// Table that returs, for a given lead byte, the total number of bytes
++	// in the UTF-8 sequence.
++	static const int utf8ByteTable[256];
++
++	virtual const char* Parse(	const char* p, 
++								TiXmlParsingData* data, 
++								TiXmlEncoding encoding /*= TIXML_ENCODING_UNKNOWN */ ) = 0;
++
++protected:
++
++	// See STL_STRING_BUG
++	// Utility class to overcome a bug.
++	class StringToBuffer
++	{
++	  public:
++		StringToBuffer( const TIXML_STRING& str );
++		~StringToBuffer();
++		char* buffer;
++	};
++
++	static const char*	SkipWhiteSpace( const char*, TiXmlEncoding encoding );
++	inline static bool	IsWhiteSpace( char c )		
++	{ 
++		return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' ); 
++	}
++
++	virtual void StreamOut (TIXML_OSTREAM *) const = 0;
++
++	#ifdef TIXML_USE_STL
++	    static bool	StreamWhiteSpace( TIXML_ISTREAM * in, TIXML_STRING * tag );
++	    static bool StreamTo( TIXML_ISTREAM * in, int character, TIXML_STRING * tag );
++	#endif
++
++	/*	Reads an XML name into the string provided. Returns
++		a pointer just past the last character of the name,
++		or 0 if the function has an error.
++	*/
++	static const char* ReadName( const char* p, TIXML_STRING* name, TiXmlEncoding encoding );
++
++	/*	Reads text. Returns a pointer past the given end tag.
++		Wickedly complex options, but it keeps the (sensitive) code in one place.
++	*/
++	static const char* ReadText(	const char* in,				// where to start
++									TIXML_STRING* text,			// the string read
++									bool ignoreWhiteSpace,		// whether to keep the white space
++									const char* endTag,			// what ends this text
++									bool ignoreCase,			// whether to ignore case in the end tag
++									TiXmlEncoding encoding );	// the current encoding
++
++	// If an entity has been found, transform it into a character.
++	static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );
++
++	// Get a character, while interpreting entities.
++	// The length can be from 0 to 4 bytes.
++	inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
++	{
++		assert( p );
++		if ( encoding == TIXML_ENCODING_UTF8 )
++		{
++			*length = utf8ByteTable[ *((unsigned char*)p) ];
++			assert( *length >= 0 && *length < 5 );
++		}
++		else
++		{
++			*length = 1;
++		}
++
++		if ( *length == 1 )
++		{
++			if ( *p == '&' )
++				return GetEntity( p, _value, length, encoding );
++			*_value = *p;
++			return p+1;
++		}
++		else if ( *length )
++		{
++			strncpy( _value, p, *length );
++			return p + (*length);
++		}
++		else
++		{
++			// Not valid text.
++			return 0;
++		}
++	}
++
++	// Puts a string to a stream, expanding entities as it goes.
++	// Note this should not contian the '<', '>', etc, or they will be transformed into entities!
++	static void PutString( const TIXML_STRING& str, TIXML_OSTREAM* out );
++
++	static void PutString( const TIXML_STRING& str, TIXML_STRING* out );
++
++	// Return true if the next characters in the stream are any of the endTag sequences.
++	// Ignore case only works for english, and should only be relied on when comparing
++	// to Engilish words: StringEqual( p, "version", true ) is fine.
++	static bool StringEqual(	const char* p,
++								const char* endTag,
++								bool ignoreCase,
++								TiXmlEncoding encoding );
++
++
++	enum
++	{
++		TIXML_NO_ERROR = 0,
++		TIXML_ERROR,
++		TIXML_ERROR_OPENING_FILE,
++		TIXML_ERROR_OUT_OF_MEMORY,
++		TIXML_ERROR_PARSING_ELEMENT,
++		TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
++		TIXML_ERROR_READING_ELEMENT_VALUE,
++		TIXML_ERROR_READING_ATTRIBUTES,
++		TIXML_ERROR_PARSING_EMPTY,
++		TIXML_ERROR_READING_END_TAG,
++		TIXML_ERROR_PARSING_UNKNOWN,
++		TIXML_ERROR_PARSING_COMMENT,
++		TIXML_ERROR_PARSING_DECLARATION,
++		TIXML_ERROR_DOCUMENT_EMPTY,
++		TIXML_ERROR_EMBEDDED_NULL,
++
++		TIXML_ERROR_STRING_COUNT
++	};
++	static const char* errorString[ TIXML_ERROR_STRING_COUNT ];
++
++	TiXmlCursor location;
++
++    /// Field containing a generic user pointer
++	void*			userData;
++	
++	// None of these methods are reliable for any language except English.
++	// Good for approximation, not great for accuracy.
++	static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
++	static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
++	inline static int ToLower( int v, TiXmlEncoding encoding )
++	{
++		if ( encoding == TIXML_ENCODING_UTF8 )
++		{
++			if ( v < 128 ) return tolower( v );
++			return v;
++		}
++		else
++		{
++			return tolower( v );
++		}
++	}
++	static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );
++
++private:
++	TiXmlBase( const TiXmlBase& );				// not implemented.
++	void operator=( const TiXmlBase& base );	// not allowed.
++
++	struct Entity
++	{
++		const char*     str;
++		unsigned int	strLength;
++		char		    chr;
++	};
++	enum
++	{
++		NUM_ENTITY = 5,
++		MAX_ENTITY_LENGTH = 6
++
++	};
++	static Entity entity[ NUM_ENTITY ];
++	static bool condenseWhiteSpace;
++};
++
++
++/** The parent class for everything in the Document Object Model.
++	(Except for attributes).
++	Nodes have siblings, a parent, and children. A node can be
++	in a document, or stand on its own. The type of a TiXmlNode
++	can be queried, and it can be cast to its more defined type.
++*/
++class TiXmlNode : public TiXmlBase
++{
++	friend class TiXmlDocument;
++	friend class TiXmlElement;
++
++public:
++	#ifdef TIXML_USE_STL	
++
++	    /** An input stream operator, for every class. Tolerant of newlines and
++		    formatting, but doesn't expect them.
++	    */
++	    friend std::istream& operator >> (std::istream& in, TiXmlNode& base);
++
++	    /** An output stream operator, for every class. Note that this outputs
++		    without any newlines or formatting, as opposed to Print(), which
++		    includes tabs and new lines.
++
++		    The operator<< and operator>> are not completely symmetric. Writing
++		    a node to a stream is very well defined. You'll get a nice stream
++		    of output, without any extra whitespace or newlines.
++		    
++		    But reading is not as well defined. (As it always is.) If you create
++		    a TiXmlElement (for example) and read that from an input stream,
++		    the text needs to define an element or junk will result. This is
++		    true of all input streams, but it's worth keeping in mind.
++
++		    A TiXmlDocument will read nodes until it reads a root element, and
++			all the children of that root element.
++	    */	
++	    friend std::ostream& operator<< (std::ostream& out, const TiXmlNode& base);
++
++		/// Appends the XML node or attribute to a std::string.
++		friend std::string& operator<< (std::string& out, const TiXmlNode& base );
++
++	#else
++	    // Used internally, not part of the public API.
++	    friend TIXML_OSTREAM& operator<< (TIXML_OSTREAM& out, const TiXmlNode& base);
++	#endif
++
++	/** The types of XML nodes supported by TinyXml. (All the
++			unsupported types are picked up by UNKNOWN.)
++	*/
++	enum NodeType
++	{
++		DOCUMENT,
++		ELEMENT,
++		COMMENT,
++		UNKNOWN,
++		TEXT,
++		DECLARATION,
++		TYPECOUNT
++	};
++
++	virtual ~TiXmlNode();
++
++	/** The meaning of 'value' changes for the specific type of
++		TiXmlNode.
++		@verbatim
++		Document:	filename of the xml file
++		Element:	name of the element
++		Comment:	the comment text
++		Unknown:	the tag contents
++		Text:		the text string
++		@endverbatim
++
++		The subclasses will wrap this function.
++	*/
++	const char * Value() const { return value.c_str (); }
++
++	/** Changes the value of the node. Defined as:
++		@verbatim
++		Document:	filename of the xml file
++		Element:	name of the element
++		Comment:	the comment text
++		Unknown:	the tag contents
++		Text:		the text string
++		@endverbatim
++	*/
++	void SetValue(const char * _value) { value = _value;}
++
++    #ifdef TIXML_USE_STL
++	/// STL std::string form.
++	void SetValue( const std::string& _value )    
++	{	  
++		StringToBuffer buf( _value );
++		SetValue( buf.buffer ? buf.buffer : "" );    	
++	}	
++	#endif
++
++	/// Delete all the children of this node. Does not affect 'this'.
++	void Clear();
++
++	/// One step up the DOM.
++	TiXmlNode* Parent() const					{ return parent; }
++
++	TiXmlNode* FirstChild()	const	{ return firstChild; }		///< The first child of this node. Will be null if there are no children.
++	TiXmlNode* FirstChild( const char * value ) const;			///< The first child of this node with the matching 'value'. Will be null if none found.
++
++	TiXmlNode* LastChild() const	{ return lastChild; }		/// The last child of this node. Will be null if there are no children.
++	TiXmlNode* LastChild( const char * value ) const;			/// The last child of this node matching 'value'. Will be null if there are no children.
++
++    #ifdef TIXML_USE_STL
++	TiXmlNode* FirstChild( const std::string& _value ) const	{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
++	TiXmlNode* LastChild( const std::string& _value ) const		{	return LastChild (_value.c_str ());	}	///< STL std::string form.
++	#endif
++
++	/** An alternate way to walk the children of a node.
++		One way to iterate over nodes is:
++		@verbatim
++			for( child = parent->FirstChild(); child; child = child->NextSibling() )
++		@endverbatim
++
++		IterateChildren does the same thing with the syntax:
++		@verbatim
++			child = 0;
++			while( child = parent->IterateChildren( child ) )
++		@endverbatim
++
++		IterateChildren takes the previous child as input and finds
++		the next one. If the previous child is null, it returns the
++		first. IterateChildren will return null when done.
++	*/
++	TiXmlNode* IterateChildren( TiXmlNode* previous ) const;
++
++	/// This flavor of IterateChildren searches for children with a particular 'value'
++	TiXmlNode* IterateChildren( const char * value, TiXmlNode* previous ) const;
++
++    #ifdef TIXML_USE_STL
++	TiXmlNode* IterateChildren( const std::string& _value, TiXmlNode* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
++	#endif
++
++	/** Add a new node related to this. Adds a child past the LastChild.
++		Returns a pointer to the new object or NULL if an error occured.
++	*/
++	TiXmlNode* InsertEndChild( const TiXmlNode& addThis );
++
++
++	/** Add a new node related to this. Adds a child past the LastChild.
++
++		NOTE: the node to be added is passed by pointer, and will be
++		henceforth owned (and deleted) by tinyXml. This method is efficient
++		and avoids an extra copy, but should be used with care as it
++		uses a different memory model than the other insert functions.
++
++		@sa InsertEndChild
++	*/
++	TiXmlNode* LinkEndChild( TiXmlNode* addThis );
++
++	/** Add a new node related to this. Adds a child before the specified child.
++		Returns a pointer to the new object or NULL if an error occured.
++	*/
++	TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );
++
++	/** Add a new node related to this. Adds a child after the specified child.
++		Returns a pointer to the new object or NULL if an error occured.
++	*/
++	TiXmlNode* InsertAfterChild(  TiXmlNode* afterThis, const TiXmlNode& addThis );
++
++	/** Replace a child of this node.
++		Returns a pointer to the new object or NULL if an error occured.
++	*/
++	TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );
++
++	/// Delete a child of this node.
++	bool RemoveChild( TiXmlNode* removeThis );
++
++	/// Navigate to a sibling node.
++	TiXmlNode* PreviousSibling() const			{ return prev; }
++
++	/// Navigate to a sibling node.
++	TiXmlNode* PreviousSibling( const char * ) const;
++
++    #ifdef TIXML_USE_STL
++	TiXmlNode* PreviousSibling( const std::string& _value ) const	{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
++	TiXmlNode* NextSibling( const std::string& _value) const		{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
++	#endif
++
++	/// Navigate to a sibling node.
++	TiXmlNode* NextSibling() const				{ return next; }
++
++	/// Navigate to a sibling node with the given 'value'.
++	TiXmlNode* NextSibling( const char * ) const;
++
++	/** Convenience function to get through elements.
++		Calls NextSibling and ToElement. Will skip all non-Element
++		nodes. Returns 0 if there is not another element.
++	*/
++	TiXmlElement* NextSiblingElement() const;
++
++	/** Convenience function to get through elements.
++		Calls NextSibling and ToElement. Will skip all non-Element
++		nodes. Returns 0 if there is not another element.
++	*/
++	TiXmlElement* NextSiblingElement( const char * ) const;
++
++    #ifdef TIXML_USE_STL
++	TiXmlElement* NextSiblingElement( const std::string& _value) const	{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
++	#endif
++
++	/// Convenience function to get through elements.
++	TiXmlElement* FirstChildElement()	const;
++
++	/// Convenience function to get through elements.
++	TiXmlElement* FirstChildElement( const char * value ) const;
++
++    #ifdef TIXML_USE_STL
++	TiXmlElement* FirstChildElement( const std::string& _value ) const	{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
++	#endif
++
++	/** Query the type (as an enumerated value, above) of this node.
++		The possible types are: DOCUMENT, ELEMENT, COMMENT,
++								UNKNOWN, TEXT, and DECLARATION.
++	*/
++	virtual int Type() const	{ return type; }
++
++	/** Return a pointer to the Document this node lives in.
++		Returns null if not in a document.
++	*/
++	TiXmlDocument* GetDocument() const;
++
++	/// Returns true if this node has no children.
++	bool NoChildren() const						{ return !firstChild; }
++
++	TiXmlDocument* ToDocument()	const		{ return ( this && type == DOCUMENT ) ? (TiXmlDocument*) this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
++	TiXmlElement*  ToElement() const		{ return ( this && type == ELEMENT  ) ? (TiXmlElement*)  this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
++	TiXmlComment*  ToComment() const		{ return ( this && type == COMMENT  ) ? (TiXmlComment*)  this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
++	TiXmlUnknown*  ToUnknown() const		{ return ( this && type == UNKNOWN  ) ? (TiXmlUnknown*)  this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
++	TiXmlText*	   ToText()    const		{ return ( this && type == TEXT     ) ? (TiXmlText*)     this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
++	TiXmlDeclaration* ToDeclaration() const	{ return ( this && type == DECLARATION ) ? (TiXmlDeclaration*) this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
++
++	/** Create an exact duplicate of this node and return it. The memory must be deleted
++		by the caller. 
++	*/
++	virtual TiXmlNode* Clone() const = 0;
++
++protected:
++	TiXmlNode( NodeType _type );
++
++	// Copy to the allocated object. Shared functionality between Clone, Copy constructor,
++	// and the assignment operator.
++	void CopyTo( TiXmlNode* target ) const;
++
++	#ifdef TIXML_USE_STL
++	    // The real work of the input operator.
++	    virtual void StreamIn( TIXML_ISTREAM* in, TIXML_STRING* tag ) = 0;
++	#endif
++
++	// Figure out what is at *p, and parse it. Returns null if it is not an xml node.
++	TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );
++
++	// Internal Value function returning a TIXML_STRING
++	const TIXML_STRING& SValue() const	{ return value ; }
++
++	TiXmlNode*		parent;
++	NodeType		type;
++
++	TiXmlNode*		firstChild;
++	TiXmlNode*		lastChild;
++
++	TIXML_STRING	value;
++
++	TiXmlNode*		prev;
++	TiXmlNode*		next;
++
++private:
++	TiXmlNode( const TiXmlNode& );				// not implemented.
++	void operator=( const TiXmlNode& base );	// not allowed.
++};
++
++
++/** An attribute is a name-value pair. Elements have an arbitrary
++	number of attributes, each with a unique name.
++
++	@note The attributes are not TiXmlNodes, since they are not
++		  part of the tinyXML document object model. There are other
++		  suggested ways to look at this problem.
++*/
++class TiXmlAttribute : public TiXmlBase
++{
++	friend class TiXmlAttributeSet;
++
++public:
++	/// Construct an empty attribute.
++	TiXmlAttribute() : TiXmlBase()
++	{
++		document = 0;
++		prev = next = 0;
++	}
++
++	#ifdef TIXML_USE_STL
++	/// std::string constructor.
++	TiXmlAttribute( const std::string& _name, const std::string& _value )
++	{
++		name = _name;
++		value = _value;
++		document = 0;
++		prev = next = 0;
++	}
++	#endif
++
++	/// Construct an attribute with a name and value.
++	TiXmlAttribute( const char * _name, const char * _value )
++	{
++		name = _name;
++		value = _value;
++		document = 0;
++		prev = next = 0;
++	}
++
++	const char*		Name()  const		{ return name.c_str (); }		///< Return the name of this attribute.
++	const char*		Value() const		{ return value.c_str (); }		///< Return the value of this attribute.
++	const int       IntValue() const;									///< Return the value of this attribute, converted to an integer.
++	const double	DoubleValue() const;								///< Return the value of this attribute, converted to a double.
++
++	/** QueryIntValue examines the value string. It is an alternative to the
++		IntValue() method with richer error checking.
++		If the value is an integer, it is stored in 'value' and 
++		the call returns TIXML_SUCCESS. If it is not
++		an integer, it returns TIXML_WRONG_TYPE.
++
++		A specialized but useful call. Note that for success it returns 0,
++		which is the opposite of almost all other TinyXml calls.
++	*/
++	int QueryIntValue( int* value ) const;
++	/// QueryDoubleValue examines the value string. See QueryIntValue().
++	int QueryDoubleValue( double* value ) const;
++
++	void SetName( const char* _name )	{ name = _name; }				///< Set the name of this attribute.
++	void SetValue( const char* _value )	{ value = _value; }				///< Set the value.
++
++	void SetIntValue( int value );										///< Set the value from an integer.
++	void SetDoubleValue( double value );								///< Set the value from a double.
++
++    #ifdef TIXML_USE_STL
++	/// STL std::string form.
++	void SetName( const std::string& _name )	
++	{	
++		StringToBuffer buf( _name );
++		SetName ( buf.buffer ? buf.buffer : "error" );	
++	}
++	/// STL std::string form.	
++	void SetValue( const std::string& _value )	
++	{	
++		StringToBuffer buf( _value );
++		SetValue( buf.buffer ? buf.buffer : "error" );	
++	}
++	#endif
++
++	/// Get the next sibling attribute in the DOM. Returns null at end.
++	TiXmlAttribute* Next() const;
++	/// Get the previous sibling attribute in the DOM. Returns null at beginning.
++	TiXmlAttribute* Previous() const;
++
++	bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
++	bool operator<( const TiXmlAttribute& rhs )	 const { return name < rhs.name; }
++	bool operator>( const TiXmlAttribute& rhs )  const { return name > rhs.name; }
++
++	/*	Attribute parsing starts: first letter of the name
++						 returns: the next char after the value end quote
++	*/
++	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
++
++	// Prints this Attribute to a FILE stream.
++	virtual void Print( FILE* cfile, int depth ) const;
++
++	virtual void StreamOut( TIXML_OSTREAM * out ) const;
++	// [internal use]
++	// Set the document pointer so the attribute can report errors.
++	void SetDocument( TiXmlDocument* doc )	{ document = doc; }
++
++private:
++	TiXmlAttribute( const TiXmlAttribute& );				// not implemented.
++	void operator=( const TiXmlAttribute& base );	// not allowed.
++
++	TiXmlDocument*	document;	// A pointer back to a document, for error reporting.
++	TIXML_STRING name;
++	TIXML_STRING value;
++	TiXmlAttribute*	prev;
++	TiXmlAttribute*	next;
++};
++
++
++/*	A class used to manage a group of attributes.
++	It is only used internally, both by the ELEMENT and the DECLARATION.
++	
++	The set can be changed transparent to the Element and Declaration
++	classes that use it, but NOT transparent to the Attribute
++	which has to implement a next() and previous() method. Which makes
++	it a bit problematic and prevents the use of STL.
++
++	This version is implemented with circular lists because:
++		- I like circular lists
++		- it demonstrates some independence from the (typical) doubly linked list.
++*/
++class TiXmlAttributeSet
++{
++public:
++	TiXmlAttributeSet();
++	~TiXmlAttributeSet();
++
++	void Add( TiXmlAttribute* attribute );
++	void Remove( TiXmlAttribute* attribute );
++
++	TiXmlAttribute* First() const	{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
++	TiXmlAttribute* Last()  const	{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
++	TiXmlAttribute*	Find( const char * name ) const;
++
++private:
++	TiXmlAttribute sentinel;
++};
++
++
++/** The element is a container class. It has a value, the element name,
++	and can contain other elements, text, comments, and unknowns.
++	Elements also contain an arbitrary number of attributes.
++*/
++class TiXmlElement : public TiXmlNode
++{
++public:
++	/// Construct an element.
++	TiXmlElement (const char * in_value);
++
++	#ifdef TIXML_USE_STL
++	/// std::string constructor.
++	TiXmlElement( const std::string& _value );
++	#endif
++
++	TiXmlElement( const TiXmlElement& );
++
++	void operator=( const TiXmlElement& base );
++
++	virtual ~TiXmlElement();
++
++	/** Given an attribute name, Attribute() returns the value
++		for the attribute of that name, or null if none exists.
++	*/
++	const char* Attribute( const char* name ) const;
++
++	/** Given an attribute name, Attribute() returns the value
++		for the attribute of that name, or null if none exists.
++		If the attribute exists and can be converted to an integer,
++		the integer value will be put in the return 'i', if 'i'
++		is non-null.
++	*/
++	const char* Attribute( const char* name, int* i ) const;
++
++	/** Given an attribute name, Attribute() returns the value
++		for the attribute of that name, or null if none exists.
++		If the attribute exists and can be converted to an double,
++		the double value will be put in the return 'd', if 'd'
++		is non-null.
++	*/
++	const char* Attribute( const char* name, double* d ) const;
++
++	/** QueryIntAttribute examines the attribute - it is an alternative to the
++		Attribute() method with richer error checking.
++		If the attribute is an integer, it is stored in 'value' and 
++		the call returns TIXML_SUCCESS. If it is not
++		an integer, it returns TIXML_WRONG_TYPE. If the attribute
++		does not exist, then TIXML_NO_ATTRIBUTE is returned.
++	*/	
++	int QueryIntAttribute( const char* name, int* value ) const;
++	/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
++	int QueryDoubleAttribute( const char* name, double* value ) const;
++
++	/** Sets an attribute of name to a given value. The attribute
++		will be created if it does not exist, or changed if it does.
++	*/
++	void SetAttribute( const char* name, const char * value );
++
++    #ifdef TIXML_USE_STL
++	const char* Attribute( const std::string& name ) const				{ return Attribute( name.c_str() ); }
++	const char* Attribute( const std::string& name, int* i ) const		{ return Attribute( name.c_str(), i ); }
++	const char* Attribute( const std::string& name, double* d ) const	{ return Attribute( name.c_str(), d ); }
++	int QueryIntAttribute( const std::string& name, int* value ) const	{ return QueryIntAttribute( name.c_str(), value ); }
++	int QueryDoubleAttribute( const std::string& name, double* value ) const { return QueryDoubleAttribute( name.c_str(), value ); }
++
++	/// STL std::string form.
++	void SetAttribute( const std::string& name, const std::string& _value )	
++	{	
++		StringToBuffer n( name );
++		StringToBuffer v( _value );
++		if ( n.buffer && v.buffer )
++			SetAttribute (n.buffer, v.buffer );	
++	}	
++	///< STL std::string form.
++	void SetAttribute( const std::string& name, int _value )	
++	{	
++		StringToBuffer n( name );
++		if ( n.buffer )
++			SetAttribute (n.buffer, _value);	
++	}	
++	#endif
++
++	/** Sets an attribute of name to a given value. The attribute
++		will be created if it does not exist, or changed if it does.
++	*/
++	void SetAttribute( const char * name, int value );
++
++	/** Sets an attribute of name to a given value. The attribute
++		will be created if it does not exist, or changed if it does.
++	*/
++	void SetDoubleAttribute( const char * name, double value );
++
++	/** Deletes an attribute with the given name.
++	*/
++	void RemoveAttribute( const char * name );
++    #ifdef TIXML_USE_STL
++	void RemoveAttribute( const std::string& name )	{	RemoveAttribute (name.c_str ());	}	///< STL std::string form.
++	#endif
++
++	TiXmlAttribute* FirstAttribute() const	{ return attributeSet.First(); }		///< Access the first attribute in this element.
++	TiXmlAttribute* LastAttribute()	const 	{ return attributeSet.Last(); }		///< Access the last attribute in this element.
++
++	/// Creates a new Element and returns it - the returned element is a copy.
++	virtual TiXmlNode* Clone() const;
++	// Print the Element to a FILE stream.
++	virtual void Print( FILE* cfile, int depth ) const;
++
++	/*	Attribtue parsing starts: next char past '<'
++						 returns: next char past '>'
++	*/
++	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
++
++protected:
++
++	void CopyTo( TiXmlElement* target ) const;
++	void ClearThis();	// like clear, but initializes 'this' object as well
++
++	// Used to be public [internal use]
++	#ifdef TIXML_USE_STL
++	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
++	#endif
++	virtual void StreamOut( TIXML_OSTREAM * out ) const;
++
++	/*	[internal use]
++		Reads the "value" of the element -- another element, or text.
++		This should terminate with the current end tag.
++	*/
++	const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );
++
++private:
++
++	TiXmlAttributeSet attributeSet;
++};
++
++
++/**	An XML comment.
++*/
++class TiXmlComment : public TiXmlNode
++{
++public:
++	/// Constructs an empty comment.
++	TiXmlComment() : TiXmlNode( TiXmlNode::COMMENT ) {}
++	TiXmlComment( const TiXmlComment& );
++	void operator=( const TiXmlComment& base );
++
++	virtual ~TiXmlComment()	{}
++
++	/// Returns a copy of this Comment.
++	virtual TiXmlNode* Clone() const;
++	/// Write this Comment to a FILE stream.
++	virtual void Print( FILE* cfile, int depth ) const;
++
++	/*	Attribtue parsing starts: at the ! of the !--
++						 returns: next char past '>'
++	*/
++	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
++
++protected:
++	void CopyTo( TiXmlComment* target ) const;
++
++	// used to be public
++	#ifdef TIXML_USE_STL
++	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
++	#endif
++	virtual void StreamOut( TIXML_OSTREAM * out ) const;
++
++private:
++
++};
++
++
++/** XML text. Contained in an element.
++*/
++class TiXmlText : public TiXmlNode
++{
++	friend class TiXmlElement;
++public:
++	/// Constructor.
++	TiXmlText (const char * initValue) : TiXmlNode (TiXmlNode::TEXT)
++	{
++		SetValue( initValue );
++	}
++	virtual ~TiXmlText() {}
++
++	#ifdef TIXML_USE_STL
++	/// Constructor.
++	TiXmlText( const std::string& initValue ) : TiXmlNode (TiXmlNode::TEXT)
++	{
++		SetValue( initValue );
++	}
++	#endif
++
++	TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TEXT )	{ copy.CopyTo( this ); }
++	void operator=( const TiXmlText& base )							 	{ base.CopyTo( this ); }
++
++	/// Write this text object to a FILE stream.
++	virtual void Print( FILE* cfile, int depth ) const;
++
++	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
++
++protected :
++	///  [internal use] Creates a new Element and returns it.
++	virtual TiXmlNode* Clone() const;
++	void CopyTo( TiXmlText* target ) const;
++
++	virtual void StreamOut ( TIXML_OSTREAM * out ) const;
++	bool Blank() const;	// returns true if all white space and new lines
++	// [internal use]
++	#ifdef TIXML_USE_STL
++	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
++	#endif
++
++private:
++};
++
++
++/** In correct XML the declaration is the first entry in the file.
++	@verbatim
++		<?xml version="1.0" standalone="yes"?>
++	@endverbatim
++
++	TinyXml will happily read or write files without a declaration,
++	however. There are 3 possible attributes to the declaration:
++	version, encoding, and standalone.
++
++	Note: In this version of the code, the attributes are
++	handled as special cases, not generic attributes, simply
++	because there can only be at most 3 and they are always the same.
++*/
++class TiXmlDeclaration : public TiXmlNode
++{
++public:
++	/// Construct an empty declaration.
++	TiXmlDeclaration()   : TiXmlNode( TiXmlNode::DECLARATION ) {}
++
++#ifdef TIXML_USE_STL
++	/// Constructor.
++	TiXmlDeclaration(	const std::string& _version,
++						const std::string& _encoding,
++						const std::string& _standalone );
++#endif
++
++	/// Construct.
++	TiXmlDeclaration(	const char* _version,
++						const char* _encoding,
++						const char* _standalone );
++
++	TiXmlDeclaration( const TiXmlDeclaration& copy );
++	void operator=( const TiXmlDeclaration& copy );
++
++	virtual ~TiXmlDeclaration()	{}
++
++	/// Version. Will return an empty string if none was found.
++	const char *Version() const			{ return version.c_str (); }
++	/// Encoding. Will return an empty string if none was found.
++	const char *Encoding() const		{ return encoding.c_str (); }
++	/// Is this a standalone document?
++	const char *Standalone() const		{ return standalone.c_str (); }
++
++	/// Creates a copy of this Declaration and returns it.
++	virtual TiXmlNode* Clone() const;
++	/// Print this declaration to a FILE stream.
++	virtual void Print( FILE* cfile, int depth ) const;
++
++	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
++
++protected:
++	void CopyTo( TiXmlDeclaration* target ) const;
++	// used to be public
++	#ifdef TIXML_USE_STL
++	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
++	#endif
++	virtual void StreamOut ( TIXML_OSTREAM * out) const;
++
++private:
++
++	TIXML_STRING version;
++	TIXML_STRING encoding;
++	TIXML_STRING standalone;
++};
++
++
++/** Any tag that tinyXml doesn't recognize is saved as an
++	unknown. It is a tag of text, but should not be modified.
++	It will be written back to the XML, unchanged, when the file
++	is saved.
++
++	DTD tags get thrown into TiXmlUnknowns.
++*/
++class TiXmlUnknown : public TiXmlNode
++{
++public:
++	TiXmlUnknown() : TiXmlNode( TiXmlNode::UNKNOWN )	{}
++	virtual ~TiXmlUnknown() {}
++
++	TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::UNKNOWN )		{ copy.CopyTo( this ); }
++	void operator=( const TiXmlUnknown& copy )										{ copy.CopyTo( this ); }
++
++	/// Creates a copy of this Unknown and returns it.
++	virtual TiXmlNode* Clone() const;
++	/// Print this Unknown to a FILE stream.
++	virtual void Print( FILE* cfile, int depth ) const;
++
++	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
++
++protected:
++	void CopyTo( TiXmlUnknown* target ) const;
++
++	#ifdef TIXML_USE_STL
++	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
++	#endif
++	virtual void StreamOut ( TIXML_OSTREAM * out ) const;
++
++private:
++
++};
++
++
++/** Always the top level node. A document binds together all the
++	XML pieces. It can be saved, loaded, and printed to the screen.
++	The 'value' of a document node is the xml file name.
++*/
++class TiXmlDocument : public TiXmlNode
++{
++public:
++	/// Create an empty document, that has no name.
++	TiXmlDocument();
++	/// Create a document with a name. The name of the document is also the filename of the xml.
++	TiXmlDocument( const char * documentName );
++
++	#ifdef TIXML_USE_STL
++	/// Constructor.
++	TiXmlDocument( const std::string& documentName );
++	#endif
++
++	TiXmlDocument( const TiXmlDocument& copy );
++	void operator=( const TiXmlDocument& copy );
++
++	virtual ~TiXmlDocument() {}
++
++	/** Load a file using the current document value.
++		Returns true if successful. Will delete any existing
++		document data before loading.
++	*/
++	bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
++	/// Save a file using the current document value. Returns true if successful.
++	bool SaveFile() const;
++	/// Load a file using the given filename. Returns true if successful.
++	bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
++	/// Save a file using the given filename. Returns true if successful.
++	bool SaveFile( const char * filename ) const;
++
++	#ifdef TIXML_USE_STL
++	bool LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )			///< STL std::string version.
++	{
++		StringToBuffer f( filename );
++		return ( f.buffer && LoadFile( f.buffer, encoding ));
++	}
++	bool SaveFile( const std::string& filename ) const		///< STL std::string version.
++	{
++		StringToBuffer f( filename );
++		return ( f.buffer && SaveFile( f.buffer ));
++	}
++	#endif
++
++	/** Parse the given null terminated block of xml data. Passing in an encoding to this
++		method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml
++		to use that encoding, regardless of what TinyXml might otherwise try to detect.
++	*/
++	virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
++
++	/** Get the root element -- the only top level element -- of the document.
++		In well formed XML, there should only be one. TinyXml is tolerant of
++		multiple elements at the document level.
++	*/
++	TiXmlElement* RootElement() const		{ return FirstChildElement(); }
++
++	/** If an error occurs, Error will be set to true. Also,
++		- The ErrorId() will contain the integer identifier of the error (not generally useful)
++		- The ErrorDesc() method will return the name of the error. (very useful)
++		- The ErrorRow() and ErrorCol() will return the location of the error (if known)
++	*/	
++	bool Error() const						{ return error; }
++
++	/// Contains a textual (english) description of the error if one occurs.
++	const char * ErrorDesc() const	{ return errorDesc.c_str (); }
++
++	/** Generally, you probably want the error string ( ErrorDesc() ). But if you
++		prefer the ErrorId, this function will fetch it.
++	*/
++	const int ErrorId()	const				{ return errorId; }
++
++	/** Returns the location (if known) of the error. The first column is column 1, 
++		and the first row is row 1. A value of 0 means the row and column wasn't applicable
++		(memory errors, for example, have no row/column) or the parser lost the error. (An
++		error in the error reporting, in that case.)
++
++		@sa SetTabSize, Row, Column
++	*/
++	int ErrorRow()	{ return errorLocation.row+1; }
++	int ErrorCol()	{ return errorLocation.col+1; }	///< The column where the error occured. See ErrorRow()
++
++	/** By calling this method, with a tab size
++		greater than 0, the row and column of each node and attribute is stored
++		when the file is loaded. Very useful for tracking the DOM back in to
++		the source file.
++
++		The tab size is required for calculating the location of nodes. If not
++		set, the default of 4 is used. The tabsize is set per document. Setting
++		the tabsize to 0 disables row/column tracking.
++
++		Note that row and column tracking is not supported when using operator>>.
++
++		The tab size needs to be enabled before the parse or load. Correct usage:
++		@verbatim
++		TiXmlDocument doc;
++		doc.SetTabSize( 8 );
++		doc.Load( "myfile.xml" );
++		@endverbatim
++
++		@sa Row, Column
++	*/
++	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }
++
++	int TabSize() const	{ return tabsize; }
++
++	/** If you have handled the error, it can be reset with this call. The error
++		state is automatically cleared if you Parse a new XML block.
++	*/
++	void ClearError()						{	error = false; 
++												errorId = 0; 
++												errorDesc = ""; 
++												errorLocation.row = errorLocation.col = 0; 
++												//errorLocation.last = 0; 
++											}
++
++	/** Dump the document to standard out. */
++	void Print() const						{ Print( stdout, 0 ); }
++
++	/// Print this Document to a FILE stream.
++	virtual void Print( FILE* cfile, int depth = 0 ) const;
++	// [internal use]
++	void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );
++
++protected :
++	virtual void StreamOut ( TIXML_OSTREAM * out) const;
++	// [internal use]
++	virtual TiXmlNode* Clone() const;
++	#ifdef TIXML_USE_STL
++	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
++	#endif
++
++private:
++	void CopyTo( TiXmlDocument* target ) const;
++
++	bool error;
++	int  errorId;
++	TIXML_STRING errorDesc;
++	int tabsize;
++	TiXmlCursor errorLocation;
++};
++
++
++/**
++	A TiXmlHandle is a class that wraps a node pointer with null checks; this is
++	an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
++	DOM structure. It is a separate utility class.
++
++	Take an example:
++	@verbatim
++	<Document>
++		<Element attributeA = "valueA">
++			<Child attributeB = "value1" />
++			<Child attributeB = "value2" />
++		</Element>
++	<Document>
++	@endverbatim
++
++	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very 
++	easy to write a *lot* of code that looks like:
++
++	@verbatim
++	TiXmlElement* root = document.FirstChildElement( "Document" );
++	if ( root )
++	{
++		TiXmlElement* element = root->FirstChildElement( "Element" );
++		if ( element )
++		{
++			TiXmlElement* child = element->FirstChildElement( "Child" );
++			if ( child )
++			{
++				TiXmlElement* child2 = child->NextSiblingElement( "Child" );
++				if ( child2 )
++				{
++					// Finally do something useful.
++	@endverbatim
++
++	And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
++	of such code. A TiXmlHandle checks for null	pointers so it is perfectly safe 
++	and correct to use:
++
++	@verbatim
++	TiXmlHandle docHandle( &document );
++	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).Element();
++	if ( child2 )
++	{
++		// do something useful
++	@endverbatim
++
++	Which is MUCH more concise and useful.
++
++	It is also safe to copy handles - internally they are nothing more than node pointers.
++	@verbatim
++	TiXmlHandle handleCopy = handle;
++	@endverbatim
++
++	What they should not be used for is iteration:
++
++	@verbatim
++	int i=0; 
++	while ( true )
++	{
++		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).Element();
++		if ( !child )
++			break;
++		// do something
++		++i;
++	}
++	@endverbatim
++
++	It seems reasonable, but it is in fact two embedded while loops. The Child method is 
++	a linear walk to find the element, so this code would iterate much more than it needs 
++	to. Instead, prefer:
++
++	@verbatim
++	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).Element();
++
++	for( child; child; child=child->NextSiblingElement() )
++	{
++		// do something
++	}
++	@endverbatim
++*/
++class TiXmlHandle
++{
++public:
++	/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
++	TiXmlHandle( TiXmlNode* node )					{ this->node = node; }
++	/// Copy constructor
++	TiXmlHandle( const TiXmlHandle& ref )			{ this->node = ref.node; }
++	TiXmlHandle operator=( const TiXmlHandle& ref ) { this->node = ref.node; return *this; }
++
++	/// Return a handle to the first child node.
++	TiXmlHandle FirstChild() const;
++	/// Return a handle to the first child node with the given name.
++	TiXmlHandle FirstChild( const char * value ) const;
++	/// Return a handle to the first child element.
++	TiXmlHandle FirstChildElement() const;
++	/// Return a handle to the first child element with the given name.
++	TiXmlHandle FirstChildElement( const char * value ) const;
++
++	/** Return a handle to the "index" child with the given name. 
++		The first child is 0, the second 1, etc.
++	*/
++	TiXmlHandle Child( const char* value, int index ) const;
++	/** Return a handle to the "index" child. 
++		The first child is 0, the second 1, etc.
++	*/
++	TiXmlHandle Child( int index ) const;
++	/** Return a handle to the "index" child element with the given name. 
++		The first child element is 0, the second 1, etc. Note that only TiXmlElements
++		are indexed: other types are not counted.
++	*/
++	TiXmlHandle ChildElement( const char* value, int index ) const;
++	/** Return a handle to the "index" child element. 
++		The first child element is 0, the second 1, etc. Note that only TiXmlElements
++		are indexed: other types are not counted.
++	*/
++	TiXmlHandle ChildElement( int index ) const;
++
++	#ifdef TIXML_USE_STL
++	TiXmlHandle FirstChild( const std::string& _value ) const				{ return FirstChild( _value.c_str() ); }
++	TiXmlHandle FirstChildElement( const std::string& _value ) const		{ return FirstChildElement( _value.c_str() ); }
++
++	TiXmlHandle Child( const std::string& _value, int index ) const			{ return Child( _value.c_str(), index ); }
++	TiXmlHandle ChildElement( const std::string& _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
++	#endif
++
++	/// Return the handle as a TiXmlNode. This may return null.
++	TiXmlNode* Node() const			{ return node; } 
++	/// Return the handle as a TiXmlElement. This may return null.
++	TiXmlElement* Element() const	{ return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }
++	/// Return the handle as a TiXmlText. This may return null.
++	TiXmlText* Text() const			{ return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }
++	/// Return the handle as a TiXmlUnknown. This may return null;
++	TiXmlUnknown* Unknown() const			{ return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }
++
++private:
++	TiXmlNode* node;
++};
++
++
++#endif
++#endif /* SETUP */
+diff -ruNp vdr-1.6.0-2/tinyxmlparser.c vdr-1.6.0-2-setup-zulu-edition/tinyxmlparser.c
+--- vdr-1.6.0-2/tinyxmlparser.c	1970-01-01 01:00:00.000000000 +0100
++++ vdr-1.6.0-2-setup-zulu-edition/tinyxmlparser.c	2009-01-19 09:43:52.000000000 +0100
+@@ -0,0 +1,1494 @@
++#ifdef USE_SETUP
++/*
++www.sourceforge.net/projects/tinyxml
++Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
++
++This software is provided 'as-is', without any express or implied 
++warranty. In no event will the authors be held liable for any 
++damages arising from the use of this software.
++
++Permission is granted to anyone to use this software for any 
++purpose, including commercial applications, and to alter it and 
++redistribute it freely, subject to the following restrictions:
++
++1. The origin of this software must not be misrepresented; you must 
++not claim that you wrote the original software. If you use this
++software in a product, an acknowledgment in the product documentation
++would be appreciated but is not required.
++
++2. Altered source versions must be plainly marked as such, and 
++must not be misrepresented as being the original software.
++
++3. This notice may not be removed or altered from any source 
++distribution.
++*/
++
++#include "tinyxml.h"
++#include <ctype.h>
++
++//#define DEBUG_PARSER
++
++// Note tha "PutString" hardcodes the same list. This
++// is less flexible than it appears. Changing the entries
++// or order will break putstring.	
++TiXmlBase::Entity TiXmlBase::entity[ NUM_ENTITY ] = 
++{
++	{ "&amp;",  5, '&' },
++	{ "&lt;",   4, '<' },
++	{ "&gt;",   4, '>' },
++	{ "&quot;", 6, '\"' },
++	{ "&apos;", 6, '\'' }
++};
++
++// Bunch of unicode info at:
++//		http://www.unicode.org/faq/utf_bom.html
++// Including the basic of this table, which determines the #bytes in the
++// sequence from the lead byte. 1 placed for invalid sequences --
++// although the result will be junk, pass it through as much as possible.
++// Beware of the non-characters in UTF-8:	
++//				ef bb bf (Microsoft "lead bytes")
++//				ef bf be
++//				ef bf bf 
++
++
++
++const int TiXmlBase::utf8ByteTable[256] = 
++{
++	//	0	1	2	3	4	5	6	7	8	9	a	b	c	d	e	f
++		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x00
++		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x10
++		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x20
++		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x30
++		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x40
++		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x50
++		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x60
++		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x70	End of ASCII range
++		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x80 0x80 to 0xc1 invalid
++		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x90 
++		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xa0 
++		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xb0 
++		1,	1,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xc0 0xc2 to 0xdf 2 byte
++		2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xd0
++		3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	// 0xe0 0xe0 to 0xef 3 byte
++		4,	4,	4,	4,	4,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1	// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid
++};
++
++
++void TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
++{
++	const unsigned long BYTE_MASK = 0xBF;
++	const unsigned long BYTE_MARK = 0x80;
++	const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
++
++	if (input < 0x80) 
++		*length = 1;
++	else if ( input < 0x800 )
++		*length = 2;
++	else if ( input < 0x10000 )
++		*length = 3;
++	else if ( input < 0x200000 )
++		*length = 4;
++	else
++		{ *length = 0; return; }	// This code won't covert this correctly anyway.
++
++	output += *length;
++
++	// Scary scary fall throughs.
++	switch (*length) 
++	{
++		case 4:
++			--output; 
++			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
++			input >>= 6;
++		case 3:
++			--output; 
++			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
++			input >>= 6;
++		case 2:
++			--output; 
++			*output = (char)((input | BYTE_MARK) & BYTE_MASK); 
++			input >>= 6;
++		case 1:
++			--output; 
++			*output = (char)(input | FIRST_BYTE_MARK[*length]);
++	}
++}
++
++
++/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding encoding )
++{
++	// This will only work for low-ascii, everything else is assumed to be a valid
++	// letter. I'm not sure this is the best approach, but it is quite tricky trying
++	// to figure out alhabetical vs. not across encoding. So take a very 
++	// conservative approach.
++
++//	if ( encoding == TIXML_ENCODING_UTF8 )
++//	{
++		if ( anyByte < 127 )
++			return isalpha( anyByte );
++		else
++			return 1;	// What else to do? The unicode set is huge...get the english ones right.
++//	}
++//	else
++//	{
++//		return isalpha( anyByte );
++//	}
++}
++
++
++/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding )
++{
++	// This will only work for low-ascii, everything else is assumed to be a valid
++	// letter. I'm not sure this is the best approach, but it is quite tricky trying
++	// to figure out alhabetical vs. not across encoding. So take a very 
++	// conservative approach.
++
++//	if ( encoding == TIXML_ENCODING_UTF8 )
++//	{
++		if ( anyByte < 127 )
++			return isalnum( anyByte );
++		else
++			return 1;	// What else to do? The unicode set is huge...get the english ones right.
++//	}
++//	else
++//	{
++//		return isalnum( anyByte );
++//	}
++}
++
++
++class TiXmlParsingData
++{
++	friend class TiXmlDocument;
++  public:
++	void Stamp( const char* now, TiXmlEncoding encoding );
++
++	const TiXmlCursor& Cursor()	{ return cursor; }
++
++  private:
++	// Only used by the document!
++	TiXmlParsingData( const char* start, int _tabsize, int row, int col )
++	{
++		assert( start );
++		stamp = start;
++		tabsize = _tabsize;
++		cursor.row = row;
++		cursor.col = col;
++	}
++
++	TiXmlCursor		cursor;
++	const char*		stamp;
++	int				tabsize;
++};
++
++
++void TiXmlParsingData::Stamp( const char* now, TiXmlEncoding encoding )
++{
++	assert( now );
++
++	// Do nothing if the tabsize is 0.
++	if ( tabsize < 1 )
++	{
++		return;
++	}
++
++	// Get the current row, column.
++	int row = cursor.row;
++	int col = cursor.col;
++	const char* p = stamp;
++	assert( p );
++
++	while ( p < now )
++	{
++		// Code contributed by Fletcher Dunn: (modified by lee)
++		switch (*p) {
++			case 0:
++				// We *should* never get here, but in case we do, don't
++				// advance past the terminating null character, ever
++				return;
++
++			case '\r':
++				// bump down to the next line
++				++row;
++				col = 0;				
++				// Eat the character
++				++p;
++
++				// Check for \r\n sequence, and treat this as a single character
++				if (*p == '\n') {
++					++p;
++				}
++				break;
++
++			case '\n':
++				// bump down to the next line
++				++row;
++				col = 0;
++
++				// Eat the character
++				++p;
++
++				// Check for \n\r sequence, and treat this as a single
++				// character.  (Yes, this bizarre thing does occur still
++				// on some arcane platforms...)
++				if (*p == '\r') {
++					++p;
++				}
++				break;
++
++			case '\t':
++				// Eat the character
++				++p;
++
++				// Skip to next tab stop
++				col = (col / tabsize + 1) * tabsize;
++				break;
++
++			case (char)(0xef):
++				if ( encoding == TIXML_ENCODING_UTF8 )
++				{
++					if ( *(p+1) && *(p+2) )
++					{
++						// In these cases, don't advance the column. These are
++						// 0-width spaces.
++						if ( *(p+1)==(char)(0xbb) && *(p+2)==(char)(0xbf) )
++							p += 3;	
++						else if ( *(p+1)==(char)(0xbf) && *(p+2)==(char)(0xbe) )
++							p += 3;	
++						else if ( *(p+1)==(char)(0xbf) && *(p+2)==(char)(0xbf) )
++							p += 3;	
++						else
++							{ p +=3; ++col; }	// A normal character.
++					}
++				}
++				else
++				{
++					++p;
++					++col;
++				}
++				break;
++
++			default:
++				if ( encoding == TIXML_ENCODING_UTF8 )
++				{
++					// Eat the 1 to 4 byte utf8 character.
++					int step = TiXmlBase::utf8ByteTable[*((unsigned char*)p)];
++					if ( step == 0 )
++						step = 1;		// Error case from bad encoding, but handle gracefully.
++					p += step;
++
++					// Just advance one column, of course.
++					++col;
++				}
++				else
++				{
++					++p;
++					++col;
++				}
++				break;
++		}
++	}
++	cursor.row = row;
++	cursor.col = col;
++	assert( cursor.row >= -1 );
++	assert( cursor.col >= -1 );
++	stamp = p;
++	assert( stamp );
++}
++
++
++const char* TiXmlBase::SkipWhiteSpace( const char* p, TiXmlEncoding encoding )
++{
++	if ( !p || !*p )
++	{
++		return 0;
++	}
++	if ( encoding == TIXML_ENCODING_UTF8 )
++	{
++		while ( *p )
++		{
++			// Skip the stupid Microsoft UTF-8 Byte order marks
++			if (	*(p+0)==(char) 0xef 
++				 && *(p+1)==(char) 0xbb 
++				 && *(p+2)==(char) 0xbf )
++			{
++				p += 3;
++				continue;
++			}
++			else if(*(p+0)==(char) 0xef
++				 && *(p+1)==(char) 0xbf
++				 && *(p+2)==(char) 0xbe )
++			{
++				p += 3;
++				continue;
++			}
++			else if(*(p+0)==(char) 0xef
++				 && *(p+1)==(char) 0xbf
++				 && *(p+2)==(char) 0xbf )
++			{
++				p += 3;
++				continue;
++			}
++
++			if ( IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )		// Still using old rules for white space.
++				++p;
++			else
++				break;
++		}
++	}
++	else
++	{
++		while ( *p && IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )
++			++p;
++	}
++
++	return p;
++}
++
++#ifdef TIXML_USE_STL
++/*static*/ bool TiXmlBase::StreamWhiteSpace( TIXML_ISTREAM * in, TIXML_STRING * tag )
++{
++	for( ;; )
++	{
++		if ( !in->good() ) return false;
++
++		int c = in->peek();
++		// At this scope, we can't get to a document. So fail silently.
++		if ( !IsWhiteSpace( c ) || c <= 0 )
++			return true;
++
++		*tag += (char) in->get();
++	}
++}
++
++/*static*/ bool TiXmlBase::StreamTo( TIXML_ISTREAM * in, int character, TIXML_STRING * tag )
++{
++	//assert( character > 0 && character < 128 );	// else it won't work in utf-8
++	while ( in->good() )
++	{
++		int c = in->peek();
++		if ( c == character )
++			return true;
++		if ( c <= 0 )		// Silent failure: can't get document at this scope
++			return false;
++
++		in->get();
++		*tag += (char) c;
++	}
++	return false;
++}
++#endif
++
++const char* TiXmlBase::ReadName( const char* p, TIXML_STRING * name, TiXmlEncoding encoding )
++{
++	*name = "";
++	assert( p );
++
++	// Names start with letters or underscores.
++	// Of course, in unicode, tinyxml has no idea what a letter *is*. The
++	// algorithm is generous.
++	//
++	// After that, they can be letters, underscores, numbers,
++	// hyphens, or colons. (Colons are valid ony for namespaces,
++	// but tinyxml can't tell namespaces from names.)
++	if (    p && *p 
++		 && ( IsAlpha( (unsigned char) *p, encoding ) || *p == '_' ) )
++	{
++		while(		p && *p
++				&&	(		IsAlphaNum( (unsigned char ) *p, encoding ) 
++						 || *p == '_'
++						 || *p == '-'
++						 || *p == '.'
++						 || *p == ':' ) )
++		{
++			(*name) += *p;
++			++p;
++		}
++		return p;
++	}
++	return 0;
++}
++
++const char* TiXmlBase::GetEntity( const char* p, char* value, int* length, TiXmlEncoding encoding )
++{
++	// Presume an entity, and pull it out.
++    TIXML_STRING ent;
++	int i;
++	*length = 0;
++
++	if ( *(p+1) && *(p+1) == '#' && *(p+2) )
++	{
++		unsigned long ucs = 0;
++		unsigned delta = 0;
++		unsigned mult = 1;
++
++		if ( *(p+2) == 'x' )
++		{
++			// Hexadecimal.
++			if ( !*(p+3) ) return 0;
++
++			const char* q = p+3;
++			q = strchr( q, ';' );
++
++			if ( !q || !*q ) return 0;
++
++			delta = q-p;
++			--q;
++
++			while ( *q != 'x' )
++			{
++				if ( *q >= '0' && *q <= '9' )
++					ucs += mult * (*q - '0');
++				else if ( *q >= 'a' && *q <= 'f' )
++					ucs += mult * (*q - 'a' + 10);
++				else if ( *q >= 'A' && *q <= 'F' )
++					ucs += mult * (*q - 'A' + 10 );
++				else 
++					return 0;
++				mult *= 16;
++				--q;
++			}
++		}
++		else
++		{
++			// Decimal.
++			if ( !*(p+2) ) return 0;
++
++			const char* q = p+2;
++			q = strchr( q, ';' );
++
++			if ( !q || !*q ) return 0;
++
++			delta = q-p;
++			--q;
++
++			while ( *q != '#' )
++			{
++				if ( *q >= '0' && *q <= '9' )
++					ucs += mult * (*q - '0');
++				else 
++					return 0;
++				mult *= 10;
++				--q;
++			}
++		}
++		if ( encoding == TIXML_ENCODING_UTF8 )
++		{
++			// convert the UCS to UTF-8
++			ConvertUTF32ToUTF8( ucs, value, length );
++		}
++		else
++		{
++			*value = (char)ucs;
++			*length = 1;
++		}
++		return p + delta + 1;
++	}
++
++	// Now try to match it.
++	for( i=0; i<NUM_ENTITY; ++i )
++	{
++		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
++		{
++			assert( strlen( entity[i].str ) == entity[i].strLength );
++			*value = entity[i].chr;
++			*length = 1;
++			return ( p + entity[i].strLength );
++		}
++	}
++
++	// So it wasn't an entity, its unrecognized, or something like that.
++	*value = *p;	// Don't put back the last one, since we return it!
++	return p+1;
++}
++
++
++bool TiXmlBase::StringEqual( const char* p,
++							 const char* tag,
++							 bool ignoreCase,
++							 TiXmlEncoding encoding )
++{
++	assert( p );
++	assert( tag );
++	if ( !p || !*p )
++	{
++		assert( 0 );
++		return false;
++	}
++
++	const char* q = p;
++
++	if ( ignoreCase )
++	{
++		while ( *q && *tag && ToLower( *q, encoding ) == ToLower( *tag, encoding ) )
++		{
++			++q;
++			++tag;
++		}
++
++		if ( *tag == 0 )
++			return true;
++	}
++	else
++	{
++		while ( *q && *tag && *q == *tag )
++		{
++			++q;
++			++tag;
++		}
++
++		if ( *tag == 0 )		// Have we found the end of the tag, and everything equal?
++			return true;
++	}
++	return false;
++}
++
++const char* TiXmlBase::ReadText(	const char* p, 
++									TIXML_STRING * text, 
++									bool trimWhiteSpace, 
++									const char* endTag, 
++									bool caseInsensitive,
++									TiXmlEncoding encoding )
++{
++    *text = "";
++	if (    !trimWhiteSpace			// certain tags always keep whitespace
++		 || !condenseWhiteSpace )	// if true, whitespace is always kept
++	{
++		// Keep all the white space.
++		while (	   p && *p
++				&& !StringEqual( p, endTag, caseInsensitive, encoding )
++			  )
++		{
++			int len;
++			char cArr[4] = { 0, 0, 0, 0 };
++			p = GetChar( p, cArr, &len, encoding );
++			text->append( cArr, len );
++		}
++	}
++	else
++	{
++		bool whitespace = false;
++
++		// Remove leading white space:
++		p = SkipWhiteSpace( p, encoding );
++		while (	   p && *p
++				&& !StringEqual( p, endTag, caseInsensitive, encoding ) )
++		{
++			if ( *p == '\r' || *p == '\n' )
++			{
++				whitespace = true;
++				++p;
++			}
++			else if ( IsWhiteSpace( *p ) )
++			{
++				whitespace = true;
++				++p;
++			}
++			else
++			{
++				// If we've found whitespace, add it before the
++				// new character. Any whitespace just becomes a space.
++				if ( whitespace )
++				{
++					(*text) += ' ';
++					whitespace = false;
++				}
++				int len;
++				char cArr[4] = { 0, 0, 0, 0 };
++				p = GetChar( p, cArr, &len, encoding );
++				if ( len == 1 )
++					(*text) += cArr[0];	// more efficient
++				else
++					text->append( cArr, len );
++			}
++		}
++	}
++	return p + strlen( endTag );
++}
++
++#ifdef TIXML_USE_STL
++
++void TiXmlDocument::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
++{
++	// The basic issue with a document is that we don't know what we're
++	// streaming. Read something presumed to be a tag (and hope), then
++	// identify it, and call the appropriate stream method on the tag.
++	//
++	// This "pre-streaming" will never read the closing ">" so the
++	// sub-tag can orient itself.
++
++	if ( !StreamTo( in, '<', tag ) ) 
++	{
++		SetError( TIXML_ERROR_PARSING_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
++		return;
++	}
++
++	while ( in->good() )
++	{
++		int tagIndex = (int) tag->length();
++		while ( in->good() && in->peek() != '>' )
++		{
++			int c = in->get();
++			if ( c <= 0 )
++			{
++				SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
++				break;
++			}
++			(*tag) += (char) c;
++		}
++
++		if ( in->good() )
++		{
++			// We now have something we presume to be a node of 
++			// some sort. Identify it, and call the node to
++			// continue streaming.
++			TiXmlNode* node = Identify( tag->c_str() + tagIndex, TIXML_DEFAULT_ENCODING );
++
++			if ( node )
++			{
++				node->StreamIn( in, tag );
++				bool isElement = node->ToElement() != 0;
++				delete node;
++				node = 0;
++
++				// If this is the root element, we're done. Parsing will be
++				// done by the >> operator.
++				if ( isElement )
++				{
++					return;
++				}
++			}
++			else
++			{
++				SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
++				return;
++			}
++		}
++	}
++	// We should have returned sooner.
++	SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
++}
++
++#endif
++
++const char* TiXmlDocument::Parse( const char* p, TiXmlParsingData* prevData, TiXmlEncoding encoding )
++{
++	ClearError();
++
++	// Parse away, at the document level. Since a document
++	// contains nothing but other tags, most of what happens
++	// here is skipping white space.
++	if ( !p || !*p )
++	{
++		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
++		return 0;
++	}
++
++	// Note that, for a document, this needs to come
++	// before the while space skip, so that parsing
++	// starts from the pointer we are given.
++	location.Clear();
++	if ( prevData )
++	{
++		location.row = prevData->cursor.row;
++		location.col = prevData->cursor.col;
++	}
++	else
++	{
++		location.row = 0;
++		location.col = 0;
++	}
++	TiXmlParsingData data( p, TabSize(), location.row, location.col );
++	location = data.Cursor();
++
++	if ( encoding == TIXML_ENCODING_UNKNOWN )
++	{
++		// Check for the Microsoft UTF-8 lead bytes.
++		if (	*(p+0) && *(p+0) == (char)(0xef)
++			 && *(p+1) && *(p+1) == (char)(0xbb)
++			 && *(p+2) && *(p+2) == (char)(0xbf) )
++		{
++			encoding = TIXML_ENCODING_UTF8;
++		}
++	}
++
++    p = SkipWhiteSpace( p, encoding );
++	if ( !p )
++	{
++		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
++		return 0;
++	}
++
++	while ( p && *p )
++	{
++		TiXmlNode* node = Identify( p, encoding );
++		if ( node )
++		{
++			p = node->Parse( p, &data, encoding );
++			LinkEndChild( node );
++		}
++		else
++		{
++			break;
++		}
++
++		// Did we get encoding info?
++		if (    encoding == TIXML_ENCODING_UNKNOWN
++			 && node->ToDeclaration() )
++		{
++			TiXmlDeclaration* dec = node->ToDeclaration();
++			const char* enc = dec->Encoding();
++			assert( enc );
++
++			if ( *enc == 0 )
++				encoding = TIXML_ENCODING_UTF8;
++			else if ( StringEqual( enc, "UTF-8", true, TIXML_ENCODING_UNKNOWN ) )
++				encoding = TIXML_ENCODING_UTF8;
++			else if ( StringEqual( enc, "UTF8", true, TIXML_ENCODING_UNKNOWN ) )
++				encoding = TIXML_ENCODING_UTF8;	// incorrect, but be nice
++			else 
++				encoding = TIXML_ENCODING_LEGACY;
++		}
++
++		p = SkipWhiteSpace( p, encoding );
++	}
++
++	// All is well.
++	return p;
++}
++
++void TiXmlDocument::SetError( int err, const char* pError, TiXmlParsingData* data, TiXmlEncoding encoding )
++{	
++	// The first error in a chain is more accurate - don't set again!
++	if ( error )
++		return;
++
++	assert( err > 0 && err < TIXML_ERROR_STRING_COUNT );
++	error   = true;
++	errorId = err;
++	errorDesc = errorString[ errorId ];
++
++	errorLocation.Clear();
++	if ( pError && data )
++	{
++		//TiXmlParsingData data( pError, prevData );
++		data->Stamp( pError, encoding );
++		errorLocation = data->Cursor();
++	}
++}
++
++
++TiXmlNode* TiXmlNode::Identify( const char* p, TiXmlEncoding encoding )
++{
++	TiXmlNode* returnNode = 0;
++
++	p = SkipWhiteSpace( p, encoding );
++	if( !p || !*p || *p != '<' )
++	{
++		return 0;
++	}
++
++	TiXmlDocument* doc = GetDocument();
++	p = SkipWhiteSpace( p, encoding );
++
++	if ( !p || !*p )
++	{
++		return 0;
++	}
++
++	// What is this thing? 
++	// - Elements start with a letter or underscore, but xml is reserved.
++	// - Comments: <!--
++	// - Decleration: <?xml
++	// - Everthing else is unknown to tinyxml.
++	//
++
++	const char* xmlHeader = { "<?xml" };
++	const char* commentHeader = { "<!--" };
++	const char* dtdHeader = { "<!" };
++
++	if ( StringEqual( p, xmlHeader, true, encoding ) )
++	{
++		#ifdef DEBUG_PARSER
++			TIXML_LOG( "XML parsing Declaration\n" );
++		#endif
++		returnNode = new TiXmlDeclaration();
++	}
++	else if ( StringEqual( p, commentHeader, false, encoding ) )
++	{
++		#ifdef DEBUG_PARSER
++			TIXML_LOG( "XML parsing Comment\n" );
++		#endif
++		returnNode = new TiXmlComment();
++	}
++	else if ( StringEqual( p, dtdHeader, false, encoding ) )
++	{
++		#ifdef DEBUG_PARSER
++			TIXML_LOG( "XML parsing Unknown(1)\n" );
++		#endif
++		returnNode = new TiXmlUnknown();
++	}
++	else if (    IsAlpha( *(p+1), encoding )
++			  || *(p+1) == '_' )
++	{
++		#ifdef DEBUG_PARSER
++			TIXML_LOG( "XML parsing Element\n" );
++		#endif
++		returnNode = new TiXmlElement( "" );
++	}
++	else
++	{
++		#ifdef DEBUG_PARSER
++			TIXML_LOG( "XML parsing Unknown(2)\n" );
++		#endif
++		returnNode = new TiXmlUnknown();
++	}
++
++	if ( returnNode )
++	{
++		// Set the parent, so it can report errors
++		returnNode->parent = this;
++	}
++	else
++	{
++		if ( doc )
++			doc->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
++	}
++	return returnNode;
++}
++
++#ifdef TIXML_USE_STL
++
++void TiXmlElement::StreamIn (TIXML_ISTREAM * in, TIXML_STRING * tag)
++{
++	// We're called with some amount of pre-parsing. That is, some of "this"
++	// element is in "tag". Go ahead and stream to the closing ">"
++	while( in->good() )
++	{
++		int c = in->get();
++		if ( c <= 0 )
++		{
++			TiXmlDocument* document = GetDocument();
++			if ( document )
++				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
++			return;
++		}
++		(*tag) += (char) c ;
++		
++		if ( c == '>' )
++			break;
++	}
++
++	if ( tag->length() < 3 ) return;
++
++	// Okay...if we are a "/>" tag, then we're done. We've read a complete tag.
++	// If not, identify and stream.
++
++	if (    tag->at( tag->length() - 1 ) == '>' 
++		 && tag->at( tag->length() - 2 ) == '/' )
++	{
++		// All good!
++		return;
++	}
++	else if ( tag->at( tag->length() - 1 ) == '>' )
++	{
++		// There is more. Could be:
++		//		text
++		//		closing tag
++		//		another node.
++		for ( ;; )
++		{
++			StreamWhiteSpace( in, tag );
++
++			// Do we have text?
++			if ( in->good() && in->peek() != '<' ) 
++			{
++				// Yep, text.
++				TiXmlText text( "" );
++				text.StreamIn( in, tag );
++
++				// What follows text is a closing tag or another node.
++				// Go around again and figure it out.
++				continue;
++			}
++
++			// We now have either a closing tag...or another node.
++			// We should be at a "<", regardless.
++			if ( !in->good() ) return;
++			assert( in->peek() == '<' );
++			int tagIndex = tag->length();
++
++			bool closingTag = false;
++			bool firstCharFound = false;
++
++			for( ;; )
++			{
++				if ( !in->good() )
++					return;
++
++				int c = in->peek();
++				if ( c <= 0 )
++				{
++					TiXmlDocument* document = GetDocument();
++					if ( document )
++						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
++					return;
++				}
++				
++				if ( c == '>' )
++					break;
++
++				*tag += (char) c;
++				in->get();
++
++				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
++				{
++					firstCharFound = true;
++					if ( c == '/' )
++						closingTag = true;
++				}
++			}
++			// If it was a closing tag, then read in the closing '>' to clean up the input stream.
++			// If it was not, the streaming will be done by the tag.
++			if ( closingTag )
++			{
++				if ( !in->good() )
++					return;
++
++				int c = in->get();
++				if ( c <= 0 )
++				{
++					TiXmlDocument* document = GetDocument();
++					if ( document )
++						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
++					return;
++				}
++				assert( c == '>' );
++				*tag += (char) c;
++
++				// We are done, once we've found our closing tag.
++				return;
++			}
++			else
++			{
++				// If not a closing tag, id it, and stream.
++				const char* tagloc = tag->c_str() + tagIndex;
++				TiXmlNode* node = Identify( tagloc, TIXML_DEFAULT_ENCODING );
++				if ( !node )
++					return;
++				node->StreamIn( in, tag );
++				delete node;
++				node = 0;
++
++				// No return: go around from the beginning: text, closing tag, or node.
++			}
++		}
++	}
++}
++#endif
++
++const char* TiXmlElement::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
++{
++	p = SkipWhiteSpace( p, encoding );
++	TiXmlDocument* document = GetDocument();
++
++	if ( !p || !*p )
++	{
++		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0, encoding );
++		return 0;
++	}
++
++//	TiXmlParsingData data( p, prevData );
++	if ( data )
++	{
++		data->Stamp( p, encoding );
++		location = data->Cursor();
++	}
++
++	if ( *p != '<' )
++	{
++		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data, encoding );
++		return 0;
++	}
++
++	p = SkipWhiteSpace( p+1, encoding );
++
++	// Read the name.
++	const char* pErr = p;
++
++    p = ReadName( p, &value, encoding );
++	if ( !p || !*p )
++	{
++		if ( document )	document->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data, encoding );
++		return 0;
++	}
++
++    TIXML_STRING endTag ("</");
++	endTag += value;
++	endTag += ">";
++
++	// Check for and read attributes. Also look for an empty
++	// tag or an end tag.
++	while ( p && *p )
++	{
++		pErr = p;
++		p = SkipWhiteSpace( p, encoding );
++		if ( !p || !*p )
++		{
++			if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
++			return 0;
++		}
++		if ( *p == '/' )
++		{
++			++p;
++			// Empty tag.
++			if ( *p  != '>' )
++			{
++				if ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data, encoding );		
++				return 0;
++			}
++			return (p+1);
++		}
++		else if ( *p == '>' )
++		{
++			// Done with attributes (if there were any.)
++			// Read the value -- which can include other
++			// elements -- read the end tag, and return.
++			++p;
++			p = ReadValue( p, data, encoding );		// Note this is an Element method, and will set the error if one happens.
++			if ( !p || !*p )
++				return 0;
++
++			// We should find the end tag now
++			if ( StringEqual( p, endTag.c_str(), false, encoding ) )
++			{
++				p += endTag.length();
++				return p;
++			}
++			else
++			{
++				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
++				return 0;
++			}
++		}
++		else
++		{
++			// Try to read an attribute:
++			TiXmlAttribute* attrib = new TiXmlAttribute();
++			if ( !attrib )
++			{
++				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, pErr, data, encoding );
++				return 0;
++			}
++
++			attrib->SetDocument( document );
++			const char* pErr = p;
++			p = attrib->Parse( p, data, encoding );
++
++			if ( !p || !*p )
++			{
++				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
++				delete attrib;
++				return 0;
++			}
++
++			// Handle the strange case of double attributes:
++			TiXmlAttribute* node = attributeSet.Find( attrib->Name() );
++			if ( node )
++			{
++				node->SetValue( attrib->Value() );
++				delete attrib;
++				return 0;
++			}
++
++			attributeSet.Add( attrib );
++		}
++	}
++	return p;
++}
++
++
++const char* TiXmlElement::ReadValue( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
++{
++	TiXmlDocument* document = GetDocument();
++
++	const char* pWithWhiteSpace = p;
++	// Read in text and elements in any order.
++	p = SkipWhiteSpace( p, encoding );
++	while ( p && *p )
++	{
++		if ( *p != '<' )
++		{
++			// Take what we have, make a text element.
++			TiXmlText* textNode = new TiXmlText( "" );
++
++			if ( !textNode )
++			{
++				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, encoding );
++				    return 0;
++			}
++
++			if ( TiXmlBase::IsWhiteSpaceCondensed() )
++			{
++				p = textNode->Parse( p, data, encoding );
++			}
++			else
++			{
++				// Special case: we want to keep the white space
++				// so that leading spaces aren't removed.
++				p = textNode->Parse( pWithWhiteSpace, data, encoding );
++			}
++
++			if ( !textNode->Blank() )
++				LinkEndChild( textNode );
++			else
++				delete textNode;
++		} 
++		else 
++		{
++			// We hit a '<'
++			// Have we hit a new element or an end tag?
++			if ( StringEqual( p, "</", false, encoding ) )
++			{
++				return p;
++			}
++			else
++			{
++				TiXmlNode* node = Identify( p, encoding );
++				if ( node )
++				{
++					p = node->Parse( p, data, encoding );
++					LinkEndChild( node );
++				}				
++				else
++				{
++					return 0;
++				}
++			}
++		}
++		p = SkipWhiteSpace( p, encoding );
++	}
++
++	if ( !p )
++	{
++		if ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0, encoding );
++	}	
++	return p;
++}
++
++
++#ifdef TIXML_USE_STL
++void TiXmlUnknown::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
++{
++	while ( in->good() )
++	{
++		int c = in->get();	
++		if ( c <= 0 )
++		{
++			TiXmlDocument* document = GetDocument();
++			if ( document )
++				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
++			return;
++		}
++		(*tag) += (char) c;
++
++		if ( c == '>' )
++		{
++			// All is well.
++			return;		
++		}
++	}
++}
++#endif
++
++
++const char* TiXmlUnknown::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
++{
++	TiXmlDocument* document = GetDocument();
++	p = SkipWhiteSpace( p, encoding );
++
++//	TiXmlParsingData data( p, prevData );
++	if ( data )
++	{
++		data->Stamp( p, encoding );
++		location = data->Cursor();
++	}
++	if ( !p || !*p || *p != '<' )
++	{
++		if ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data, encoding );
++		return 0;
++	}
++	++p;
++    value = "";
++
++	while ( p && *p && *p != '>' )
++	{
++		value += *p;
++		++p;
++	}
++
++	if ( !p )
++	{
++		if ( document )	document->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0, encoding );
++	}
++	if ( *p == '>' )
++		return p+1;
++	return p;
++}
++
++#ifdef TIXML_USE_STL
++void TiXmlComment::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
++{
++	while ( in->good() )
++	{
++		int c = in->get();	
++		if ( c <= 0 )
++		{
++			TiXmlDocument* document = GetDocument();
++			if ( document )
++				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
++			return;
++		}
++
++		(*tag) += (char) c;
++
++		if ( c == '>' 
++			 && tag->at( tag->length() - 2 ) == '-'
++			 && tag->at( tag->length() - 3 ) == '-' )
++		{
++			// All is well.
++			return;		
++		}
++	}
++}
++#endif
++
++
++const char* TiXmlComment::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
++{
++	TiXmlDocument* document = GetDocument();
++	value = "";
++
++	p = SkipWhiteSpace( p, encoding );
++
++//	TiXmlParsingData data( p, prevData );
++	if ( data )
++	{
++		data->Stamp( p, encoding );
++		location = data->Cursor();
++	}
++	const char* startTag = "<!--";
++	const char* endTag   = "-->";
++
++	if ( !StringEqual( p, startTag, false, encoding ) )
++	{
++		document->SetError( TIXML_ERROR_PARSING_COMMENT, p, data, encoding );
++		return 0;
++	}
++	p += strlen( startTag );
++	p = ReadText( p, &value, false, endTag, false, encoding );
++	return p;
++}
++
++
++const char* TiXmlAttribute::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
++{
++	p = SkipWhiteSpace( p, encoding );
++	if ( !p || !*p ) return 0;
++
++	int tabsize = 4;
++	if ( document )
++		tabsize = document->TabSize();
++
++//	TiXmlParsingData data( p, prevData );
++	if ( data )
++	{
++		data->Stamp( p, encoding );
++		location = data->Cursor();
++	}
++	// Read the name, the '=' and the value.
++	const char* pErr = p;
++	p = ReadName( p, &name, encoding );
++	if ( !p || !*p )
++	{
++		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
++		return 0;
++	}
++	p = SkipWhiteSpace( p, encoding );
++	if ( !p || !*p || *p != '=' )
++	{
++		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
++		return 0;
++	}
++
++	++p;	// skip '='
++	p = SkipWhiteSpace( p, encoding );
++	if ( !p || !*p )
++	{
++		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
++		return 0;
++	}
++	
++	const char* end;
++
++	if ( *p == '\'' )
++	{
++		++p;
++		end = "\'";
++		p = ReadText( p, &value, false, end, false, encoding );
++	}
++	else if ( *p == '"' )
++	{
++		++p;
++		end = "\"";
++		p = ReadText( p, &value, false, end, false, encoding );
++	}
++	else
++	{
++		// All attribute values should be in single or double quotes.
++		// But this is such a common error that the parser will try
++		// its best, even without them.
++		value = "";
++		while (    p && *p										// existence
++				&& !IsWhiteSpace( *p ) && *p != '\n' && *p != '\r'	// whitespace
++				&& *p != '/' && *p != '>' )						// tag end
++		{
++			value += *p;
++			++p;
++		}
++	}
++	return p;
++}
++
++#ifdef TIXML_USE_STL
++void TiXmlText::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
++{
++	while ( in->good() )
++	{
++		int c = in->peek();	
++		if ( c == '<' )
++			return;
++		if ( c <= 0 )
++		{
++			TiXmlDocument* document = GetDocument();
++			if ( document )
++				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
++			return;
++		}
++
++		(*tag) += (char) c;
++		in->get();
++	}
++}
++#endif
++
++const char* TiXmlText::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
++{
++	value = "";
++//	TiXmlParsingData data( p, prevData );
++	if ( data )
++	{
++		data->Stamp( p, encoding );
++		location = data->Cursor();
++	}
++	bool ignoreWhite = true;
++
++	const char* end = "<";
++	p = ReadText( p, &value, ignoreWhite, end, false, encoding );
++	if ( p )
++		return p-1;	// don't truncate the '<'
++	return 0;
++}
++
++#ifdef TIXML_USE_STL
++void TiXmlDeclaration::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
++{
++	while ( in->good() )
++	{
++		int c = in->get();
++		if ( c <= 0 )
++		{
++			TiXmlDocument* document = GetDocument();
++			if ( document )
++				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
++			return;
++		}
++		(*tag) += (char) c;
++
++		if ( c == '>' )
++		{
++			// All is well.
++			return;
++		}
++	}
++}
++#endif
++
++const char* TiXmlDeclaration::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )
++{
++	p = SkipWhiteSpace( p, _encoding );
++	// Find the beginning, find the end, and look for
++	// the stuff in-between.
++	TiXmlDocument* document = GetDocument();
++	if ( !p || !*p || !StringEqual( p, "<?xml", true, _encoding ) )
++	{
++		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );
++		return 0;
++	}
++//	TiXmlParsingData data( p, prevData );
++	if ( data )
++	{
++		data->Stamp( p, _encoding );
++		location = data->Cursor();
++	}
++	p += 5;
++
++	version = "";
++	encoding = "";
++	standalone = "";
++
++	while ( p && *p )
++	{
++		if ( *p == '>' )
++		{
++			++p;
++			return p;
++		}
++
++		p = SkipWhiteSpace( p, _encoding );
++		if ( StringEqual( p, "version", true, _encoding ) )
++		{
++			TiXmlAttribute attrib;
++			p = attrib.Parse( p, data, _encoding );		
++			version = attrib.Value();
++		}
++		else if ( StringEqual( p, "encoding", true, _encoding ) )
++		{
++			TiXmlAttribute attrib;
++			p = attrib.Parse( p, data, _encoding );		
++			encoding = attrib.Value();
++		}
++		else if ( StringEqual( p, "standalone", true, _encoding ) )
++		{
++			TiXmlAttribute attrib;
++			p = attrib.Parse( p, data, _encoding );		
++			standalone = attrib.Value();
++		}
++		else
++		{
++			// Read over whatever it is.
++			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )
++				++p;
++		}
++	}
++	return 0;
++}
++
++bool TiXmlText::Blank() const
++{
++	for ( unsigned i=0; i<value.length(); i++ )
++		if ( !IsWhiteSpace( value[i] ) )
++			return false;
++	return true;
++}
++#endif /* SETUP */
Index: vdr-2.2.0/PLUGINS/src/setup/plugins.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/plugins.c	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,427 @@
+/****************************************************************************
+ * DESCRIPTION: 
+ *             Plugin Representation of XML Tree
+ *
+ * $Id: plugins.cpp,v 1.7 2005/10/12 13:44:14 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ ****************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include "vdr/plugin.h"
+#include "plugins.h"
+#include "util.h"
+#include "debug.h"
+
+
+/**
+ * Construktor
+ * @return empty Plugins Object
+ */
+Plugins::Plugins()
+{
+    _activePlugins = NULL;
+    _sysconfigName = Util::Strdupnew("PLUGINLIST");
+}
+
+
+/**
+ * Destructor
+ * @return 
+ */
+Plugins::~Plugins()
+{
+    delete [] _activePlugins;
+    delete [] _sysconfigName;
+}
+
+//---------------------------------------------
+/**
+ * Add the given Plugin to the List of Plugins
+ * @param name name of plugin
+ * @param param parameters for plugin, could null if not available
+ * @param info description of plugin
+ * @param flag active flag
+ * @param protected true if entry is protected
+ * @param inSystem true if active in System
+ */
+void Plugins::AddPlugin(const char*name, const char*param, const char*info, bool flag,
+                  bool protect, bool inSystem)
+{
+    Plugin *p = new Plugin;
+
+    p->SetName(name);
+    p->SetParameter(param);
+    p->SetInfo(info);
+    p->SetActive(flag);
+    p->SetProtect(protect);
+    p->SetInSystem(inSystem);
+    Add(p);
+}
+
+
+
+/**
+ * Move elemnt in plugin list to specified position
+ * @param index   index of element to move
+ * @param toindex index to insert
+ * @param where After or before the given position
+ */
+void Plugins::MovePlugin( int index, int toindex, enum Where where)
+{
+    int nr=Count();
+    if(index<0   || index   > nr ||  // invalid index is ignored
+       toindex<0 || toindex > nr)
+        return;
+
+    if( index > toindex)
+    {
+       if( where == BEHIND)
+         toindex++;
+       Move(index, toindex);
+    }
+    else
+     if( index <toindex)
+     {
+       if( where == BEFORE)
+         toindex--;
+       Move(index, toindex);
+     }
+}
+
+
+/**
+ * Sort the Pplugins
+ * @param order specifies the direction of sorting
+ */
+void Plugins::Sort( enum Order order)
+{
+ int nr= Count();
+    if(order==ASC)
+    {
+
+        // Bubble up i'th record
+        for (int i = 0; i < nr-1; i++)
+            for (int j = nr-1; j > i; j--)
+            {
+                if ( *Get(j) > *Get(j-1) )
+                    Move(j, j-1 );
+            }
+    }
+    else
+    {
+        for (int i = 0; i < nr-1; i++)
+            for (int j = nr-1; j > i; j--)
+            {
+                if( *Get(j) < *Get(j-1) )
+                    Move(j, j-1 );
+            }
+    }
+
+}
+
+
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+const char * Plugin::_trueStr ="yes";
+const char * Plugin::_falseStr = "no";
+
+/**
+ * Constructor 
+ * @return 
+ */
+Plugin::Plugin()
+{
+    _name=NULL;
+    _info=NULL;
+    _parameter=NULL;
+    _active=false;
+    _inSystem=false;
+    _protect = false;
+}
+
+/**
+ * Destructor
+ * @return 
+ */
+Plugin::~Plugin()
+{
+  delete []_name;
+  delete []_info;
+  delete []_parameter;
+}
+
+/**
+ * Overload operator < to compare Plugins
+
+ * @param param the Plugin to compare
+ * @return true if name of left plugin is less the right plugin
+ */
+bool Plugin::operator <( Plugin &param )
+{
+    if(strcmp(_info, param._info)<0)
+        return(true);
+    else
+        return(false);
+}
+
+/**
+ * Overload operator > to compare Plugins
+
+ * @param param the Plugin to compare
+ * @return true if name of left plugin is greater the right plugin
+ */
+bool Plugin::operator >( Plugin &param )
+{
+    if(strcmp(_info, param._info)>0)
+        return(true);
+    else
+        return(false);
+}
+
+
+/**
+ * Set the name of the plugin
+ * @param nam value to store
+ */
+void Plugin::SetName(const char* nam)
+{
+    delete []_name;
+    _name= Util::Strdupnew(nam);
+}
+
+/**
+ * Set the description of the plugin
+ * @param inf description to be set
+ */
+void Plugin::SetInfo(const char* inf)
+{
+   delete []_info;
+   _info= Util::Strdupnew(inf);
+}
+
+//---------------------------------------------
+/**
+ * get the number of registerted Plugins
+ * @return number of plugins stored
+ */
+int Plugins::GetNr()
+{
+    return(Count());
+}
+
+/**
+ * Prints the Plugins on stdout
+ */
+void  Plugins::Print()
+{
+    int nr = Count();
+    for(int i=0; i<nr; i++)
+    {
+        printf("Plugin[%d] ", i);
+        Get(i)->Print();
+    }
+}
+
+
+/**
+ * Prints a plugin on stdout
+ */
+void  Plugin::Print()
+{
+    printf("Name=%s  Parameter=%s Info=%s Active=%d inSystem=%d\n",
+            _name, _parameter, _info, _active, _inSystem);
+}
+void Plugins::SetSysconfigName( const char * name )
+{
+  delete [] _sysconfigName;
+  _sysconfigName =  Util::Strdupnew(name);
+}
+
+const char * Plugins::GetSysconfigName( )
+{
+ return(_sysconfigName);
+}
+
+
+
+
+/**
+ * retrieves the name of the plugin
+ * @return the name
+ */
+const char* Plugin::GetName()
+{
+    return(_name);
+}
+/**
+ * retrieves the description of the plugin
+ * @return description
+ */
+const char* Plugin::GetInfo()
+{
+    return(_info);
+}
+/**
+ * get plugin parameters
+ * @return plugin parameters or null if none available
+ */
+const char * Plugin::Plugin::GetParameter( )
+{
+  return(_parameter);
+}
+
+/**
+ * set plugin command parameters 
+ * @param p NULL or plugin parameter string
+ */
+void Plugin::Plugin::SetParameter( const char * p )
+{
+  delete [] _parameter;
+  _parameter = Util::Strdupnew(p);
+}
+
+/**
+ * Set Active State
+ * @param flag true if plugin is active
+ */
+void Plugin::Plugin::SetActive( int flag )
+{
+ _active=flag;
+}
+
+/**
+ * get Active State of plugin
+ * @return true if active
+ */
+int Plugin::Plugin::GetActive( )
+{
+  return(_active);
+}
+/**
+ * Set Flag if Plugin is in System
+ * @param flag true if plugin is active
+ */
+void Plugin::Plugin::SetInSystem( bool flag )
+{
+ _inSystem=flag;
+}
+
+/**
+ * get Flag if Plugin is in System
+ * @return true if active
+ */
+bool Plugin::Plugin::GetInSystem( )
+{
+  return(_inSystem);
+}
+
+/**
+ * get Active State of plugin as String value
+ * @return true if active
+ */
+const char* Plugin::Plugin::GetActiveString( )
+{
+  if(_active)
+    return(_trueStr);
+  else
+    return(_falseStr);
+}
+
+
+
+/**
+ * get regerence to active State
+ * @return poiinter to active State
+ */
+int * Plugin::Plugin::GetActiveRef( )
+{
+  return(&_active);
+}
+
+void Plugin::Plugin::SetProtect( bool protect )
+{
+  _protect = protect;
+}
+
+bool Plugin::Plugin::GetProtect( )
+{
+  return(_protect);
+}
+
+
+
+
+/**
+ * returns a String holding space separated List of plugins
+ * @return 
+ */
+const char * Plugins::GetActivePlugins( )
+{
+  char buf[2000];
+  buf[0] = '\0';
+  int  nr =Count();
+  
+  for(int i=0; i<nr; i++)
+  {
+    Plugin * plugin = Get(i);
+    if(plugin->GetActive() && plugin->GetInSystem() )
+    {
+      const char *p = plugin->GetParameter();
+      if( p == NULL)
+        sprintf(buf, "%s \\\"-P%s \\\"", buf,  plugin->GetName());
+      else
+        sprintf(buf, "%s \\\"-P%s %s\\\"", buf, plugin->GetName(), p);
+    }
+  }
+  if( _activePlugins != NULL)
+    delete [] _activePlugins;
+    
+  _activePlugins = new char[strlen(buf)+1];
+  strcpy(_activePlugins, buf);
+  return((const char*) _activePlugins);
+}
+
+/**
+ * Sets the flag "inSystem" of the corresponding plugin to true.
+ * If the plugin is not found an unknown Plugin will be added.
+ * @param pluginName 
+ */
+void Plugins::SetLibDirPlugin( const char * pluginName )
+{
+  Plugin *p =GetPluginByName(pluginName);
+  if( p != NULL)
+  { 
+    p->SetInSystem(true);
+  }
+  else
+  {
+    AddPlugin(pluginName,NULL,  pluginName, false, false, true);
+  }
+ 
+}
+
+/**
+ * returns a pointer to the plugin with the specified name
+ * or NULL if not found
+ * @param name of the plugin 
+ * @return pointer to plugin otherwise NULL
+ */
+Plugin * Plugins::GetPluginByName( const char * name )
+{
+  Plugin *p=NULL;
+  int nr = Count();
+ 
+  for(int i=0; i<nr && p==NULL; i++)
+  { 
+   if( strcmp(Get(i)->GetName(),name)==0)
+      p= Get(i);
+  }
+  return(p);
+}
+
+
Index: vdr-2.2.0/PLUGINS/src/setup/plugins.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/plugins.h	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,82 @@
+/*********************************************************
+ * DESCRIPTION: 
+ *             Header File
+ *
+ * $Id: plugins.h,v 1.5 2005/10/12 13:44:14 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de        
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ *********************************************************/
+
+#ifndef PLUGINS_H
+#define PLUGINS_H
+#include <vdr/tools.h>
+
+/**
+@author Ralf Dotzert
+*/
+class Plugin :  public cListObject
+{
+private:
+static const char * _trueStr;
+static const char * _falseStr;
+const char * _name;
+const char * _info;
+const char * _parameter;
+int   _active;
+bool  _inSystem;
+bool  _protect;
+public:
+    Plugin();
+    ~Plugin();
+    bool operator< (Plugin &param);
+    bool operator> (Plugin &param);
+    void Print();
+    const char* GetName();
+    const char* GetInfo();
+    const char* GetParameter();
+    void SetName(const char* name);
+    void SetInfo(const char* info);
+    void SetParameter(const char* parameter);
+    void SetActive(int flag);
+    void SetProtect(bool protect);
+    int  GetActive();
+    int  *GetActiveRef();
+    void SetInSystem(bool flag);
+    bool GetInSystem();
+    bool GetProtect();
+    const char* GetActiveString();
+};
+
+class Plugins  : public cList<Plugin> 
+{
+private:
+const char  *_sysconfigName;
+char        *_activePlugins;
+public:
+   
+    Plugins();
+    ~Plugins();
+    enum Order { ASC, DESC};
+    enum Where { BEFORE, BEHIND};
+    int  GetNr();
+    void AddPlugin(const char*name, const char*parameter,  const char*info, bool active,
+                   bool protect, bool inSystem=false );
+    void SetSysconfigName(const char *name);
+    const char *GetSysconfigName();
+    Plugin *GetPluginByName(const char*name);
+
+    void MovePlugin(int index, int toindex, enum Where);
+    void Sort( enum Order order);
+    const char *GetActivePlugins();
+    void SetLibDirPlugin(const char* pluginName);
+    void Print();
+
+};
+
+   
+
+
+
+#endif
Index: vdr-2.2.0/PLUGINS/src/setup/po/ca_ES.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/ca_ES.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,135 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Marc Rovira Vall <tm05462@salleURL.edu>, 2003
+# Ramon Roca <ramon.roca@xcombo.com>, 2003
+# Jordi Vil <jvila@tinet.org>, 2003
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Jordi Vil <jvila@tinet.org>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-1\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Configuraci"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Editar"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Editar"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Editar"
+
+msgid "Delete"
+msgstr "Esborrar"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/cs_CZ.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/cs_CZ.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,133 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Vladimr Brta <vladimir.barta@k2atmitec.cz>, 2006
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Vladimr Brta <vladimir.barta@k2atmitec.cz>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-2\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Nastaven"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Editace"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Editace"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Editace"
+
+msgid "Delete"
+msgstr "Smazat"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/da_DK.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/da_DK.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,133 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Mogens Elneff <mogens@elneff.dk>, 2004
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Mogens Elneff <mogens@elneff.dk>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-15\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Indstillinger"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Rediger"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Rediger"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Rediger"
+
+msgid "Delete"
+msgstr "Slet"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/de_DE.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/de_DE.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,131 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Klaus Schmidinger <kls@cadsoft.de>, 2000
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Klaus Schmidinger <kls@cadsoft.de>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-15\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr "VDR-Setup Erweiterung"
+
+msgid "Setup"
+msgstr "Einstellungen"
+
+msgid "Menu Edit"
+msgstr "Men bearbeiten"
+
+msgid "Plugins activate / deactivate"
+msgstr "Plugins aktivieren / sortieren"
+
+msgid "protected"
+msgstr "geschtzt"
+
+msgid "PageUp"
+msgstr "Seite ^"
+
+msgid "PageDown"
+msgstr "Seite v"
+
+msgid "Before"
+msgstr "Davor"
+
+msgid "After"
+msgstr "Dahinter"
+
+msgid "Move"
+msgstr "Verschieben"
+
+msgid "Title"
+msgstr "Titel"
+
+msgid "Edit Plugin"
+msgstr "Editiere Plugin"
+
+msgid "Command"
+msgstr "Befehl"
+
+msgid "Has to confirm"
+msgstr "Zu besttigen"
+
+msgid "Execute as thread"
+msgstr "Als Thread ausfhren"
+
+msgid "Edit Command"
+msgstr "Editiere Befehl"
+
+msgid "Edit Menu"
+msgstr "Editiere Men"
+
+msgid "Create Menu"
+msgstr "Neues Men"
+
+msgid "Create Command"
+msgstr "Neuer Befehl"
+
+msgid "Delete Menu?"
+msgstr "Men lschen?"
+
+msgid "Up/Dn for new location - color key to move"
+msgstr "Auf/Ab fr neue Position - dann Farbtaste"
+
+msgid "Menu"
+msgstr "Men"
+
+msgid "Into"
+msgstr "Hinein"
+
+msgid "Create"
+msgstr "Neu"
+
+msgid "Edit"
+msgstr "Editieren"
+
+msgid "Delete"
+msgstr "Lschen"
+
+msgid "missing channels/xxx.conf"
+msgstr "fehlende channels/xxx.conf"
+
+msgid "Help"
+msgstr "Hilfe"
+
+msgid "Execute"
+msgstr "Starte"
+
+msgid "Error in configuration files"
+msgstr "Fehler in der VDR-Konfiguration"
+
+msgid "Reboot"
+msgstr "Reboot"
+
+msgid "Enter Pin: "
+msgstr "Pin Eingabe: "
+
+msgid "Really reboot?"
+msgstr "Wirklich neu booten?"
+
+msgid "Invalid Pin!"
+msgstr "Ungltige Pin!"
+
+msgid "setupSetup$Main menu entry"
+msgstr "Hauptmen Eintrag"
+
+msgid "setupSetup$Menu suffix"
+msgstr "Men Suffix"
+
+msgid "setupSetup$Entry prefix"
+msgstr "Entry Prefix"
+
+msgid "setupSetup$Return value"
+msgstr "Rckgabe Wert"
Index: vdr-2.2.0/PLUGINS/src/setup/po/el_GR.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/el_GR.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,133 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Dimitrios Dimitrakos <mail@dimitrios.de>, 2002
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Dimitrios Dimitrakos <mail@dimitrios.de>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-7\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr ""
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr ""
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr ""
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr ""
+
+msgid "Delete"
+msgstr ""
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/es_ES.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/es_ES.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,133 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Ruben Nunez Francisco <ruben.nunez@tang-it.com>, 2002
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Ruben Nunez Francisco <ruben.nunez@tang-it.com>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-15\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Configuracin"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Modificar"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Modificar"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Modificar"
+
+msgid "Delete"
+msgstr "Borrar"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/et_EE.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/et_EE.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,133 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Arthur Konovalov <kasjas@hot.ee>, 2004
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Arthur Konovalov <kasjas@hot.ee>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-13\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Stted"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Muuda"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Muuda"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Muuda"
+
+msgid "Delete"
+msgstr "Kustuta"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/fi_FI.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/fi_FI.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,136 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Hannu Savolainen <hannu@opensound.com>, 2002
+# Jaakko Hyvtti <jaakko@hyvatti.iki.fi>, 2002
+# Niko Tarnanen <niko.tarnanen@hut.fi>, 2003
+# Rolf Ahrenberg <rahrenbe@cc.hut.fi>, 2003
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Rolf Ahrenberg <rahrenbe@cc.hut.fi>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-15\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Asetukset"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Muokkaa"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Muokkaa"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Muokkaa"
+
+msgid "Delete"
+msgstr "Poista"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/fr_FR.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/fr_FR.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,139 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Jean-Claude Repetto <jc@repetto.org>, 2001
+# Olivier Jacques <jacquesolivier@hotmail.com>, 2003
+# Gregoire Favre <greg@magma.unil.ch>, 2003
+# Nicolas Huillard <nhuillard@e-dition.fr>, 2005
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Nicolas Huillard <nhuillard@e-dition.fr>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-1\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr "Extension de configuration"
+
+msgid "Setup"
+msgstr "Configuration"
+
+msgid "Menu Edit"
+msgstr "Edition du menu"
+
+msgid "Plugins activate / deactivate"
+msgstr "Activer/desactiver des plugins"
+
+msgid "protected"
+msgstr "protg"
+
+msgid "PageUp"
+msgstr "Page ^"
+
+msgid "PageDown"
+msgstr "Page v"
+
+msgid "Before"
+msgstr "Avant"
+
+msgid "After"
+msgstr "Aprs"
+
+msgid "Move"
+msgstr "Dplacer"
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Edition du menu"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Edition du menu"
+
+#, fuzzy
+msgid "Create Menu"
+msgstr "Crer"
+
+#, fuzzy
+msgid "Create Command"
+msgstr "Crer"
+
+msgid "Delete Menu?"
+msgstr "Effacer le menu?"
+
+msgid "Up/Dn for new location - color key to move"
+msgstr "^/v pour nouvel emplacement - touches couleurs pour dplacer"
+
+#, fuzzy
+msgid "Menu"
+msgstr "Edition du menu"
+
+msgid "Into"
+msgstr "Dans"
+
+msgid "Create"
+msgstr "Crer"
+
+msgid "Edit"
+msgstr "Modifier"
+
+msgid "Delete"
+msgstr "Supprimer"
+
+msgid "missing channels/xxx.conf"
+msgstr "channels/xxx.conf manquant"
+
+msgid "Help"
+msgstr "Aide"
+
+msgid "Execute"
+msgstr "Effectuer"
+
+msgid "Error in configuration files"
+msgstr "Erreur dans fichiers de configurations"
+
+msgid "Reboot"
+msgstr "Redmarer le systme"
+
+msgid "Enter Pin: "
+msgstr "Le code pin: "
+
+msgid "Really reboot?"
+msgstr "Vraiment redmarrer le systme?"
+
+msgid "Invalid Pin!"
+msgstr "La clef est fausse!"
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr "Suffixe Menu"
+
+msgid "setupSetup$Entry prefix"
+msgstr "Entry prfix"
+
+msgid "setupSetup$Return value"
+msgstr "Valeur de retour"
Index: vdr-2.2.0/PLUGINS/src/setup/po/hr_HR.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/hr_HR.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,134 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Drazen Dupor <drazen.dupor@dupor.com>, 2004
+# Dino Ravnic <dino.ravnic@fer.hr>, 2004
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Drazen Dupor <drazen.dupor@dupor.com>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-2\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Konfiguracija"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Promijeni"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Promijeni"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Promijeni"
+
+msgid "Delete"
+msgstr "Obrii"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/hu_HU.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/hu_HU.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,134 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Istvan Koenigsberger <istvnko@hotmail.com>, 2002
+# Guido Josten <guido.josten@t-online.de>, 2002
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Istvan Koenigsberger <istvnko@hotmail.com>, Guido Josten <guido.josten@t-online.de>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-2\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Belltsok"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Belltani"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Belltani"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Belltani"
+
+msgid "Delete"
+msgstr "Trlni"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr "Pin kd: "
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/it_IT.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/it_IT.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,135 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Alberto Carraro <bertocar@tin.it>, 2001
+# Antonio Ospite <ospite@studenti.unina.it>, 2003
+# Sean Carlos <seanc@libero.it>, 2005
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Sean Carlos <seanc@libero.it>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-15\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Opzioni"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Modifica"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Modifica"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Modifica"
+
+msgid "Delete"
+msgstr "Cancella"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/nl_NL.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/nl_NL.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,135 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Arnold Niessen <niessen@iae.nl> <arnold.niessen@philips.com>, 2001
+# Hans Dingemans <hans.dingemans@tacticalops.nl>, 2003
+# Maarten Wisse <Maarten.Wisse@urz.uni-hd.de>, 2005
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Maarten Wisse <Maarten.Wisse@urz.uni-hd.de>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-15\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Instellingen"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Verander"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Verander"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Verander"
+
+msgid "Delete"
+msgstr "Verwijder"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/nn_NO.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/nn_NO.po	2015-12-24 15:16:31.692279586 +0100
@@ -0,0 +1,134 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Jrgen Tvedt <pjtvedt@online.no>, 2001
+# Truls Slevigen <truls@slevigen.no>, 2002
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Truls Slevigen <truls@slevigen.no>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-1\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Konfigurasjon"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Editer"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Editer"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Editer"
+
+msgid "Delete"
+msgstr "Slett"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/pl_PL.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/pl_PL.po	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,133 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Michael Rakowski <mrak@gmx.de>, 2002
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Michael Rakowski <mrak@gmx.de>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-2\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Ustawienia"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Edytuj"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Edytuj"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Edytuj"
+
+msgid "Delete"
+msgstr "Usu"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/pt_PT.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/pt_PT.po	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,133 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Paulo Lopes <pmml@netvita.pt>, 2001
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Paulo Lopes <pmml@netvita.pt>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-1\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Configurar"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Modificar"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Modificar"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Modificar"
+
+msgid "Delete"
+msgstr "Apagar"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/ro_RO.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/ro_RO.po	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,134 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Paul Lacatus <paul@campina.iiruc.ro>, 2002
+# Lucian Muresan <lucianm@users.sourceforge.net>, 2004
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Lucian Muresan <lucianm@users.sourceforge.net>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-2\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Configuraie"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Modific"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Modific"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Modific"
+
+msgid "Delete"
+msgstr "terge"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/ru_RU.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/ru_RU.po	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,133 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Vyacheslav Dikonov <sdiconov@mail.ru>, 2004
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Vyacheslav Dikonov <sdiconov@mail.ru>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-5\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr ""
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr ""
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr ""
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr ""
+
+msgid "Delete"
+msgstr ""
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr " : "
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/sl_SI.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/sl_SI.po	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,134 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Miha Setina <mihasetina@softhome.net>, 2000
+# Matjaz Thaler <matjaz.thaler@guest.arnes.si>, 2003
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Matjaz Thaler <matjaz.thaler@guest.arnes.si>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-2\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Nastavitve"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "Uredi"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "Uredi"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "Uredi"
+
+msgid "Delete"
+msgstr "Izbrii"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/sv_SE.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/sv_SE.po	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,134 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Tomas Prybil <tomas@prybil.se>, 2002
+# Jan Ekholm <chakie@infa.abo.fi>, 2003
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Tomas Prybil <tomas@prybil.se>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-1\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr "Instllningar"
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Plugin"
+msgstr "ndra"
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+#, fuzzy
+msgid "Edit Menu"
+msgstr "ndra"
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr "ndra"
+
+msgid "Delete"
+msgstr "Ta bort"
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/po/tr_TR.po
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/po/tr_TR.po	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,131 @@
+# VDR plugin language source file.
+# Copyright (C) 2007 Klaus Schmidinger <kls@cadsoft.de>
+# This file is distributed under the same license as the VDR package.
+# Oktay Yolgeen <oktay_73@yahoo.de>, 2007
+#
+msgid ""
+msgstr ""
+"Project-Id-Version: VDR 1.5.7\n"
+"Report-Msgid-Bugs-To: <vdrdev@schmirler.de>\n"
+"POT-Creation-Date: 2013-07-28 03:57+0200\n"
+"PO-Revision-Date: 2008-01-27 18:38+0100\n"
+"Last-Translator: Oktay Yolgeen <oktay_73@yahoo.de>\n"
+"Language-Team: <vdr@linuxtv.org>\n"
+"Language: \n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=ISO-8859-9\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+msgid "VDR-Setup Extension"
+msgstr ""
+
+msgid "Setup"
+msgstr ""
+
+msgid "Menu Edit"
+msgstr ""
+
+msgid "Plugins activate / deactivate"
+msgstr ""
+
+msgid "protected"
+msgstr ""
+
+msgid "PageUp"
+msgstr ""
+
+msgid "PageDown"
+msgstr ""
+
+msgid "Before"
+msgstr ""
+
+msgid "After"
+msgstr ""
+
+msgid "Move"
+msgstr ""
+
+msgid "Title"
+msgstr ""
+
+msgid "Edit Plugin"
+msgstr ""
+
+msgid "Command"
+msgstr ""
+
+msgid "Has to confirm"
+msgstr ""
+
+msgid "Execute as thread"
+msgstr ""
+
+msgid "Edit Command"
+msgstr ""
+
+msgid "Edit Menu"
+msgstr ""
+
+msgid "Create Menu"
+msgstr ""
+
+msgid "Create Command"
+msgstr ""
+
+msgid "Delete Menu?"
+msgstr ""
+
+msgid "Up/Dn for new location - color key to move"
+msgstr ""
+
+msgid "Menu"
+msgstr ""
+
+msgid "Into"
+msgstr ""
+
+msgid "Create"
+msgstr ""
+
+msgid "Edit"
+msgstr ""
+
+msgid "Delete"
+msgstr ""
+
+msgid "missing channels/xxx.conf"
+msgstr ""
+
+msgid "Help"
+msgstr ""
+
+msgid "Execute"
+msgstr ""
+
+msgid "Error in configuration files"
+msgstr ""
+
+msgid "Reboot"
+msgstr ""
+
+msgid "Enter Pin: "
+msgstr ""
+
+msgid "Really reboot?"
+msgstr ""
+
+msgid "Invalid Pin!"
+msgstr ""
+
+msgid "setupSetup$Main menu entry"
+msgstr ""
+
+msgid "setupSetup$Menu suffix"
+msgstr ""
+
+msgid "setupSetup$Entry prefix"
+msgstr ""
+
+msgid "setupSetup$Return value"
+msgstr ""
Index: vdr-2.2.0/PLUGINS/src/setup/README
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/README	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,66 @@
+This is a "plugin" for the Video Disk Recorder (VDR).
+
+Written by:                  Ralf Dotzert <ranga@vdrtools.de>
+
+Project's homepage:          www.vdrtools.de
+
+Latest original version available at: www.vdrtools.de
+
+Latest hacked version available at:
+www.zulu-entertainment.de/files/vdr-setup/vdr-setup-0.3.1-zulu-edition.tgz
+
+See the file COPYING for license information.
+
+Overview
+--------
+The "Setup Plugin" can be used to to setup all or most configuration parameters 
+of VDR distributions via the OSD.
+
+The Plugin can be easily configured by editing XML the following XML-Files:
+
+  [VDR-CONFIG-DIR]/plugins/vdr-setup.xml
+  [VDR-CONFIG-DIR]/plugins/vdr-menu.xml
+
+minivdr-setup.xml
+=============
+Holds the Setup configuration, See Examples/*/vdr-setup.xml:
+
+vdr-menu.xml
+============
+Holds the VDR Menu-Submenu configuration. See Examples/vdr-menu.xml.
+
+The configuration files must be copied into the directory PluginsConfigdirectory/setup
+
+Help Viles should be placed in PluginsConfigdirectory/setup/help
+
+Requirements
+============
+It is required to apply the patch to VDR included with the plugin.
+
+For vdr-setup-0.3.1-zulu-edition the VDR-Extensions-Patch => 63 or
+VDR-Extensions-Patch 62 + vdr-ext62_setup-custom-plugin-title.diff is required
+
+
+Also please make sure, that the file specified with the parameter "sysconfigFile"
+ (see vdr-setup.xml) exists.
+The Plugin will save the configured parameters in this file in the form of:
+
+VARIABLE="value"
+...
+
+The sysconfig file can be just included by any Shell-Scripts which may interpret 
+the stored Variables.
+
+
+All Variable names can be specified within the minivdr-setup.xml configuration file
+itself. The predefined Variable PLUGINLIST will hold all activated Plugins including
+their optional parameters, and can be used in the VDR startup script to dynamically
+specifiy the Plugins.
+
+
+Detailed Information currently only available in german language.
+see MANUAL.DE and http://www.vdrtools.de
+
+
+
+
Index: vdr-2.2.0/PLUGINS/src/setup/setup.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/setup.c	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,110 @@
+/****************************************************************************
+ * DESCRIPTION: 
+ *             Setup a Plugin vor VDR
+ *
+ * $Id: setup.cpp,v 1.18 2006/03/06 19:16:41 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ ****************************************************************************/
+
+#include <vdr/plugin.h>
+#include "setupmenu.h"
+#include "setupsetup.h"
+
+static const char *VERSION        = "0.3.1-easyVDR-edition";
+static const char *DESCRIPTION    = trNOOP("VDR-Setup Extension");
+static const char *MAINMENUENTRY  = trNOOP("Setup");
+
+//holds setup configuration
+cSetupSetup  setupSetup;
+
+class cPluginSetup : public cPlugin {
+private:
+  // Add any member variables or functions you may need here.
+public:
+  cPluginSetup(void);
+  virtual ~cPluginSetup();
+  virtual const char *Version(void) { return VERSION; }
+  virtual const char *Description(void) { return tr(DESCRIPTION); }
+  virtual const char *CommandLineHelp(void);
+  virtual bool ProcessArgs(int argc, char *argv[]);
+  virtual bool Initialize(void);
+  virtual bool Start(void);
+  virtual void Housekeeping(void);
+  virtual const char *MainMenuEntry(void) { return setupSetup.DirectMenu ? tr("Menu Edit") : tr(MAINMENUENTRY); }
+  virtual cOsdObject *MainMenuAction(void);
+  virtual cMenuSetupPage *SetupMenu(void);
+  virtual bool SetupParse(const char *Name, const char *Value);
+  };
+
+cPluginSetup::cPluginSetup(void)
+{
+  // Initialize any member variables here.
+  // DON'T DO ANYTHING ELSE THAT MAY HAVE SIDE EFFECTS, REQUIRE GLOBAL
+  // VDR OBJECTS TO EXIST OR PRODUCE ANY OUTPUT!
+}
+
+cPluginSetup::~cPluginSetup()
+{
+  // Clean up after yourself!
+ 
+}
+
+const char *cPluginSetup::CommandLineHelp(void)
+{
+  // Return a string that describes all known command line options.
+  return NULL;
+}
+
+bool cPluginSetup::ProcessArgs(int argc, char *argv[])
+{
+  // Implement command line argument processing here if applicable.
+  return true;
+}
+
+bool cPluginSetup::Initialize(void)
+{
+  // Initialize any background activities the plugin shall perform.
+#if VDRVERSNUM < 10507
+  RegisterI18n(Phrases);
+#endif
+  return true;
+}
+
+bool cPluginSetup::Start(void)
+{
+  // Start any background activities the plugin shall perform.
+  return true;
+}
+
+void cPluginSetup::Housekeeping(void)
+{
+  // Perform any cleanup or other regular tasks.
+}
+
+cOsdObject *cPluginSetup::MainMenuAction(void)
+{
+  // Perform the action when selected from the main VDR menu.
+  if (setupSetup.DirectMenu)
+     return new cSetupVdrMenu(tr("Menu Edit"));
+  return (new cSetupMenu());
+}
+
+cMenuSetupPage *cPluginSetup::SetupMenu(void)
+{
+  // Return a setup menu in case the plugin supports one.
+  return new cSetupSetupPage;
+
+}
+
+bool cPluginSetup::SetupParse(const char *Name, const char *Value)
+{
+  // Parse your own setup parameters and store their values.
+  return setupSetup.SetupParse(Name, Value);
+}
+
+
+
+VDRPLUGINCREATOR(cPluginSetup); // Don't touch this!
Index: vdr-2.2.0/PLUGINS/src/setup/setupmenu.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/setupmenu.c	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,1076 @@
+/****************************************************************************
+ * DESCRIPTION:
+ *             Creates VDR Menus
+ *
+ * $Id: setupmenu.cpp,v 1.21 2006/03/05 09:47:26 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2005 by Ralf Dotzert
+ ****************************************************************************/
+
+#include <stdlib.h>
+#include <vdr/menuitems.h>
+#if APIVERSNUM >= 10501
+#include <vdr/shutdown.h>
+#endif
+#include <string>
+
+#include "setupmenu.h"
+#include "config.h"
+#include "plugins.h"
+#include "debug.h"
+#include "setupsetup.h"
+#include "setupsystemmenu.h"
+
+
+
+//#################################################################################################
+cSetupPluginMenu::cSetupPluginMenu(Config  *config) : cOsdMenu(tr("Plugins activate / deactivate"), 38)
+{
+  _moveMode = false;
+  _sortMode = false;
+
+  if (config != NULL && config->GetPlugins() != NULL) {
+     _config  = config;
+     _plugins = config->GetPlugins();
+     Set();
+    }
+}
+
+cSetupPluginMenu::~cSetupPluginMenu()
+{
+}
+
+/**
+ * 
+ */
+void cSetupPluginMenu::Set( )
+{
+
+  int current = Current();
+
+  Clear();
+
+  for (int i=0; i<_plugins->GetNr(); i++) {
+      if (_plugins->Get(i)->GetProtect()) {
+         char *title = NULL;
+         asprintf(&title, "%s:\t%s", _plugins->Get(i)->GetInfo(),tr("protected")); 
+         Add(new cOsdItem (title));
+         free(title);
+         }
+      else
+         Add(new cMenuEditBoolItem(_plugins->Get(i)->GetInfo(), _plugins->Get(i)->GetActiveRef(), trVDR("no"), trVDR("yes")));
+      }
+
+  if (current == -1 && _plugins->GetNr() > 0)
+     current = 0;
+  SetCurrent(Get(current));
+
+  if (_moveMode)
+     SetHelp(tr("PageUp"),  tr("PageDown"), tr("Before"), tr("After"));
+  else
+     SetHelp(tr("PageUp"),  tr("PageDown"), trVDR("Parameters"), tr("Move"));
+
+  setHelp();
+  Display();
+}
+
+eOSState cSetupPluginMenu::ProcessKey( eKeys Key )
+{
+  bool HadSubMenu = HasSubMenu();
+  eOSState state = cOsdMenu::ProcessKey(Key);
+  if (HasSubMenu() || HadSubMenu)
+     return state;
+
+  switch (Key) {
+    case kOk :
+                   _config->SaveFile();
+                   return osBack;
+                   break;
+
+    case kRed:
+                   PageUp();
+                   Set();
+                   break;
+
+    case kGreen:
+                   PageDown();
+                   Set();
+                   break;
+    case kYellow:
+                   if (_moveMode) {
+                      _plugins->MovePlugin(_startIndex, Current(), Plugins::BEFORE);
+                      _moveMode = !_moveMode;
+                      Set();
+                      }
+                   else { // Edit Parameter
+                      char *tmp=NULL;
+                      asprintf(&tmp, "%s-%s", trVDR("Plugin"), trVDR("Parameters"));
+                      return(AddSubMenu(new cSetupPluginParameter(tmp, _plugins->Get(Current()))));
+                      free(tmp);
+                      }
+                   break;
+    case kBlue:
+                   if (_moveMode) {
+                      _plugins->MovePlugin(_startIndex, Current(), Plugins::BEHIND);
+                      }
+                   else {
+                      _startIndex = Current();
+                      }
+                   _moveMode = !_moveMode;
+                   Set();
+                   break;
+    case kDown:
+    case kUp:
+                   setHelp();
+                   break;
+    default:       break;
+    }
+  return state;
+}
+
+void cSetupPluginMenu::setHelp()
+{
+  char *tmp = NULL;
+  int  current = Current();
+  if (current >= 0 ) {
+     asprintf(&tmp, "%s: %s", trVDR("Plugin"), _plugins->Get(current)->GetName());
+     SetStatus(tmp);
+     free(tmp);
+     }
+}
+
+
+//#################################################################################################
+//  Edit Plugin Parameter
+//################################################################################################
+
+cSetupPluginParameter::cSetupPluginParameter( const char *title, Plugin * plugin ) : cOsdMenu(title, 25)
+{
+  _plugin = plugin;
+  _edit   = false;
+  Set();
+}
+
+cSetupPluginParameter::~ cSetupPluginParameter( )
+{
+}
+
+void cSetupPluginParameter::Set( )
+{
+  char *tmp = NULL;
+  const char *param = _plugin->GetParameter();
+  Clear();
+  if (param == NULL)
+     _editParameter[0] = '\0';
+  else {
+     strncpy(_editParameter, param, sizeof(_editParameter));
+     _editParameter[sizeof(_editParameter)] = '\0';
+     }
+  asprintf(&tmp, "%s-%s", trVDR("Plugin"), trVDR("Parameters"));
+  Add(new cMenuEditStrItem(tmp, _editParameter, sizeof(_editParameter), trVDR(FileNameChars)));
+
+  asprintf(&tmp, "%s: %s", trVDR("Plugin"), _plugin->GetName());
+  SetStatus(tmp);
+  free(tmp);
+  Display();
+}
+
+eOSState cSetupPluginParameter::ProcessKey( eKeys Key )
+{
+
+  eOSState state = cOsdMenu::ProcessKey(Key);
+
+  switch (Key) {
+    case kOk:
+              if (!_edit)
+                 return osBack;
+              else {
+                 _plugin->SetParameter(_editParameter);
+                 _edit=false;
+                 }
+              break;
+    case kRight:
+              _edit = true;
+              break;
+    default:
+              break;
+    }
+  return state;
+}
+
+
+//#################################################################################################
+//  cSetupVdrMenu
+//################################################################################################
+
+cSetupVdrMenu::cSetupVdrMenu(const char *title): cOsdMenu(title, 25)
+{
+  _startIndex           = 0;
+  _createEditNodeIndex  = 0;
+
+  // Load Menu Configuration
+  char *menuXML = NULL;
+#if VDRVERSNUM < 10507
+  asprintf(&menuXML, "%s/setup/vdr-menu.%i.xml", cPlugin::ConfigDirectory(), Setup.OSDLanguage);
+#else
+  asprintf(&menuXML, "%s/setup/vdr-menu.%s.xml", cPlugin::ConfigDirectory(), Setup.OSDLanguage);
+#endif
+  if (access(menuXML, 06) == -1)
+     asprintf(&menuXML, "%s/setup/vdr-menu.xml", cPlugin::ConfigDirectory());
+  isyslog("setup: loading %s", menuXML);
+  _vdrSubMenu.LoadXml(menuXML);
+  free(menuXML);
+
+  _menuState  = UNDEFINED;
+  Set();
+}
+
+cSetupVdrMenu::~ cSetupVdrMenu( )
+{
+}
+
+void cSetupVdrMenu::Set( )
+{
+  int current = Current();
+  cSubMenuNode *node = NULL;
+  int nr = _vdrSubMenu.GetNrOfNodes();
+
+  Clear();
+
+  switch (_menuState) {
+    case UNDEFINED:
+                SetTitle(tr("Menu Edit"));
+    case MOVE:
+                for (int i=0; i<nr; i++) {
+                    if ((node = _vdrSubMenu.GetAbsNode(i)) != NULL) {
+                       char *tmp = createMenuName(node);
+                       Add(new cOsdItem(tmp));
+                       free(tmp);
+                       }
+                    }
+                current = _createEditNodeIndex;
+                if (current >= nr)
+                   current = nr-1;
+                break;
+    case EDIT:
+                if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::CALL_PLUGIN) {
+/*
+                   char *name = NULL;
+                   asprintf(&name, "%s:\t%s", trVDR("Name"), _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetName());
+                   Add(new cOsdItem(name));
+                   free(name);
+*/
+                   if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetCustomTitle() != NULL)
+                      strncpy(_editTitle, _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetCustomTitle(), sizeof(_editTitle));
+                   else
+                      strncpy(_editTitle, "", sizeof(_editTitle));
+                   _editTitle[sizeof(_editTitle)] = '\0';
+                   Add(new cMenuEditStrItem(tr("Title"), _editTitle, sizeof(_editTitle), trVDR(FileNameChars)));
+
+                   char *menutitle = NULL;
+                   asprintf(&menutitle, "%s '%s'", tr("Edit Plugin"), _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetName());
+                   SetTitle(menutitle);
+                   free(menutitle);
+                   }
+                else if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::COMMAND ||
+                         _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::THREAD) {
+                   strncpy(_editTitle, _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetName(), sizeof(_editTitle));
+                   _editTitle[sizeof(_editTitle)] = '\0';
+                   Add(new cMenuEditStrItem(trVDR("Name"), _editTitle, sizeof(_editTitle), trVDR(FileNameChars)));
+
+                   strncpy(_editCommand, _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetCommand(), sizeof(_editCommand));
+                   _editTitle[sizeof(_editCommand)] = '\0';
+                   Add(new cMenuEditStrItem(tr("Command"), _editCommand, sizeof(_editCommand), trVDR(FileNameChars)));
+
+                   if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->CommandConfirm())
+                      _hasToConfirm = 1;
+                   else
+                      _hasToConfirm = 0;
+                   Add(new cMenuEditBoolItem(tr("Has to confirm"), &_hasToConfirm));
+
+                   if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::THREAD)
+                      _isThread = 1;
+                   else
+                      _isThread = 0;
+                   Add(new cMenuEditBoolItem(tr("Execute as thread"), &_isThread));
+
+                   SetTitle(tr("Edit Command"));
+                   }
+                else { // MENU
+                   strncpy(_editTitle, _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetName(), sizeof(_editTitle));
+                   _editTitle[sizeof(_editTitle)] = '\0';
+                   Add(new cMenuEditStrItem(trVDR("Name"), _editTitle, sizeof(_editTitle), trVDR(FileNameChars)));
+
+                   SetTitle(tr("Edit Menu"));
+                   }
+
+                setHelp();
+                break;
+    case CREATE:
+                strncpy(_editTitle, "", sizeof(_editTitle));
+                Add(new cMenuEditStrItem(trVDR("Name"), _editTitle, sizeof(_editTitle), trVDR(FileNameChars)));
+                SetTitle(tr("Create Menu"));
+                setHelp();
+                break;
+    case CREATECMD:
+                strncpy(_editTitle, "", sizeof(_editTitle));
+                Add(new cMenuEditStrItem(trVDR("Name"), _editTitle, sizeof(_editTitle), trVDR(FileNameChars)));
+                strncpy(_editCommand, "", sizeof(_editCommand));
+                Add(new cMenuEditStrItem(tr("Command"), _editCommand, sizeof(_editCommand), trVDR(FileNameChars)));
+
+                _hasToConfirm = 1;
+                Add(new cMenuEditBoolItem(tr("Has to confirm"), &_hasToConfirm));
+
+                _isThread = 0;
+                Add(new cMenuEditBoolItem(tr("Execute as thread"), &_isThread));
+                SetTitle(tr("Create Command"));
+                setHelp();
+                break;
+    default:
+                break;
+    }
+
+  SetCurrent(Get(current));
+  setHelp();
+  Display();
+}
+
+
+
+
+eOSState cSetupVdrMenu::ProcessKey( eKeys Key )
+{
+    cSubMenuNode *node = NULL;
+    eOSState state = cOsdMenu::ProcessKey(Key);
+    if (HasSubMenu())
+       return state;
+//    isyslog("setup: %d", state); // osUnknown=0, osContinue=1, osBack=16
+    if (state == osUnknown || state == osBack) {
+       switch (Key) {
+         case k0:
+                       if (_menuState == UNDEFINED) {
+                          _menuState = CREATECMD;
+                          _createEditNodeIndex = Current();
+                          Set();
+                          }
+                       break;
+         case kRed:
+                      if (_menuState == CREATE) {
+                          _menuState = CREATECMD;
+                          Set();
+                          }
+                       else if (_menuState == CREATECMD) {
+                          _menuState = CREATE;
+                          Set();
+                          }
+                       else if (_menuState == UNDEFINED) {
+                          _menuState = CREATE;
+                          _createEditNodeIndex = Current();
+                          Set();
+                          }
+                       break;
+         case kGreen:
+                       if (_menuState == MOVE) {
+                          if ((node = _vdrSubMenu.GetAbsNode(Current())) != NULL && node->GetType() == cSubMenuNode::MENU) {
+                             _vdrSubMenu.MoveMenu(_startIndex, Current(), cSubMenu::INTO);
+                             _menuState = UNDEFINED;
+                             _createEditNodeIndex = Current();
+                             SetStatus(NULL);
+                             Set();
+                             }
+                          }
+                       else if (_menuState == UNDEFINED) {
+                          if ((node = _vdrSubMenu.GetAbsNode(Current())) != NULL && (node->GetType() == cSubMenuNode::MENU ||
+                                                                                     node->GetType() == cSubMenuNode::CALL_PLUGIN ||
+                                                                                     node->GetType() == cSubMenuNode::COMMAND ||
+                                                                                     node->GetType() == cSubMenuNode::THREAD)) {
+                             _menuState = EDIT;
+                             _createEditNodeIndex = Current();
+                             Set();
+                             }
+                          }
+                       setHelp();
+                       break;
+         case kYellow:
+                       if (_menuState == MOVE) {
+                          _vdrSubMenu.MoveMenu(_startIndex, Current(), cSubMenu::BEFORE);
+                          _menuState = UNDEFINED;
+                          _createEditNodeIndex = Current();
+                          SetStatus(NULL);
+                          Set();
+                          }
+                       else if (_menuState == UNDEFINED) {
+                          if (Interface->Confirm(tr("Delete Menu?"))) {
+                             _createEditNodeIndex = Current();
+                             _vdrSubMenu.DeleteMenu(_createEditNodeIndex);
+                             _menuState = UNDEFINED;
+                             Set();
+                             }
+                          }
+                       break;
+         case kBlue:
+                       if (_menuState == MOVE) {
+                          _vdrSubMenu.MoveMenu(_startIndex, Current(), cSubMenu::BEHIND);
+                          _createEditNodeIndex = Current();
+                          _menuState = UNDEFINED;
+                          SetStatus(NULL);
+                          }
+                       else if (_menuState == UNDEFINED) {
+                          _startIndex = Current();
+                          _createEditNodeIndex = _startIndex;
+                          _menuState = MOVE;
+                          SetStatus(tr("Up/Dn for new location - color key to move"));
+                          }
+                       Set();
+                       break;
+
+         case kOk:
+                       switch (_menuState) {
+                         case UNDEFINED:
+                                    // Save Menus to file and exit submenu
+                                     state = osBack;
+                                    _vdrSubMenu.SetMenuSuffix(setupSetup._menuSuffix);
+                                    _vdrSubMenu.SaveXml();
+                                    break;
+                         case CREATE:
+                                    _vdrSubMenu.CreateMenu(_createEditNodeIndex, _editTitle);
+                                    _menuState = UNDEFINED;
+                                    Set();
+                                    break;
+                         case CREATECMD:
+                                    if (_isThread == 1)
+                                       _vdrSubMenu.CreateThread(_createEditNodeIndex, _editTitle, _editCommand, _hasToConfirm);
+                                    else
+                                       _vdrSubMenu.CreateCommand(_createEditNodeIndex, _editTitle, _editCommand, _hasToConfirm);
+                                    _menuState = UNDEFINED;
+                                    Set();
+                                    break;
+                         case EDIT:
+                                    if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::CALL_PLUGIN)
+                                       _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetCustomTitle(_editTitle);
+                                    else if (_vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::COMMAND ||
+                                             _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->GetType() == cSubMenuNode::THREAD) {
+                                       _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetName(_editTitle);
+                                       if (_isThread == 1)
+                                          _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetType(cSubMenuNode::THREAD);
+                                       else
+                                          _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetType(cSubMenuNode::COMMAND);
+                                       _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetCommand(_editCommand);
+                                       _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetCommandConfirm(_hasToConfirm);
+                                       }
+                                    else
+                                       _vdrSubMenu.GetAbsNode(_createEditNodeIndex)->SetName(_editTitle);
+                                    _menuState = UNDEFINED;
+                                    Set();
+                                    break;
+
+                         default:
+                                    break;
+                         }
+                       break;
+         case kBack:
+                       state = osBack;
+                       if (_menuState == CREATE || _menuState == CREATECMD || _menuState == EDIT) {
+                          _menuState = UNDEFINED;
+                          Set();
+                          state = osContinue;
+                          }
+                       break;
+         case kDown:
+         case kUp:
+         case kRight:
+         case kLeft:
+                       if (_menuState == MOVE)
+                          setHelp();
+                       break;
+         default:
+                       break;
+         }
+      }
+   else if (state == osContinue) {
+       switch (Key) {
+         case kBack:
+                      setHelp();
+                      break;
+         case kDown:
+         case kUp:
+         case kRight:
+         case kLeft:
+                       if (_menuState == MOVE)
+                          setHelp();
+                       break;
+         default:
+                       break;
+         }
+      }
+
+   return state;
+}
+
+// --------------- Private Methods ---------------------
+void cSetupVdrMenu::setHelp( )
+{
+  cSubMenuNode *node = NULL;
+
+   if (_menuState == CREATE)
+     SetHelp(tr("Command"), NULL, NULL, NULL);
+  else if (_menuState == CREATECMD)
+     SetHelp(tr("Menu"), NULL, NULL, NULL);
+  else if (_menuState == EDIT)
+     SetHelp(NULL, NULL, NULL, NULL);
+  else if (_menuState == MOVE) {
+     if ((node= _vdrSubMenu.GetAbsNode(Current())) != NULL && node->GetType() == cSubMenuNode::MENU)
+        SetHelp(NULL, tr("Into"), tr("Before"), tr("After"));
+     else
+        SetHelp(NULL, NULL, tr("Before"), tr("After"));
+     }
+  else
+     SetHelp(tr("Create"), tr("Edit"), tr("Delete"), tr("Move"));
+}
+
+char * cSetupVdrMenu::createMenuName( cSubMenuNode *node )
+{
+  char *prefix = NULL;
+  char *tmp = NULL;
+  int   level = node->GetLevel();
+
+  // Set Prefix
+  prefix = (char*) malloc(1);
+  prefix[0] = '\0';
+  for (int i=0; i<level; i++)
+      asprintf(&prefix, "|   %s", prefix);
+
+  cSubMenuNode::Type type = node->GetType();
+
+  if (type == cSubMenuNode::MENU)
+     asprintf(&tmp, "%s+%s", prefix, node->GetName());
+  else if (type == cSubMenuNode::SYSTEM)
+     asprintf(&tmp, "%s %s", prefix, trVDR(node->GetName()));
+  else if (type == cSubMenuNode::CALL_PLUGIN)
+     if (node->GetCustomTitle() != NULL && strcmp(node->GetCustomTitle(), "") != 0)
+        asprintf(&tmp, "%s %s  (%s)", prefix, node->GetCustomTitle(), node->GetName());
+     else
+        asprintf(&tmp, "%s %s  (%s)", prefix, node->GetPluginMainMenuEntry(), node->GetName());
+  else
+     asprintf(&tmp, "%s %s",  prefix, node->GetName());
+
+  free(prefix);
+
+  return(tmp);
+}
+
+//#################################################################################################//  cSetupGenericMenu
+//################################################################################################
+cSetupGenericMenu::cSetupGenericMenu(const char *title, MenuNode *node, Config  *config)  : cSetupMenu()
+{
+  _node     = node;
+  _editItem = false;
+  _currLine = 0;
+  _config   = config;
+
+  SetTitle(title);
+  SetCols(25);
+
+  if (_node != NULL)
+     Set();
+}
+
+
+cSetupGenericMenu::~cSetupGenericMenu()
+{
+}
+
+const char * cSetupGenericMenu::nohk(const char *str)
+{
+  static std::string tmp;
+  tmp = setupSetup._entryPrefix;
+
+  if (strlen(setupSetup._entryPrefix) == 0 || setupSetup._entryPrefix[0] == ' ')
+     tmp = "      ";
+  else {
+     tmp =  "  ";
+     tmp += setupSetup._entryPrefix;
+     tmp += "  ";
+     }
+
+  tmp += str;
+  return(tmp.c_str());
+}
+
+/**
+ * 
+ */
+void cSetupGenericMenu::Set( )
+{
+  int current = Current();
+  Clear();
+  SetHasHotkeys();
+  for (int i=0; i< _node->GetNr(); i++) {
+      MenuNode::Type type = _node->GetNode(i)->GetType();
+
+     if (type == MenuNode::ENTRY) {
+        MenuEntry *e = _node->GetNode(i)->GetMenuEntry();
+
+        switch (e->GetType()) {
+          case Util::BOOL:
+             Add(new cMenuEditBoolItem(nohk(e->GetName()), e->GetValueBoolRef(), trVDR("no"), trVDR("yes")));
+             break;
+          case Util::NUMBER:
+             Add(new cMenuEditIntItem(nohk(e->GetName()), e->GetValueNumberRef(), 0, 999999999));
+             break;
+          case Util::TEXT:
+             Add(new cMenuEditStrItem(nohk((char*)e->GetName()), (char*)e->GetValue(), e->GetValueTextMaxLen(), " abcdefghijklmnopqrstuvwxyz0123456789-.#~_"));
+             break;
+          case Util::NUMBER_TEXT:
+             Add(new cMenuEditStrItem(nohk((char*)e->GetName()), (char*)e->GetValue(), e->GetValueTextMaxLen(), "0123456789"));
+             break;
+          case Util::IP:
+             Add(new cMenuEditStrItem(nohk((char*)e->GetName()), (char*)e->GetValueIp(), e->GetValueIpMaxLen(), ".0123456789"));
+             break;
+          case Util::HEX:
+             Add(new cMenuEditStrItem(nohk((char*)e->GetName()), (char*)e->GetValue(), e->GetValueTextMaxLen(), "0123456789ABCDEF:"));
+             break;
+          case Util::SELECTION:
+             {
+               if (e->GetNrOfSelectionValues() == 0) {
+                  char *txt = NULL;
+                  asprintf(&txt, "%s:\t%s", nohk(e->GetName()), tr("missing channels/xxx.conf"));
+                  Add(new cOsdItem (txt));
+                  free(txt);
+                  }
+               else
+                  Add(new cMenuEditStraItem(nohk(e->GetName()), e->GetReferenceSelection(),
+                                                                e->GetNrOfSelectionValues(),
+                                                                e->GetSelectionValues()) );
+             }
+             break;
+          default:
+             break;
+          }
+        }
+     else if (type == MenuNode::MENUSYSTEM) {
+        char *tmp = NULL;
+        asprintf(&tmp, "%s", _node->GetNode(i)->GetMenu()->GetSystem());
+        if ((strcmp(tmp, "ActPlugins") == 0) || (strcmp(tmp, "VDRMenu") == 0))
+           asprintf(&tmp, "%s%s", tr(_node->GetNode(i)->GetName()), setupSetup._menuSuffix);
+        else
+           asprintf(&tmp, "%s%s", trVDR(_node->GetNode(i)->GetName()), setupSetup._menuSuffix);
+        Add(new cOsdItem(hk(tmp)));
+        free(tmp);
+        }
+     else {
+        char *tmp = NULL;
+        asprintf(&tmp, "%s%s", _node->GetNode(i)->GetName(), setupSetup._menuSuffix);
+        Add(new cOsdItem(hk(tmp)));
+        free(tmp);
+        }
+     }
+  SetCurrent(Get(current));
+  Display();
+}
+
+eOSState cSetupGenericMenu::ProcessKey( eKeys Key )
+{
+  bool HadSubMenu = HasSubMenu();
+  eOSState state = cOsdMenu::ProcessKey(Key);
+
+  if (HasSubMenu() || HadSubMenu)
+     return state;
+
+  MenuNode *n = _node->GetNode(Current());
+
+  switch (Key) {
+    case kOk :
+                    if (n != NULL && (n->GetType() == MenuNode::MENU || n->GetType() == MenuNode::MENUSYSTEM)) {
+                       if (n->GetType() == MenuNode::MENU)
+                          return(AddSubMenu(new cSetupGenericMenu(n->GetName(), n,  _config)));
+                       else {  // Menu "system"
+                          cOsdMenu *menu = cSetupSystemMenu::GetSystemMenu(n->GetMenu()->GetSystem(), _config);
+                          if (menu != NULL)
+                             return(AddSubMenu(menu));
+                          }
+                       }
+                    else {
+                       if (!_editItem) { //close submenu only if we do not have edited an textitem
+                          state = osBack;
+                          _config->SaveFile(); // Write New Configurationfile
+
+                          for (int i=0;  i < _node->GetNr(); i++) {
+                              n = _node->GetNode(i);
+                              if ( n->GetType() == MenuNode::ENTRY)
+                                 ExecuteCommand(n->GetMenuEntry()->GetCommand());
+                              }
+                          ExecuteCommand(_node->GetMenu()->GetCommand());
+                          }
+
+                       _editItem = false;
+                       }
+                    break;
+     case kRed:
+                    {
+                       char *help = NULL;
+                       if (n->GetType() == MenuNode::ENTRY)
+                          help = GetLongHelp(n->GetMenuEntry()->GetHelp2());
+                       else
+                          help = GetLongHelp(n->GetMenu()->GetHelp2());
+
+                       if (help != NULL) {
+                          eOSState newState = AddSubMenu(new cMenuText(tr("Help"), help, fontFix));
+                          free(help);
+                          return(newState);
+                          }
+                       }
+                    break;
+     case kGreen:
+                    break;
+     case kYellow:
+                    break;
+     case kBlue:
+                    break;
+     case kRight:
+                    if (n!= NULL &&
+                        n->GetType() == MenuNode::ENTRY &&
+                       (n->GetMenuEntry()->GetType() == Util::TEXT ||
+                        n->GetMenuEntry()->GetType() == Util::NUMBER_TEXT ||
+                        n->GetMenuEntry()->GetType() == Util::HEX ||
+                        n->GetMenuEntry()->GetType() == Util::NUMBER)
+                        )
+                        _editItem = true;
+                    break;
+
+     default:
+                    if (n!= NULL) {
+                       if (n->GetType() == MenuNode::ENTRY) {
+                          SetStatus(n->GetMenuEntry()->GetHelp1());
+                          if (n->GetMenuEntry()->GetHelp2() != NULL)
+                             SetHelp(tr("Help"), NULL, NULL, NULL);
+                          else
+                             SetHelp(NULL, NULL, NULL, NULL);
+                          }
+                       else {
+                          SetStatus(n->GetMenu()->GetHelp1());
+                          if (n->GetMenu()->GetHelp2() != NULL)
+                             SetHelp(tr("Help"), NULL, NULL, NULL);
+                          else
+                             SetHelp(NULL, NULL, NULL, NULL);
+                          }
+                       }
+                    else
+                       SetStatus(NULL);
+                    break;
+     }
+   return state;
+}
+
+void cSetupGenericMenu::ExecuteCommand( const char * cmd )
+{
+  char *tmp=NULL;
+  int   status=0;
+
+  if (cmd != NULL) {
+     asprintf(&tmp, "%s: %s", tr("Execute"), cmd);
+     SetStatus(tmp);
+     free(tmp);
+     status=system(cmd);
+     if (status == -1)
+        DEBUG3("%s: fork of command %s failed\n", DBG_PREFIX, cmd);
+     else {
+       if (WEXITSTATUS(status) != 0)
+          DEBUG4("%s: executing of command %s returned=%d\n", DBG_PREFIX, cmd, WEXITSTATUS(status));
+       }
+     }
+}
+
+
+
+
+//#############################################################################################
+// cSetupMenu
+//#############################################################################################
+
+
+cSetupMenu::cSetupMenu() : cOsdMenu(tr("Setup"))
+{
+  char *configFile=NULL;
+
+  SetCols(20);
+#if VDRVERSNUM < 10507
+  asprintf(&configFile, "%s/setup/vdr-setup.%i.xml", cPlugin::ConfigDirectory(), Setup.OSDLanguage);
+#else
+  asprintf(&configFile, "%s/setup/vdr-setup.%s.xml", cPlugin::ConfigDirectory(), Setup.OSDLanguage);
+#endif
+  if (access(configFile, 06) == -1)
+     asprintf(&configFile, "%s/setup/vdr-setup.xml", cPlugin::ConfigDirectory());
+  isyslog("setup: loading %s", configFile);
+
+  _config    = new Config( configFile );
+  free(configFile);
+
+  _number    = 0;
+  _error     = false;
+  _childLock = false;
+  _childLockEntered = NULL;
+  _childLockEnteredHidden = NULL;
+
+  if (_config != NULL && _config->LoadFile() == true) {
+     if (_config->GetChildLock() != NULL && strcmp(_config->GetChildLock(), "0000") != 0) {
+        _childLock = true;
+        _childLockEntered          = Util::Strdupnew(_config->GetChildLock());
+        _childLockEntered[0]       = '\0';
+        _childLockEnteredHidden    = Util::Strdupnew(_config->GetChildLock());
+        _childLockEnteredHidden[0] = '\0';
+        SetAskChildCode();
+        }
+     else
+        Set();
+     }
+  else {
+     SetStatus(tr("Error in configuration files"));
+     _error = true;
+     }
+}
+
+
+cSetupMenu::~cSetupMenu()
+{
+  delete _config;
+  delete []_childLockEntered;
+  delete [] _childLockEnteredHidden;
+}
+
+/**
+ * 
+ */
+void cSetupMenu::Set( )
+{
+  int current  = Current();
+  Menus     *m = _config->GetMenus();
+  MenuNode  *n = NULL;
+
+  Clear();
+  SetHasHotkeys();
+
+  // Customized Setup Menus
+  for (int i=0; i< m->GetNr(); i++) {
+      n = m->GetMenuNode(i);
+      char *tmp = NULL;
+      asprintf(&tmp, "%s%s", n->GetName(), setupSetup._menuSuffix);
+      Add(new cOsdItem (hk(tmp)));
+      free(tmp);
+      }
+  SetCurrent(Get(current));
+  SetHelp(NULL, NULL, trVDR("Restart"), tr("Reboot"));
+
+  Display();
+}
+
+/**
+ * Ask the user for the secret Child Code
+ */
+void cSetupMenu::SetAskChildCode( )
+{
+  Clear();
+  char *tmp = NULL;
+  asprintf(&tmp, "%s%s", tr("Enter Pin: "), _childLockEnteredHidden);
+  Add(new cOsdItem (tmp));
+  free(tmp);
+  Display();
+}
+
+
+
+
+/**
+ * Procss Key
+ * @param Key 
+ * @return 
+ */
+eOSState cSetupMenu::ProcessKey( eKeys Key )
+{
+  if (_childLock)
+     return(GetCodeProcessKey(Key));
+  else
+     return(StandardProcessKey(Key));
+}
+
+/**
+ * Standard Key Processing
+ * @param Key 
+ * @return 
+ */
+eOSState cSetupMenu::StandardProcessKey( eKeys Key )
+{
+    bool HadSubMenu = HasSubMenu();
+
+    eOSState state = cOsdMenu::ProcessKey(Key);
+
+    if (HasSubMenu() || HadSubMenu)
+       return(state);
+
+    int current = Current();
+    MenuNode *node = _config->GetMenus()->GetMenuNode(current);
+    switch (Key) {
+      case kOk :
+                      if (node != NULL) {
+                         if (node->GetType() == MenuNode::MENU) {
+                            return AddSubMenu(new cSetupGenericMenu(node->GetName(), node, _config));
+                            }
+                         else if (node->GetType() == MenuNode::MENUSYSTEM) {
+                            cOsdMenu * menu =cSetupSystemMenu::GetSystemMenu (hk(node->GetMenu()->GetSystem()), _config);
+                            if (menu != NULL)
+                               AddSubMenu(menu);
+                            }
+                         SetCurrent(Get(current));
+                         return(osContinue);
+                         }
+                      break;
+      case kRed:
+                      {
+                         char *help = NULL;
+                         if (node->GetType() == MenuNode::ENTRY)
+                            help = GetLongHelp(node->GetMenuEntry()->GetHelp2());
+                         else
+                            help = GetLongHelp(node->GetMenu()->GetHelp2());
+
+                         if (help != NULL) {
+                            eOSState newState = AddSubMenu(new cMenuText(tr("Help"), help, fontFix));
+                            free(help);
+                            return(newState);
+                            }
+
+                         }
+                      break;
+      case kYellow:
+                      if (Interface->Confirm(cRecordControls::Active() ? trVDR("Recording - restart anyway?") : trVDR("Really restart?"))) {
+#if APIVERSNUM >= 10501
+                         ShutdownHandler.RequestEmergencyExit();
+#else
+                         cThread::EmergencyExit(true);
+#endif
+                         return osEnd;
+                         }
+                      return osContinue;
+                      break;
+      case kBlue:
+                      if (Interface->Confirm(cRecordControls::Active() ? trVDR("Recording - restart anyway?") : tr("Really reboot?"))) {
+#if APIVERSNUM >= 10501
+                         ShutdownHandler.RequestEmergencyExit();
+#else
+                         cThread::EmergencyExit(true);
+#endif
+                         system(_config->GetBootLinux());
+                         }
+                      return osContinue;
+                      break;
+
+      case kNone:
+                      break;
+
+      default:
+                      if (node!= NULL) {
+                         if (node->GetType() == MenuNode::ENTRY) {
+                            SetStatus(node->GetMenuEntry()->GetHelp1());
+                            if (node->GetMenuEntry()->GetHelp2() != NULL)
+                               SetHelp(tr("Help"), NULL, trVDR("Restart"), tr("Reboot"));
+                            else
+                               SetHelp(NULL, NULL, trVDR("Restart"), tr("Reboot"));
+                            }
+                         else {
+                            SetStatus( node->GetMenu()->GetHelp1());
+                            if (node->GetMenu()->GetHelp2() != NULL)
+                               SetHelp(tr("Help"), NULL, trVDR("Restart"), tr("Reboot"));
+                            else
+                               SetHelp(NULL, NULL, trVDR("Restart"), tr("Reboot"));
+                            }
+                         }
+                      else
+                         SetStatus(NULL);
+                      break;
+      }
+    return state;
+
+}
+
+
+
+/**
+ * Key Processing for fetching Secret Code
+ * @param Key 
+ * @return 
+ */
+eOSState cSetupMenu::GetCodeProcessKey( eKeys Key )
+{
+  int num;
+  eOSState state = cOsdMenu::ProcessKey(Key);
+
+  switch (Key) {
+    case k0 ... k9:
+                num = Key - k0;
+                sprintf(_childLockEntered, "%s%d", _childLockEntered, num);
+                sprintf(_childLockEnteredHidden, "%s*", _childLockEnteredHidden);
+                SetAskChildCode();
+                if (strlen(_childLockEntered) == strlen(_config->GetChildLock())) {
+                   if (strcmp(_childLockEntered,_config->GetChildLock()) == 0) {
+                      _childLock=false;
+                      Set();
+                      }
+                   else {
+                      _childLockEntered[0] = '\0';
+                      _childLockEnteredHidden[0] = '\0';
+                      SetStatus(tr("Invalid Pin!"));
+                      }
+                   }
+                else {
+                   SetStatus(NULL);
+                   }
+                break;
+
+
+    case kBack:
+                return osBack;
+                break;
+    case kNone:
+                break;
+    default:
+                SetStatus(NULL);
+                break;
+    }
+  return state;
+}
+
+//
+char * cSetupMenu::GetLongHelp( const char * help )
+{
+  char *helpfile = NULL;
+  char *result = NULL;
+
+  if (help != NULL) {
+     asprintf(&helpfile, "%s/setup/help/%s", cPlugin::ConfigDirectory(), help);
+     FILE *fp = fopen(helpfile, "r");
+     if (fp != NULL) {
+        fseek(fp, 0L, SEEK_END);
+
+        long len = ftell(fp);
+        fseek(fp, 0L, SEEK_SET);
+        int byteRead = 0;
+        if ((result = (char*) malloc(len+1)) == NULL)
+           DEBUG3("%s: can not allocate buffer for Helpfile: %s\n", DBG_PREFIX, helpfile );
+        else
+        if ((byteRead = fread(result, 1, len, fp)) == -1)
+           DEBUG3("%s: can not read file: Helpfile: %s\n", DBG_PREFIX, helpfile);
+        else
+           result[byteRead] = '\0';
+        fclose(fp);
+        }
+     else
+        DEBUG4("%s: can not open Helpfile: %s, %s\n", DBG_PREFIX, helpfile, strerror(errno));
+     free(helpfile);
+     }
+  return(result);
+}
+
+
+
+
Index: vdr-2.2.0/PLUGINS/src/setup/setupmenu.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/setupmenu.h	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,118 @@
+/*********************************************************
+ * DESCRIPTION: 
+ *             Header File
+ *
+ * $Id: setupmenu.h,v 1.15 2005/10/12 13:44:14 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ *********************************************************/
+
+#ifndef SETUPMENU_H
+#define SETUPMENU_H
+#include <vdr/menu.h>
+#include <vdr/interface.h>
+#include <vdr/submenu.h>
+#include "config.h"
+/**
+@author Ralf Dotzert
+*/
+class cSetupPluginParameter : public cOsdMenu
+{
+  private:
+    Plugin  *_plugin;
+    char     _editParameter[500];
+    bool     _edit;
+  public:
+    cSetupPluginParameter(const char *title, Plugin *plugin);
+    ~cSetupPluginParameter();
+    void  Set();
+    eOSState ProcessKey(eKeys Key);
+};
+
+
+
+class cSetupPluginMenu : public cOsdMenu
+{
+private:
+    Config  *_config;
+    Plugins *_plugins;
+    int      _startIndex;
+    bool     _moveMode;
+    bool     _sortMode;
+public:
+    cSetupPluginMenu(Config  *config);
+    ~cSetupPluginMenu();
+    void  Set();
+    eOSState ProcessKey(eKeys Key);
+    void setHelp();
+};
+
+
+
+class cSetupVdrMenu : public cOsdMenu
+{
+private:
+    enum MenuState { UNDEFINED, MOVE, CREATE, CREATECMD, EDIT, DELETE};
+    cSubMenu  _vdrSubMenu;
+    char      *createMenuName(cSubMenuNode *node);
+    void      setHelp();
+    MenuState _menuState;
+
+    int       _startIndex;
+    int       _createEditNodeIndex;
+
+    char      _editTitle[50];
+    char      _editCommand[999];
+    int       _hasToConfirm;
+    int       _isThread;
+public:
+    cSetupVdrMenu(const char *title);
+
+    ~cSetupVdrMenu();
+    void  Set();
+    eOSState ProcessKey(eKeys Key);
+};
+
+
+class cSetupMenu : public cOsdMenu
+{
+private:
+
+   int  _number;
+   bool _error;
+   bool _childLock;
+   char *_childLockEntered;
+   char *_childLockEnteredHidden;
+
+protected:
+   Config *_config;
+public:
+    cSetupMenu();
+    ~cSetupMenu();
+    void Set();
+    void SetAskChildCode();
+    eOSState ProcessKey(eKeys Key);
+    eOSState StandardProcessKey(eKeys Key);
+    eOSState GetCodeProcessKey(eKeys Key);
+    char *GetLongHelp(const char* help);
+};
+
+class cSetupGenericMenu : public cSetupMenu
+{
+  private:
+    MenuNode *_node;
+    bool      _editItem;
+    int       _currLine;
+    Config   *_config;
+    const char * nohk(const char *str);
+  public:
+    cSetupGenericMenu(const char *title, MenuNode *node, Config  *config);
+    ~cSetupGenericMenu();
+    void      Set();
+    eOSState  ProcessKey(eKeys Key);
+    void      ExecuteCommand(const char* cmd);
+};
+
+#endif
Index: vdr-2.2.0/PLUGINS/src/setup/setupsetup.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/setupsetup.c	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,98 @@
+/****************************************************************************
+ * DESCRIPTION:
+ *             Setup Dialog
+ *
+ * $Id: setupsetup.cpp,v 1.2 2005/10/12 13:44:14 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2005 by Ralf Dotzert
+ ****************************************************************************/
+
+
+#include <vdr/menu.h>
+#include <vdr/submenu.h>
+#include <string.h>
+
+#include "setupsetup.h"
+#include "debug.h"
+
+//*****************************************************************************
+// Setup Configuration
+//*****************************************************************************
+
+cSetupSetup::cSetupSetup()
+{
+  // Set Default Values
+  strcpy(_menuSuffix, " ...");
+  strcpy(_entryPrefix, "-");
+  DirectMenu = 0;
+  ReturnValue = 1;
+}
+
+bool cSetupSetup::SetupParse( const char *Name, const char *Value )
+{
+  if      (!strcasecmp(Name, "DirectMenu"))  DirectMenu = atoi(Value);
+  else if (!strcasecmp(Name, "MenuSuffix"))  snprintf(_menuSuffix, sizeof(_menuSuffix), Value);
+  else if (!strcasecmp(Name, "EntryPrefix")) snprintf(_entryPrefix, sizeof(_entryPrefix), Value);
+  else if (!strcasecmp(Name, "ReturnValue")) ReturnValue = atoi(Value);
+  else return false;
+
+  return true;
+}
+
+//*****************************************************************************
+// Setup Page
+//*****************************************************************************
+cSetupSetupPage::cSetupSetupPage( )
+{
+  ReturnValues[0]="true/false";
+  ReturnValues[1]="on/off";
+  ReturnValues[2]="yes/no";
+
+  Add(new cMenuEditBoolItem(tr("setupSetup$Main menu entry"), &setupSetup.DirectMenu, tr("Setup"), tr("Menu Edit")));
+  Add(new cMenuEditStrItem(tr("setupSetup$Menu suffix"),       setupSetup._menuSuffix, sizeof(setupSetup._menuSuffix),  trVDR(FileNameChars)));
+  Add(new cMenuEditStrItem(tr("setupSetup$Entry prefix"),      setupSetup._entryPrefix, sizeof(setupSetup._entryPrefix), trVDR(FileNameChars)));
+  Add(new cMenuEditStraItem(tr("setupSetup$Return value"),    &setupSetup.ReturnValue, 3, ReturnValues));
+}
+
+
+void cSetupSetupPage::Store( void )
+{
+  SetupStore("DirectMenu",      setupSetup.DirectMenu);
+  SetupStore("MenuSuffix",      setupSetup._menuSuffix);
+  SetupStore("EntryPrefix",     setupSetup._entryPrefix);
+  SetupStore("ReturnValue",     setupSetup.ReturnValue);
+}
+
+eOSState cSetupSetupPage::ProcessKey( eKeys Key )
+{
+  cSubMenu vdrSubMenu;
+  char *menuXML = NULL;
+  eOSState state = cOsdMenu::ProcessKey(Key);
+  if (state == osUnknown) {
+     switch (Key) {
+        case kOk: // Load Menu Configuration
+#if VDRVERSNUM < 10507
+                 asprintf(&menuXML, "%s/setup/vdr-menu.%i.xml", cPlugin::ConfigDirectory(), Setup.OSDLanguage);
+#else
+                 asprintf(&menuXML, "%s/setup/vdr-menu.%s.xml", cPlugin::ConfigDirectory(), Setup.OSDLanguage);
+#endif
+                 if (access(menuXML, 06) == -1)
+                    asprintf(&menuXML, "%s/setup/vdr-menu.xml", cPlugin::ConfigDirectory());
+                 if (vdrSubMenu.LoadXml(menuXML)) {
+                    isyslog("setup: saved setup to %s", menuXML);
+                    vdrSubMenu.SetMenuSuffix(setupSetup._menuSuffix);
+                    vdrSubMenu.SaveXml();
+                    }
+                 free(menuXML);
+                 Store();
+                 return osBack;
+        default: break;
+        }
+     state = osContinue;
+     }
+  return state;
+}
+
+
Index: vdr-2.2.0/PLUGINS/src/setup/setupsetup.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/setupsetup.h	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,52 @@
+/****************************************************************************
+ * DESCRIPTION:
+ *             Setup Dialog
+ *
+ * $Id: setupsetup.h,v 1.2 2005/10/12 13:44:14 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2005 by Ralf Dotzert
+ ****************************************************************************/
+
+
+#ifndef SETUPSETUP_H
+#define SETUPSETUP_H
+
+#include <vdr/plugin.h>
+
+/**
+@author Ralf Dotzert
+*/
+//*****************************************************************************
+// Setup Configuration
+//*****************************************************************************
+
+class cSetupSetup
+{
+  public:
+    char _menuSuffix[20];
+    char _entryPrefix[2];
+    int  DirectMenu;
+    int  ReturnValue;
+
+    cSetupSetup();
+    bool SetupParse(const char *Name, const char *Value);
+};
+
+extern cSetupSetup setupSetup;
+
+//*****************************************************************************
+// Setup Page
+//*****************************************************************************
+class cSetupSetupPage : public cMenuSetupPage
+{
+  private:
+    const char *ReturnValues[3];
+  public:
+    cSetupSetupPage();
+    void Store(void);
+    eOSState ProcessKey(eKeys Key);
+};
+
+#endif
Index: vdr-2.2.0/PLUGINS/src/setup/setupsystemmenu.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/setupsystemmenu.h	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,28 @@
+/*********************************************************
+ * DESCRIPTION: 
+ *             Header File
+ *
+ * $Id: setupsystemmenu.h,v 1.1 2005/10/12 13:44:14 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de        
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ *********************************************************/
+
+#ifndef SETUPSYSTEMMENU_H
+#define SETUPSYSTEMMENU_H
+
+#include <vdr/menu.h>
+#include <vdr/interface.h>
+#include <vdr/submenu.h>
+#include "config.h"
+
+class cSetupSystemMenu
+{
+public:
+  cSetupSystemMenu();
+  ~cSetupSystemMenu();
+  static cOsdMenu *GetSystemMenu(const char *sysCommand, Config  *config);
+};
+
+#endif
Index: vdr-2.2.0/PLUGINS/src/setup/sysconfig.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/sysconfig.c	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,299 @@
+/****************************************************************************
+ * DESCRIPTION: 
+ *             Handles sysconfig File
+ *
+ * $Id: sysconfig.cpp,v 1.6 2006/02/04 11:59:29 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ ****************************************************************************/
+
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include "vdr/plugin.h"
+#include "sysconfig.h"
+#include "debug.h"
+#include "util.h"
+
+
+
+Variable::Variable( )
+{
+  _name  = NULL;
+  _value = NULL;
+}
+
+Variable::~ Variable( )
+{
+  delete [] _name;
+  delete [] _value;
+}
+
+
+
+
+void Variable::SetName( const char * nam )
+{
+  delete [] _name;
+ _name = Util::Strdupnew(nam);
+}
+
+const char * Variable::GetName( )
+{
+  return(_name);
+}
+
+void Variable::SetValue( const char * val )
+{
+  delete [] _value;
+  _value =  Util::Strdupnew(val);
+}
+
+const char * Variable::GetValue( )
+{
+  return(_value);
+}
+/**
+ * print Variable
+ */
+void Variable::Print( )
+{
+  printf("Name=");
+  if( _name == NULL)
+    printf("NULL");
+  else
+    printf(_name);
+
+  printf(" Value=");
+  if( _value == NULL)
+    printf("NULL");
+  else
+    printf(_value);
+  printf("\n"); 
+}
+
+
+
+
+//------------------------------------------------------
+
+Variable * Sysconfig::_variables=NULL;
+int        Sysconfig::_nr =0;
+char      *Sysconfig::_filename=NULL;
+
+Sysconfig::Sysconfig()
+{
+  _variables = NULL;
+  _filename  = NULL;
+  _nr        = 0;
+}
+
+
+Sysconfig::~Sysconfig()
+{
+  destroy();
+}
+
+void Sysconfig::destroy( )
+{
+
+  delete [] _variables;
+  delete [] _filename;
+
+  _variables=NULL;
+  _filename=NULL;
+  _nr=0;
+}
+
+
+
+bool Sysconfig::LoadFile( const char*fname)
+{
+   bool result = true;
+   const char * line;
+   destroy();
+   _filename = Util::Strdupnew(fname);
+   FILE * fp = fopen(fname, "r");
+
+   if( fp != NULL)
+   {
+     while( (line = readLine(fp)) != NULL)
+     {
+       addLine(line);
+       delete [] line;
+     }
+    
+     fclose(fp);
+   }
+   else
+   {
+     DEBUG4("%s: Could not read file: %s, errno=%d\n", DBG_PREFIX, _filename, errno);
+   }
+
+   return(result);
+}
+
+/**
+ * Save Sysconfig file
+ * @return true on success
+ */
+bool Sysconfig::SaveFile( )
+{
+  bool result=true;
+   FILE * fp = fopen(_filename, "w");
+   if(fp != NULL)
+   {
+     fprintf(fp, "#\n\
+# Generated by Setup-Plugin, \n\
+# (c) 2005,2006 by Ralf Dotzert\n\
+#\n\n");
+     for(int i=0; i< _nr; i++)
+     {
+       fprintf(fp, "%s=\"%s\"\n", _variables[i].GetName(), _variables[i].GetValue());
+     }
+     fclose(fp);
+   }
+   else
+    {
+     DEBUG4("%s: Could not write file: %s, errno=%d\n", DBG_PREFIX, _filename, errno);
+     result=false;
+    }
+  return(result);
+}
+
+/**
+ * read one line from opened file
+ * @param fp opened filepointer
+ * @return null if EOF or allocated character String holding one line
+ */
+const char * Sysconfig::readLine( FILE * fp )
+{
+  char myChar;
+  char buf[1024];
+  int  i=0;
+  int  maxLen = (int) sizeof(buf)-1;
+  char *line=NULL;
+  while((myChar=fgetc(fp)) != EOF )
+  {
+    if(myChar=='\n' || i==maxLen)
+    {
+       line = new char[i+1];
+       strncpy(line, buf, i);
+       line[i]='\0';
+       return(line);
+    }
+    else
+      buf[i++]=myChar;
+  }
+  return((const char*)line);
+}
+
+/**
+ * Add the given line from sysconfig file an split it in Name an Variable
+ * @param line allocated buffer holding one line
+ */
+void Sysconfig::addLine(const char * line )
+{
+  char *nam=NULL;
+  char *val=NULL;
+  if(strlen(line)>0 && line[0] != '#' ) // comment line
+  {
+    if( (nam =strtok((char*)line, "=")) != NULL &&
+        ( val=strtok(NULL, "\"")) != NULL )
+    {
+      addVariable(nam, val);
+    }
+  }
+  
+ 
+}
+
+/**
+ * add new Variable to internal Variable list
+ * @param name specifiesd the name of the variables
+ * @param value specifies the value of the variable
+ */
+void Sysconfig::addVariable( const char * name, const char * value )
+{
+    Variable *v = new Variable[_nr+1];
+ 
+    //copy existing Array elements
+    for(int i=0; i<_nr; i++)
+    {
+    //    v[i] = variables[i];
+     v[i].SetName(_variables[i].GetName());
+     v[i].SetValue(_variables[i].GetValue());
+    }
+
+    delete []_variables;
+
+    v[_nr].SetName(name);
+    v[_nr].SetValue(value);
+    _variables=v;
+    _nr++;  
+}
+
+
+
+/**
+ * 
+ */
+void Sysconfig::Print( )
+{
+  for(int i=0; i<_nr; i++)
+    _variables[i].Print();
+}
+
+/**
+ * Set or overwrite the specified variable
+ * @param name name of variable
+ * @param value value of variable
+ */
+void Sysconfig::SetVariable(const char * name, const char * value )
+{
+  bool found =false;
+  int  index=0;
+
+  for(int i=0; i<_nr && found==false; i++)
+  {
+    if( strcmp(name, _variables[i].GetName())==0 )
+    {
+      found=true;
+      index=i;
+    }
+  }
+  if( found)
+    _variables[index].SetValue(value);
+  else
+    addVariable(name, value);
+}
+
+/**
+ * returns the current filename of the sysconfig
+ * @return return filename
+ */
+char * Sysconfig::GetFileName( )
+{
+  return(_filename);
+}
+
+const char * Sysconfig::GetVariable( const char * name )
+{
+  bool found =false;
+  int  index=0;
+
+  for(int i=0; i<_nr && found==false; i++)
+  {
+    if( strcmp(name, _variables[i].GetName())==0 )
+    {
+      found=true;
+      index=i;
+    }
+  }
+  if( found)
+    return(_variables[index].GetValue());
+  else
+    return(NULL);
+}
Index: vdr-2.2.0/PLUGINS/src/setup/sysconfig.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/sysconfig.h	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,58 @@
+/*********************************************************
+ * DESCRIPTION: 
+ *             Header File
+ *
+ * $Id: sysconfig.h,v 1.4 2005/10/12 13:44:14 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ *********************************************************/
+
+#ifndef SYSCONFIG_H
+#define SYSCONFIG_H
+
+
+
+/**
+@author Ralf Dotzert
+*/
+class Variable{
+const char *_name;
+const char *_value;
+public:
+    Variable();
+    ~Variable();
+    void SetName(const char *name);
+    const char *GetName();
+    void SetValue(const char *value);
+    const char *GetValue();
+    void Print();
+};
+
+
+
+class Sysconfig{
+static Variable *_variables;
+static  int       _nr;
+static char     *_filename;
+public:
+    Sysconfig();
+    ~Sysconfig();
+     void destroy();
+     bool LoadFile(const char*fname);
+     bool SaveFile();
+     void Print();
+     void SetVariable(const char* name, const char*value);
+    static const char *GetVariable(const char *name);
+     char *GetFileName();
+private:
+     const char *readLine(FILE *fp);
+     void addLine(const char *line);
+     void addVariable(const char *name, const char *value);
+};
+
+
+
+
+#endif
Index: vdr-2.2.0/PLUGINS/src/setup/tinystr.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/tinystr.c	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,299 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+
+#ifndef TIXML_USE_STL
+
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+
+#include "tinystr.h"
+
+// TiXmlString constructor, based on a C string
+TiXmlString::TiXmlString (const char* instring)
+{
+    unsigned newlen;
+    char * newstring;
+
+    if (!instring)
+    {
+        allocated = 0;
+        cstring = NULL;
+        current_length = 0;
+        return;
+    }
+    newlen = strlen (instring) + 1;
+    newstring = new char [newlen];
+    memcpy (newstring, instring, newlen);
+    // strcpy (newstring, instring);
+    allocated = newlen;
+    cstring = newstring;
+    current_length = newlen - 1;
+}
+
+// TiXmlString copy constructor
+TiXmlString::TiXmlString (const TiXmlString& copy)
+{
+    unsigned newlen;
+    char * newstring;
+
+	// Prevent copy to self!
+	if ( &copy == this )
+		return;
+
+    if (! copy . allocated)
+    {
+        allocated = 0;
+        cstring = NULL;
+        current_length = 0;
+        return;
+    }
+    newlen = copy . length () + 1;
+    newstring = new char [newlen];
+    // strcpy (newstring, copy . cstring);
+    memcpy (newstring, copy . cstring, newlen);
+    allocated = newlen;
+    cstring = newstring;
+    current_length = newlen - 1;
+}
+
+// TiXmlString = operator. Safe when assign own content
+void TiXmlString ::operator = (const char * content)
+{
+    unsigned newlen;
+    char * newstring;
+
+    if (! content)
+    {
+        empty_it ();
+        return;
+    }
+    newlen = strlen (content) + 1;
+    newstring = new char [newlen];
+    // strcpy (newstring, content);
+    memcpy (newstring, content, newlen);
+    empty_it ();
+    allocated = newlen;
+    cstring = newstring;
+    current_length = newlen - 1;
+}
+
+// = operator. Safe when assign own content
+void TiXmlString ::operator = (const TiXmlString & copy)
+{
+    unsigned newlen;
+    char * newstring;
+
+    if (! copy . length ())
+    {
+        empty_it ();
+        return;
+    }
+    newlen = copy . length () + 1;
+    newstring = new char [newlen];
+    // strcpy (newstring, copy . c_str ());
+    memcpy (newstring, copy . c_str (), newlen);
+    empty_it ();
+    allocated = newlen;
+    cstring = newstring;
+    current_length = newlen - 1;
+}
+
+
+// append a const char * to an existing TiXmlString
+void TiXmlString::append( const char* str, int len )
+{
+    char * new_string;
+    unsigned new_alloc, new_size, size_suffix;
+
+	// don't use strlen - it can overrun the len passed in!
+	const char* p = str;
+	size_suffix = 0;
+
+	while ( *p && size_suffix < (unsigned)len )
+	{
+		++p;
+		++size_suffix;
+	}
+    if ( !size_suffix)
+        return;
+
+    new_size = length () + size_suffix + 1;
+    // check if we need to expand
+    if (new_size > allocated)
+    {
+        // compute new size
+        new_alloc = assign_new_size (new_size);
+
+        // allocate new buffer
+        new_string = new char [new_alloc];
+        new_string [0] = 0;
+
+        // copy the previous allocated buffer into this one
+        if (allocated && cstring)
+            // strcpy (new_string, cstring);
+            memcpy (new_string, cstring, length ());
+
+        // append the suffix. It does exist, otherwize we wouldn't be expanding
+        // strncat (new_string, str, len);
+        memcpy (new_string + length (),
+                str,
+                size_suffix);
+
+        // return previsously allocated buffer if any
+        if (allocated && cstring)
+            delete [] cstring;
+
+        // update member variables
+        cstring = new_string;
+        allocated = new_alloc;
+    }
+    else
+    {
+        // we know we can safely append the new string
+        // strncat (cstring, str, len);
+        memcpy (cstring + length (),
+                str,
+                size_suffix);
+    }
+    current_length = new_size - 1;
+    cstring [current_length] = 0;
+}
+
+
+// append a const char * to an existing TiXmlString
+void TiXmlString::append( const char * suffix )
+{
+    char * new_string;
+    unsigned new_alloc, new_size;
+
+    new_size = length () + strlen (suffix) + 1;
+    // check if we need to expand
+    if (new_size > allocated)
+    {
+        // compute new size
+        new_alloc = assign_new_size (new_size);
+
+        // allocate new buffer
+        new_string = new char [new_alloc];
+        new_string [0] = 0;
+
+        // copy the previous allocated buffer into this one
+        if (allocated && cstring)
+            memcpy (new_string, cstring, 1 + length ());
+            // strcpy (new_string, cstring);
+
+        // append the suffix. It does exist, otherwize we wouldn't be expanding
+        // strcat (new_string, suffix);
+        memcpy (new_string + length (),
+                suffix,
+                strlen (suffix) + 1);
+
+        // return previsously allocated buffer if any
+        if (allocated && cstring)
+            delete [] cstring;
+
+        // update member variables
+        cstring = new_string;
+        allocated = new_alloc;
+    }
+    else
+    {
+        // we know we can safely append the new string
+        // strcat (cstring, suffix);
+        memcpy (cstring + length (),
+                suffix,
+                strlen (suffix) + 1);
+    }
+    current_length = new_size - 1;
+}
+
+// Check for TiXmlString equuivalence
+//bool TiXmlString::operator == (const TiXmlString & compare) const
+//{
+//    return (! strcmp (c_str (), compare . c_str ()));
+//}
+
+//unsigned TiXmlString::length () const
+//{
+//    if (allocated)
+//        // return strlen (cstring);
+//        return current_length;
+//    return 0;
+//}
+
+
+unsigned TiXmlString::find (char tofind, unsigned offset) const
+{
+    char * lookup;
+
+    if (offset >= length ())
+        return (unsigned) notfound;
+    for (lookup = cstring + offset; * lookup; lookup++)
+        if (* lookup == tofind)
+            return lookup - cstring;
+    return (unsigned) notfound;
+}
+
+
+bool TiXmlString::operator == (const TiXmlString & compare) const
+{
+	if ( allocated && compare.allocated )
+	{
+		assert( cstring );
+		assert( compare.cstring );
+		return ( strcmp( cstring, compare.cstring ) == 0 );
+ 	}
+	return false;
+}
+
+
+bool TiXmlString::operator < (const TiXmlString & compare) const
+{
+	if ( allocated && compare.allocated )
+	{
+		assert( cstring );
+		assert( compare.cstring );
+		return ( strcmp( cstring, compare.cstring ) > 0 );
+ 	}
+	return false;
+}
+
+
+bool TiXmlString::operator > (const TiXmlString & compare) const
+{
+	if ( allocated && compare.allocated )
+	{
+		assert( cstring );
+		assert( compare.cstring );
+		return ( strcmp( cstring, compare.cstring ) < 0 );
+ 	}
+	return false;
+}
+
+
+#endif	// TIXML_USE_STL
Index: vdr-2.2.0/PLUGINS/src/setup/tinystr.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/tinystr.h	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,242 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original file by Yves Berquin.
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+
+
+#ifndef TIXML_USE_STL
+
+#ifndef TIXML_STRING_INCLUDED
+#define TIXML_STRING_INCLUDED
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4786 )	// Debugger truncating names.
+#endif
+
+#include <assert.h>
+
+/*
+   TiXmlString is an emulation of the std::string template.
+   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.
+   Only the member functions relevant to the TinyXML project have been implemented.
+   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase
+   a string and there's no more room, we allocate a buffer twice as big as we need.
+*/
+class TiXmlString
+{
+  public :
+    // TiXmlString constructor, based on a string
+    TiXmlString (const char * instring);
+
+    // TiXmlString empty constructor
+    TiXmlString ()
+    {
+        allocated = 0;
+        cstring = NULL;
+        current_length = 0;
+    }
+
+    // TiXmlString copy constructor
+    TiXmlString (const TiXmlString& copy);
+
+    // TiXmlString destructor
+    ~ TiXmlString ()
+    {
+        empty_it ();
+    }
+
+    // Convert a TiXmlString into a classical char *
+    const char * c_str () const
+    {
+        if (allocated)
+            return cstring;
+        return "";
+    }
+
+    // Return the length of a TiXmlString
+    unsigned length () const
+	{
+		return ( allocated ) ? current_length : 0;
+	}
+
+    // TiXmlString = operator
+    void operator = (const char * content);
+
+    // = operator
+    void operator = (const TiXmlString & copy);
+
+    // += operator. Maps to append
+    TiXmlString& operator += (const char * suffix)
+    {
+        append (suffix);
+		return *this;
+    }
+
+    // += operator. Maps to append
+    TiXmlString& operator += (char single)
+    {
+        append (single);
+		return *this;
+    }
+
+    // += operator. Maps to append
+    TiXmlString& operator += (TiXmlString & suffix)
+    {
+        append (suffix);
+		return *this;
+    }
+    bool operator == (const TiXmlString & compare) const;
+    bool operator < (const TiXmlString & compare) const;
+    bool operator > (const TiXmlString & compare) const;
+
+    // Checks if a TiXmlString is empty
+    bool empty () const
+    {
+        return length () ? false : true;
+    }
+
+    // single char extraction
+    const char& at (unsigned index) const
+    {
+        assert( index < length ());
+        return cstring [index];
+    }
+
+    // find a char in a string. Return TiXmlString::notfound if not found
+    unsigned find (char lookup) const
+    {
+        return find (lookup, 0);
+    }
+
+    // find a char in a string from an offset. Return TiXmlString::notfound if not found
+    unsigned find (char tofind, unsigned offset) const;
+
+    /*	Function to reserve a big amount of data when we know we'll need it. Be aware that this
+		function clears the content of the TiXmlString if any exists.
+    */
+    void reserve (unsigned size)
+    {
+        empty_it ();
+        if (size)
+        {
+            allocated = size;
+            cstring = new char [size];
+            cstring [0] = 0;
+            current_length = 0;
+        }
+    }
+
+    // [] operator
+    char& operator [] (unsigned index) const
+    {
+        assert( index < length ());
+        return cstring [index];
+    }
+
+    // Error value for find primitive
+    enum {	notfound = 0xffffffff,
+            npos = notfound };
+
+    void append (const char *str, int len );
+
+  protected :
+
+    // The base string
+    char * cstring;
+    // Number of chars allocated
+    unsigned allocated;
+    // Current string size
+    unsigned current_length;
+
+    // New size computation. It is simplistic right now : it returns twice the amount
+    // we need
+    unsigned assign_new_size (unsigned minimum_to_allocate)
+    {
+        return minimum_to_allocate * 2;
+    }
+
+    // Internal function that clears the content of a TiXmlString
+    void empty_it ()
+    {
+        if (cstring)
+            delete [] cstring;
+        cstring = NULL;
+        allocated = 0;
+        current_length = 0;
+    }
+
+    void append (const char *suffix );
+
+    // append function for another TiXmlString
+    void append (const TiXmlString & suffix)
+    {
+        append (suffix . c_str ());
+    }
+
+    // append for a single char.
+    void append (char single)
+    {
+        if ( cstring && current_length < (allocated-1) )
+		{
+			cstring[ current_length ] = single;
+			++current_length;
+			cstring[ current_length ] = 0;
+		}
+		else
+		{
+			char smallstr [2];
+			smallstr [0] = single;
+			smallstr [1] = 0;
+			append (smallstr);
+		}
+    }
+
+} ;
+
+/*
+   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.
+   Only the operators that we need for TinyXML have been developped.
+*/
+class TiXmlOutStream : public TiXmlString
+{
+public :
+    TiXmlOutStream () : TiXmlString () {}
+
+    // TiXmlOutStream << operator. Maps to TiXmlString::append
+    TiXmlOutStream & operator << (const char * in)
+    {
+        append (in);
+        return (* this);
+    }
+
+    // TiXmlOutStream << operator. Maps to TiXmlString::append
+    TiXmlOutStream & operator << (const TiXmlString & in)
+    {
+        append (in . c_str ());
+        return (* this);
+    }
+} ;
+
+#endif	// TIXML_STRING_INCLUDED
+#endif	// TIXML_USE_STL
Index: vdr-2.2.0/PLUGINS/src/setup/tinyxml.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/tinyxml.c	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,1427 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include <ctype.h>
+#include "tinyxml.h"
+
+#ifdef TIXML_USE_STL
+#include <sstream>
+#endif
+
+
+bool TiXmlBase::condenseWhiteSpace = true;
+
+void TiXmlBase::PutString( const TIXML_STRING& str, TIXML_OSTREAM* stream )
+{
+	TIXML_STRING buffer;
+	PutString( str, &buffer );
+	(*stream) << buffer;
+}
+
+void TiXmlBase::PutString( const TIXML_STRING& str, TIXML_STRING* outString )
+{
+	int i=0;
+
+	while( i<(int)str.length() )
+	{
+		unsigned char c = (unsigned char) str[i];
+
+		if (    c == '&'
+		     && i < ( (int)str.length() - 2 )
+			 && str[i+1] == '#'
+			 && str[i+2] == 'x' )
+		{
+			// Hexadecimal character reference.
+			// Pass through unchanged.
+			// &#xA9;	-- copyright symbol, for example.
+			//
+			// The -1 is a bug fix from Rob Laveaux. It keeps
+			// an overflow from happening if there is no ';'.
+			// There are actually 2 ways to exit this loop -
+			// while fails (error case) and break (semicolon found).
+			// However, there is no mechanism (currently) for
+			// this function to return an error.
+			while ( i<(int)str.length()-1 )
+			{
+				outString->append( str.c_str() + i, 1 );
+				++i;
+				if ( str[i] == ';' )
+					break;
+			}
+		}
+		else if ( c == '&' )
+		{
+			outString->append( entity[0].str, entity[0].strLength );
+			++i;
+		}
+		else if ( c == '<' )
+		{
+			outString->append( entity[1].str, entity[1].strLength );
+			++i;
+		}
+		else if ( c == '>' )
+		{
+			outString->append( entity[2].str, entity[2].strLength );
+			++i;
+		}
+		else if ( c == '\"' )
+		{
+			outString->append( entity[3].str, entity[3].strLength );
+			++i;
+		}
+		else if ( c == '\'' )
+		{
+			outString->append( entity[4].str, entity[4].strLength );
+			++i;
+		}
+		else if ( c < 32 )
+		{
+			// Easy pass at non-alpha/numeric/symbol
+			// Below 32 is symbolic.
+			char buf[ 32 ];
+			sprintf( buf, "&#x%02X;", (unsigned) ( c & 0xff ) );
+			outString->append( buf, strlen( buf ) );
+			++i;
+		}
+		else
+		{
+			//char realc = (char) c;
+			//outString->append( &realc, 1 );
+			*outString += (char) c;	// somewhat more efficient function call.
+			++i;
+		}
+	}
+}
+
+
+// <-- Strange class for a bug fix. Search for STL_STRING_BUG
+TiXmlBase::StringToBuffer::StringToBuffer( const TIXML_STRING& str )
+{
+	buffer = new char[ str.length()+1 ];
+	if ( buffer )
+	{
+		strcpy( buffer, str.c_str() );
+	}
+}
+
+
+TiXmlBase::StringToBuffer::~StringToBuffer()
+{
+	delete [] buffer;
+}
+// End strange bug fix. -->
+
+
+TiXmlNode::TiXmlNode( NodeType _type ) : TiXmlBase()
+{
+	parent = 0;
+	type = _type;
+	firstChild = 0;
+	lastChild = 0;
+	prev = 0;
+	next = 0;
+}
+
+
+TiXmlNode::~TiXmlNode()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}
+}
+
+
+void TiXmlNode::CopyTo( TiXmlNode* target ) const
+{
+	target->SetValue (value.c_str() );
+	target->userData = userData;
+}
+
+
+void TiXmlNode::Clear()
+{
+	TiXmlNode* node = firstChild;
+	TiXmlNode* temp = 0;
+
+	while ( node )
+	{
+		temp = node;
+		node = node->next;
+		delete temp;
+	}
+
+	firstChild = 0;
+	lastChild = 0;
+}
+
+
+TiXmlNode* TiXmlNode::LinkEndChild( TiXmlNode* node )
+{
+	node->parent = this;
+
+	node->prev = lastChild;
+	node->next = 0;
+
+	if ( lastChild )
+		lastChild->next = node;
+	else
+		firstChild = node;			// it was an empty list.
+
+	lastChild = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertEndChild( const TiXmlNode& addThis )
+{
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+
+	return LinkEndChild( node );
+}
+
+
+TiXmlNode* TiXmlNode::InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis )
+{
+	if ( !beforeThis || beforeThis->parent != this )
+		return 0;
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->next = beforeThis;
+	node->prev = beforeThis->prev;
+	if ( beforeThis->prev )
+	{
+		beforeThis->prev->next = node;
+	}
+	else
+	{
+		assert( firstChild == beforeThis );
+		firstChild = node;
+	}
+	beforeThis->prev = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::InsertAfterChild( TiXmlNode* afterThis, const TiXmlNode& addThis )
+{
+	if ( !afterThis || afterThis->parent != this )
+		return 0;
+
+	TiXmlNode* node = addThis.Clone();
+	if ( !node )
+		return 0;
+	node->parent = this;
+
+	node->prev = afterThis;
+	node->next = afterThis->next;
+	if ( afterThis->next )
+	{
+		afterThis->next->prev = node;
+	}
+	else
+	{
+		assert( lastChild == afterThis );
+		lastChild = node;
+	}
+	afterThis->next = node;
+	return node;
+}
+
+
+TiXmlNode* TiXmlNode::ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis )
+{
+	if ( replaceThis->parent != this )
+		return 0;
+
+	TiXmlNode* node = withThis.Clone();
+	if ( !node )
+		return 0;
+
+	node->next = replaceThis->next;
+	node->prev = replaceThis->prev;
+
+	if ( replaceThis->next )
+		replaceThis->next->prev = node;
+	else
+		lastChild = node;
+
+	if ( replaceThis->prev )
+		replaceThis->prev->next = node;
+	else
+		firstChild = node;
+
+	delete replaceThis;
+	node->parent = this;
+	return node;
+}
+
+
+bool TiXmlNode::RemoveChild( TiXmlNode* removeThis )
+{
+	if ( removeThis->parent != this )
+	{
+		assert( 0 );
+		return false;
+	}
+
+	if ( removeThis->next )
+		removeThis->next->prev = removeThis->prev;
+	else
+		lastChild = removeThis->prev;
+
+	if ( removeThis->prev )
+		removeThis->prev->next = removeThis->next;
+	else
+		firstChild = removeThis->next;
+
+	delete removeThis;
+	return true;
+}
+
+TiXmlNode* TiXmlNode::FirstChild( const char * _value ) const
+{
+	TiXmlNode* node;
+	for ( node = firstChild; node; node = node->next )
+	{
+		if ( node->SValue() == TIXML_STRING( _value ))
+			return node;
+	}
+	return 0;
+}
+
+TiXmlNode* TiXmlNode::LastChild( const char * _value ) const
+{
+	TiXmlNode* node;
+	for ( node = lastChild; node; node = node->prev )
+	{
+		if ( node->SValue() == TIXML_STRING (_value))
+			return node;
+	}
+	return 0;
+}
+
+TiXmlNode* TiXmlNode::IterateChildren( TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild();
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling();
+	}
+}
+
+TiXmlNode* TiXmlNode::IterateChildren( const char * val, TiXmlNode* previous ) const
+{
+	if ( !previous )
+	{
+		return FirstChild( val );
+	}
+	else
+	{
+		assert( previous->parent == this );
+		return previous->NextSibling( val );
+	}
+}
+
+TiXmlNode* TiXmlNode::NextSibling( const char * _value ) const
+{
+	TiXmlNode* node;
+	for ( node = next; node; node = node->next )
+	{
+		if ( node->SValue() == TIXML_STRING (_value))
+			return node;
+	}
+	return 0;
+}
+
+
+TiXmlNode* TiXmlNode::PreviousSibling( const char * _value ) const
+{
+	TiXmlNode* node;
+	for ( node = prev; node; node = node->prev )
+	{
+		if ( node->SValue() == TIXML_STRING (_value))
+			return node;
+	}
+	return 0;
+}
+
+void TiXmlElement::RemoveAttribute( const char * name )
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+	{
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+TiXmlElement* TiXmlNode::FirstChildElement() const
+{
+	TiXmlNode* node;
+
+	for (	node = FirstChild();
+			node;
+			node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+TiXmlElement* TiXmlNode::FirstChildElement( const char * _value ) const
+{
+	TiXmlNode* node;
+
+	for (	node = FirstChild( _value );
+			node;
+			node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+TiXmlElement* TiXmlNode::NextSiblingElement() const
+{
+	TiXmlNode* node;
+
+	for (	node = NextSibling();
+	node;
+	node = node->NextSibling() )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+TiXmlElement* TiXmlNode::NextSiblingElement( const char * _value ) const
+{
+	TiXmlNode* node;
+
+	for (	node = NextSibling( _value );
+	node;
+	node = node->NextSibling( _value ) )
+	{
+		if ( node->ToElement() )
+			return node->ToElement();
+	}
+	return 0;
+}
+
+
+
+TiXmlDocument* TiXmlNode::GetDocument() const
+{
+	const TiXmlNode* node;
+
+	for( node = this; node; node = node->parent )
+	{
+		if ( node->ToDocument() )
+			return node->ToDocument();
+	}
+	return 0;
+}
+
+
+TiXmlElement::TiXmlElement (const char * _value)
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlElement::TiXmlElement( const std::string& _value )
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	value = _value;
+}
+#endif
+
+
+TiXmlElement::TiXmlElement( const TiXmlElement& copy)
+	: TiXmlNode( TiXmlNode::ELEMENT )
+{
+	firstChild = lastChild = 0;
+	copy.CopyTo( this );
+}
+
+
+void TiXmlElement::operator=( const TiXmlElement& base )
+{
+	ClearThis();
+	base.CopyTo( this );
+}
+
+
+TiXmlElement::~TiXmlElement()
+{
+	ClearThis();
+}
+
+
+void TiXmlElement::ClearThis()
+{
+	Clear();
+	while( attributeSet.First() )
+	{
+		TiXmlAttribute* node = attributeSet.First();
+		attributeSet.Remove( node );
+		delete node;
+	}
+}
+
+
+const char * TiXmlElement::Attribute( const char * name ) const
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+
+	if ( node )
+		return node->Value();
+
+	return 0;
+}
+
+
+const char * TiXmlElement::Attribute( const char * name, int* i ) const
+{
+	const char * s = Attribute( name );
+	if ( i )
+	{
+		if ( s )
+			*i = atoi( s );
+		else
+			*i = 0;
+	}
+	return s;
+}
+
+
+const char * TiXmlElement::Attribute( const char * name, double* d ) const
+{
+	const char * s = Attribute( name );
+	if ( d )
+	{
+		if ( s )
+			*d = atof( s );
+		else
+			*d = 0;
+	}
+	return s;
+}
+
+
+int TiXmlElement::QueryIntAttribute( const char* name, int* ival ) const
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+
+	return node->QueryIntValue( ival );
+}
+
+
+int TiXmlElement::QueryDoubleAttribute( const char* name, double* dval ) const
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+	if ( !node )
+		return TIXML_NO_ATTRIBUTE;
+
+	return node->QueryDoubleValue( dval );
+}
+
+
+void TiXmlElement::SetAttribute( const char * name, int val )
+{
+	char buf[64];
+	sprintf( buf, "%d", val );
+	SetAttribute( name, buf );
+}
+
+
+void TiXmlElement::SetDoubleAttribute( const char * name, double val )
+{
+	char buf[128];
+	sprintf( buf, "%f", val );
+	SetAttribute( name, buf );
+}
+
+
+void TiXmlElement::SetAttribute( const char * name, const char * _value )
+{
+	TiXmlAttribute* node = attributeSet.Find( name );
+	if ( node )
+	{
+		node->SetValue( _value );
+		return;
+	}
+
+	TiXmlAttribute* attrib = new TiXmlAttribute( name, _value );
+	if ( attrib )
+	{
+		attributeSet.Add( attrib );
+	}
+	else
+	{
+		TiXmlDocument* document = GetDocument();
+		if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+}
+
+void TiXmlElement::Print( FILE* cfile, int depth ) const
+{
+	int i;
+	for ( i=0; i<depth; i++ )
+	{
+		fprintf( cfile, "    " );
+	}
+
+	fprintf( cfile, "<%s", value.c_str() );
+
+	TiXmlAttribute* attrib;
+	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
+	{
+		fprintf( cfile, " " );
+		attrib->Print( cfile, depth );
+	}
+
+	// There are 3 different formatting approaches:
+	// 1) An element without children is printed as a <foo /> node
+	// 2) An element with only a text child is printed as <foo> text </foo>
+	// 3) An element with children is printed on multiple lines.
+	TiXmlNode* node;
+	if ( !firstChild )
+	{
+		fprintf( cfile, " />" );
+	}
+	else if ( firstChild == lastChild && firstChild->ToText() )
+	{
+		fprintf( cfile, ">" );
+		firstChild->Print( cfile, depth + 1 );
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+	else
+	{
+		fprintf( cfile, ">" );
+
+		for ( node = firstChild; node; node=node->NextSibling() )
+		{
+			if ( !node->ToText() )
+			{
+				fprintf( cfile, "\n" );
+			}
+			node->Print( cfile, depth+1 );
+		}
+		fprintf( cfile, "\n" );
+		for( i=0; i<depth; ++i )
+		fprintf( cfile, "    " );
+		fprintf( cfile, "</%s>", value.c_str() );
+	}
+}
+
+void TiXmlElement::StreamOut( TIXML_OSTREAM * stream ) const
+{
+	(*stream) << "<" << value;
+
+	TiXmlAttribute* attrib;
+	for ( attrib = attributeSet.First(); attrib; attrib = attrib->Next() )
+	{
+		(*stream) << " ";
+		attrib->StreamOut( stream );
+	}
+
+	// If this node has children, give it a closing tag. Else
+	// make it an empty tag.
+	TiXmlNode* node;
+	if ( firstChild )
+	{
+		(*stream) << ">";
+
+		for ( node = firstChild; node; node=node->NextSibling() )
+		{
+			node->StreamOut( stream );
+		}
+		(*stream) << "</" << value << ">";
+	}
+	else
+	{
+		(*stream) << " />";
+	}
+}
+
+
+void TiXmlElement::CopyTo( TiXmlElement* target ) const
+{
+	// superclass:
+	TiXmlNode::CopyTo( target );
+
+	// Element class:
+	// Clone the attributes, then clone the children.
+	TiXmlAttribute* attribute = 0;
+	for(	attribute = attributeSet.First();
+	attribute;
+	attribute = attribute->Next() )
+	{
+		target->SetAttribute( attribute->Name(), attribute->Value() );
+	}
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}
+}
+
+
+TiXmlNode* TiXmlElement::Clone() const
+{
+	TiXmlElement* clone = new TiXmlElement( Value() );
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlDocument::TiXmlDocument() : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	ClearError();
+}
+
+TiXmlDocument::TiXmlDocument( const char * documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+	value = documentName;
+	ClearError();
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDocument::TiXmlDocument( const std::string& documentName ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	tabsize = 4;
+    value = documentName;
+	ClearError();
+}
+#endif
+
+
+TiXmlDocument::TiXmlDocument( const TiXmlDocument& copy ) : TiXmlNode( TiXmlNode::DOCUMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDocument::operator=( const TiXmlDocument& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+bool TiXmlDocument::LoadFile( TiXmlEncoding encoding )
+{
+	// See STL_STRING_BUG below.
+	StringToBuffer buf( value );
+
+	if ( buf.buffer && LoadFile( buf.buffer, encoding ) )
+		return true;
+
+	return false;
+}
+
+
+bool TiXmlDocument::SaveFile() const
+{
+	// See STL_STRING_BUG below.
+	StringToBuffer buf( value );
+
+	if ( buf.buffer && SaveFile( buf.buffer ) )
+		return true;
+
+	return false;
+}
+
+bool TiXmlDocument::LoadFile( const char* filename, TiXmlEncoding encoding )
+{
+	// Delete the existing data:
+	Clear();
+	location.Clear();
+
+	// There was a really terrifying little bug here. The code:
+	//		value = filename
+	// in the STL case, cause the assignment method of the std::string to
+	// be called. What is strange, is that the std::string had the same
+	// address as it's c_str() method, and so bad things happen. Looks
+	// like a bug in the Microsoft STL implementation.
+	// See STL_STRING_BUG above.
+	// Fixed with the StringToBuffer class.
+	value = filename;
+
+	FILE* file = fopen( value.c_str (), "r" );
+
+	if ( file )
+	{
+		// Get the file size, so we can pre-allocate the string. HUGE speed impact.
+		long length = 0;
+		fseek( file, 0, SEEK_END );
+		length = ftell( file );
+		fseek( file, 0, SEEK_SET );
+
+		// Strange case, but good to handle up front.
+		if ( length == 0 )
+		{
+			fclose( file );
+			return false;
+		}
+
+		// If we have a file, assume it is all one big XML file, and read it in.
+		// The document parser may decide the document ends sooner than the entire file, however.
+		TIXML_STRING data;
+		data.reserve( length );
+
+		const int BUF_SIZE = 2048;
+		char buf[BUF_SIZE];
+
+		while( fgets( buf, BUF_SIZE, file ) )
+		{
+			data += buf;
+		}
+		fclose( file );
+
+		Parse( data.c_str(), 0, encoding );
+
+		if (  Error() )
+            return false;
+        else
+			return true;
+	}
+	SetError( TIXML_ERROR_OPENING_FILE, 0, 0, TIXML_ENCODING_UNKNOWN );
+	return false;
+}
+
+bool TiXmlDocument::SaveFile( const char * filename ) const
+{
+	// The old c stuff lives on...
+	FILE* fp = fopen( filename, "w" );
+	if ( fp )
+	{
+		Print( fp, 0 );
+		fclose( fp );
+		return true;
+	}
+	return false;
+}
+
+
+void TiXmlDocument::CopyTo( TiXmlDocument* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->error = error;
+	target->errorDesc = errorDesc.c_str ();
+
+	TiXmlNode* node = 0;
+	for ( node = firstChild; node; node = node->NextSibling() )
+	{
+		target->LinkEndChild( node->Clone() );
+	}
+}
+
+
+TiXmlNode* TiXmlDocument::Clone() const
+{
+	TiXmlDocument* clone = new TiXmlDocument();
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlDocument::Print( FILE* cfile, int depth ) const
+{
+	TiXmlNode* node;
+	for ( node=FirstChild(); node; node=node->NextSibling() )
+	{
+		node->Print( cfile, depth );
+		fprintf( cfile, "\n" );
+	}
+}
+
+void TiXmlDocument::StreamOut( TIXML_OSTREAM * out ) const
+{
+	TiXmlNode* node;
+	for ( node=FirstChild(); node; node=node->NextSibling() )
+	{
+		node->StreamOut( out );
+
+		// Special rule for streams: stop after the root element.
+		// The stream in code will only read one element, so don't
+		// write more than one.
+		if ( node->ToElement() )
+			break;
+	}
+}
+
+
+TiXmlAttribute* TiXmlAttribute::Next() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( next->value.empty() && next->name.empty() )
+		return 0;
+	return next;
+}
+
+
+TiXmlAttribute* TiXmlAttribute::Previous() const
+{
+	// We are using knowledge of the sentinel. The sentinel
+	// have a value or name.
+	if ( prev->value.empty() && prev->name.empty() )
+		return 0;
+	return prev;
+}
+
+
+void TiXmlAttribute::Print( FILE* cfile, int /*depth*/ ) const
+{
+	TIXML_STRING n, v;
+
+	PutString( name, &n );
+	PutString( value, &v );
+
+	if (value.find ('\"') == TIXML_STRING::npos)
+		fprintf (cfile, "%s=\"%s\"", n.c_str(), v.c_str() );
+	else
+		fprintf (cfile, "%s='%s'", n.c_str(), v.c_str() );
+}
+
+
+void TiXmlAttribute::StreamOut( TIXML_OSTREAM * stream ) const
+{
+	if (value.find( '\"' ) != TIXML_STRING::npos)
+	{
+		PutString( name, stream );
+		(*stream) << "=" << "'";
+		PutString( value, stream );
+		(*stream) << "'";
+	}
+	else
+	{
+		PutString( name, stream );
+		(*stream) << "=" << "\"";
+		PutString( value, stream );
+		(*stream) << "\"";
+	}
+}
+
+int TiXmlAttribute::QueryIntValue( int* ival ) const
+{
+	if ( sscanf( value.c_str(), "%d", ival ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+int TiXmlAttribute::QueryDoubleValue( double* dval ) const
+{
+	if ( sscanf( value.c_str(), "%lf", dval ) == 1 )
+		return TIXML_SUCCESS;
+	return TIXML_WRONG_TYPE;
+}
+
+void TiXmlAttribute::SetIntValue( int _value )
+{
+	char buf [64];
+	sprintf (buf, "%d", _value);
+	SetValue (buf);
+}
+
+void TiXmlAttribute::SetDoubleValue( double _value )
+{
+	char buf [64];
+	sprintf (buf, "%lf", _value);
+	SetValue (buf);
+}
+
+const int TiXmlAttribute::IntValue() const
+{
+	return atoi (value.c_str ());
+}
+
+const double  TiXmlAttribute::DoubleValue() const
+{
+	return atof (value.c_str ());
+}
+
+
+TiXmlComment::TiXmlComment( const TiXmlComment& copy ) : TiXmlNode( TiXmlNode::COMMENT )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlComment::operator=( const TiXmlComment& base )
+{
+	Clear();
+	base.CopyTo( this );
+}
+
+
+void TiXmlComment::Print( FILE* cfile, int depth ) const
+{
+	for ( int i=0; i<depth; i++ )
+	{
+		fputs( "    ", cfile );
+	}
+	fprintf( cfile, "<!--%s-->", value.c_str() );
+}
+
+void TiXmlComment::StreamOut( TIXML_OSTREAM * stream ) const
+{
+	(*stream) << "<!--";
+	//PutString( value, stream );
+	(*stream) << value;
+	(*stream) << "-->";
+}
+
+
+void TiXmlComment::CopyTo( TiXmlComment* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+TiXmlNode* TiXmlComment::Clone() const
+{
+	TiXmlComment* clone = new TiXmlComment();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlText::Print( FILE* cfile, int /*depth*/ ) const
+{
+	TIXML_STRING buffer;
+	PutString( value, &buffer );
+	fprintf( cfile, "%s", buffer.c_str() );
+}
+
+
+void TiXmlText::StreamOut( TIXML_OSTREAM * stream ) const
+{
+	PutString( value, stream );
+}
+
+
+void TiXmlText::CopyTo( TiXmlText* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+TiXmlNode* TiXmlText::Clone() const
+{
+	TiXmlText* clone = 0;
+	clone = new TiXmlText( "" );
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlDeclaration::TiXmlDeclaration( const char * _version,
+									const char * _encoding,
+									const char * _standalone )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+
+
+#ifdef TIXML_USE_STL
+TiXmlDeclaration::TiXmlDeclaration(	const std::string& _version,
+									const std::string& _encoding,
+									const std::string& _standalone )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	version = _version;
+	encoding = _encoding;
+	standalone = _standalone;
+}
+#endif
+
+
+TiXmlDeclaration::TiXmlDeclaration( const TiXmlDeclaration& copy )
+	: TiXmlNode( TiXmlNode::DECLARATION )
+{
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDeclaration::operator=( const TiXmlDeclaration& copy )
+{
+	Clear();
+	copy.CopyTo( this );
+}
+
+
+void TiXmlDeclaration::Print( FILE* cfile, int /*depth*/ ) const
+{
+	fprintf (cfile, "<?xml ");
+
+	if ( !version.empty() )
+		fprintf (cfile, "version=\"%s\" ", version.c_str ());
+	if ( !encoding.empty() )
+		fprintf (cfile, "encoding=\"%s\" ", encoding.c_str ());
+	if ( !standalone.empty() )
+		fprintf (cfile, "standalone=\"%s\" ", standalone.c_str ());
+	fprintf (cfile, "?>");
+}
+
+void TiXmlDeclaration::StreamOut( TIXML_OSTREAM * stream ) const
+{
+	(*stream) << "<?xml ";
+
+	if ( !version.empty() )
+	{
+		(*stream) << "version=\"";
+		PutString( version, stream );
+		(*stream) << "\" ";
+	}
+	if ( !encoding.empty() )
+	{
+		(*stream) << "encoding=\"";
+		PutString( encoding, stream );
+		(*stream ) << "\" ";
+	}
+	if ( !standalone.empty() )
+	{
+		(*stream) << "standalone=\"";
+		PutString( standalone, stream );
+		(*stream) << "\" ";
+	}
+	(*stream) << "?>";
+}
+
+
+void TiXmlDeclaration::CopyTo( TiXmlDeclaration* target ) const
+{
+	TiXmlNode::CopyTo( target );
+
+	target->version = version;
+	target->encoding = encoding;
+	target->standalone = standalone;
+}
+
+
+TiXmlNode* TiXmlDeclaration::Clone() const
+{
+	TiXmlDeclaration* clone = new TiXmlDeclaration();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+void TiXmlUnknown::Print( FILE* cfile, int depth ) const
+{
+	for ( int i=0; i<depth; i++ )
+		fprintf( cfile, "    " );
+	fprintf( cfile, "<%s>", value.c_str() );
+}
+
+
+void TiXmlUnknown::StreamOut( TIXML_OSTREAM * stream ) const
+{
+	(*stream) << "<" << value << ">";		// Don't use entities here! It is unknown.
+}
+
+
+void TiXmlUnknown::CopyTo( TiXmlUnknown* target ) const
+{
+	TiXmlNode::CopyTo( target );
+}
+
+
+TiXmlNode* TiXmlUnknown::Clone() const
+{
+	TiXmlUnknown* clone = new TiXmlUnknown();
+
+	if ( !clone )
+		return 0;
+
+	CopyTo( clone );
+	return clone;
+}
+
+
+TiXmlAttributeSet::TiXmlAttributeSet()
+{
+	sentinel.next = &sentinel;
+	sentinel.prev = &sentinel;
+}
+
+
+TiXmlAttributeSet::~TiXmlAttributeSet()
+{
+	assert( sentinel.next == &sentinel );
+	assert( sentinel.prev == &sentinel );
+}
+
+
+void TiXmlAttributeSet::Add( TiXmlAttribute* addMe )
+{
+	assert( !Find( addMe->Name() ) );	// Shouldn't be multiply adding to the set.
+
+	addMe->next = &sentinel;
+	addMe->prev = sentinel.prev;
+
+	sentinel.prev->next = addMe;
+	sentinel.prev      = addMe;
+}
+
+void TiXmlAttributeSet::Remove( TiXmlAttribute* removeMe )
+{
+	TiXmlAttribute* node;
+
+	for( node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node == removeMe )
+		{
+			node->prev->next = node->next;
+			node->next->prev = node->prev;
+			node->next = 0;
+			node->prev = 0;
+			return;
+		}
+	}
+	assert( 0 );		// we tried to remove a non-linked attribute.
+}
+
+TiXmlAttribute*	TiXmlAttributeSet::Find( const char * name ) const
+{
+	TiXmlAttribute* node;
+
+	for( node = sentinel.next; node != &sentinel; node = node->next )
+	{
+		if ( node->name == name )
+			return node;
+	}
+	return 0;
+}
+
+
+#ifdef TIXML_USE_STL
+TIXML_ISTREAM & operator >> (TIXML_ISTREAM & in, TiXmlNode & base)
+{
+	TIXML_STRING tag;
+	tag.reserve( 8 * 1000 );
+	base.StreamIn( &in, &tag );
+
+	base.Parse( tag.c_str(), 0, TIXML_DEFAULT_ENCODING );
+	return in;
+}
+#endif
+
+
+TIXML_OSTREAM & operator<< (TIXML_OSTREAM & out, const TiXmlNode & base)
+{
+	base.StreamOut (& out);
+	return out;
+}
+
+
+#ifdef TIXML_USE_STL
+std::string & operator<< (std::string& out, const TiXmlNode& base )
+{
+   std::ostringstream os_stream( std::ostringstream::out );
+   base.StreamOut( &os_stream );
+
+   out.append( os_stream.str() );
+   return out;
+}
+#endif
+
+
+TiXmlHandle TiXmlHandle::FirstChild() const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChild( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlNode* child = node->FirstChild( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement() const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement();
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::FirstChildElement( const char * value ) const
+{
+	if ( node )
+	{
+		TiXmlElement* child = node->FirstChildElement( value );
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::Child( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlNode* child = node->FirstChild( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSibling( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement();
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement(), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
+
+
+TiXmlHandle TiXmlHandle::ChildElement( const char* value, int count ) const
+{
+	if ( node )
+	{
+		int i;
+		TiXmlElement* child = node->FirstChildElement( value );
+		for (	i=0;
+				child && i<count;
+				child = child->NextSiblingElement( value ), ++i )
+		{
+			// nothing
+		}
+		if ( child )
+			return TiXmlHandle( child );
+	}
+	return TiXmlHandle( 0 );
+}
Index: vdr-2.2.0/PLUGINS/src/setup/tinyxmlerror.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/tinyxmlerror.c	2015-12-24 15:16:31.696279606 +0100
@@ -0,0 +1,51 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+
+// The goal of the seperate error file is to make the first
+// step towards localization. tinyxml (currently) only supports
+// latin-1, but at least the error messages could now be translated.
+//
+// It also cleans up the code a bit.
+//
+
+const char* TiXmlBase::errorString[ TIXML_ERROR_STRING_COUNT ] =
+{
+	"No error",
+	"Error",
+	"Failed to open file",
+	"Memory allocation failed.",
+	"Error parsing Element.",
+	"Failed to read Element name",
+	"Error reading Element value.",
+	"Error reading Attributes.",
+	"Error: empty tag.",
+	"Error reading end tag.",
+	"Error parsing Unknown.",
+	"Error parsing Comment.",
+	"Error parsing Declaration.",
+	"Error document empty.",
+	"Error null (0) or unexpected EOF found in input stream.",
+};
Index: vdr-2.2.0/PLUGINS/src/setup/tinyxml.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/tinyxml.h	2015-12-24 15:16:31.700279626 +0100
@@ -0,0 +1,1370 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+
+#ifndef TINYXML_INCLUDED
+#define TINYXML_INCLUDED
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4530 )
+#pragma warning( disable : 4786 )
+#endif
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+// Help out windows:
+#if defined( _DEBUG ) && !defined( DEBUG )
+#define DEBUG
+#endif
+
+#if defined( DEBUG ) && defined( _MSC_VER )
+#include <windows.h>
+#define TIXML_LOG OutputDebugString
+#else
+#define TIXML_LOG printf
+#endif
+
+#ifdef TIXML_USE_STL
+	#include <string>
+ 	#include <iostream>
+	#define TIXML_STRING	std::string
+	#define TIXML_ISTREAM	std::istream
+	#define TIXML_OSTREAM	std::ostream
+#else
+	#include "tinystr.h"
+	#define TIXML_STRING	TiXmlString
+	#define TIXML_OSTREAM	TiXmlOutStream
+#endif
+
+class TiXmlDocument;
+class TiXmlElement;
+class TiXmlComment;
+class TiXmlUnknown;
+class TiXmlAttribute;
+class TiXmlText;
+class TiXmlDeclaration;
+class TiXmlParsingData;
+
+const int TIXML_MAJOR_VERSION = 2;
+const int TIXML_MINOR_VERSION = 3;
+const int TIXML_PATCH_VERSION = 2;
+
+/*	Internal structure for tracking location of items
+	in the XML file.
+*/
+struct TiXmlCursor
+{
+	TiXmlCursor()		{ Clear(); }
+	void Clear()		{ row = col = -1; }
+
+	int row;	// 0 based.
+	int col;	// 0 based.
+};
+
+
+// Only used by Attribute::Query functions
+enum
+{
+	TIXML_SUCCESS,
+	TIXML_NO_ATTRIBUTE,
+	TIXML_WRONG_TYPE
+};
+
+
+// Used by the parsing routines.
+enum TiXmlEncoding
+{
+	TIXML_ENCODING_UNKNOWN,
+	TIXML_ENCODING_UTF8,
+	TIXML_ENCODING_LEGACY
+};
+
+const TiXmlEncoding TIXML_DEFAULT_ENCODING = TIXML_ENCODING_UNKNOWN;
+
+/** TiXmlBase is a base class for every class in TinyXml.
+	It does little except to establish that TinyXml classes
+	can be printed and provide some utility functions.
+
+	In XML, the document and elements can contain
+	other elements and other types of nodes.
+
+	@verbatim
+	A Document can contain:	Element	(container or leaf)
+							Comment (leaf)
+							Unknown (leaf)
+							Declaration( leaf )
+
+	An Element can contain:	Element (container or leaf)
+							Text	(leaf)
+							Attributes (not on tree)
+							Comment (leaf)
+							Unknown (leaf)
+
+	A Decleration contains: Attributes (not on tree)
+	@endverbatim
+*/
+class TiXmlBase
+{
+	friend class TiXmlNode;
+	friend class TiXmlElement;
+	friend class TiXmlDocument;
+
+public:
+	TiXmlBase()	:	userData(0) {}
+	virtual ~TiXmlBase()					{}
+
+	/**	All TinyXml classes can print themselves to a filestream.
+		This is a formatted print, and will insert tabs and newlines.
+
+		(For an unformatted stream, use the << operator.)
+	*/
+	virtual void Print( FILE* cfile, int depth ) const = 0;
+
+	/**	The world does not agree on whether white space should be kept or
+		not. In order to make everyone happy, these global, static functions
+		are provided to set whether or not TinyXml will condense all white space
+		into a single space or not. The default is to condense. Note changing this
+		values is not thread safe.
+	*/
+	static void SetCondenseWhiteSpace( bool condense )		{ condenseWhiteSpace = condense; }
+
+	/// Return the current white space setting.
+	static bool IsWhiteSpaceCondensed()						{ return condenseWhiteSpace; }
+
+	/** Return the position, in the original source file, of this node or attribute.
+		The row and column are 1-based. (That is the first row and first column is
+		1,1). If the returns values are 0 or less, then the parser does not have
+		a row and column value.
+
+		Generally, the row and column value will be set when the TiXmlDocument::Load(),
+		TiXmlDocument::LoadFile(), or any TiXmlNode::Parse() is called. It will NOT be set
+		when the DOM was created from operator>>.
+
+		The values reflect the initial load. Once the DOM is modified programmatically
+		(by adding or changing nodes and attributes) the new values will NOT update to
+		reflect changes in the document.
+
+		There is a minor performance cost to computing the row and column. Computation
+		can be disabled if TiXmlDocument::SetTabSize() is called with 0 as the value.
+
+		@sa TiXmlDocument::SetTabSize()
+	*/
+	int Row() const			{ return location.row + 1; }
+	int Column() const		{ return location.col + 1; }	///< See Row()
+
+	void  SetUserData( void* user )			{ userData = user; }
+	void* GetUserData()						{ return userData; }
+
+	// Table that returs, for a given lead byte, the total number of bytes
+	// in the UTF-8 sequence.
+	static const int utf8ByteTable[256];
+
+	virtual const char* Parse(	const char* p,
+								TiXmlParsingData* data,
+								TiXmlEncoding encoding /*= TIXML_ENCODING_UNKNOWN */ ) = 0;
+
+protected:
+
+	// See STL_STRING_BUG
+	// Utility class to overcome a bug.
+	class StringToBuffer
+	{
+	  public:
+		StringToBuffer( const TIXML_STRING& str );
+		~StringToBuffer();
+		char* buffer;
+	};
+
+	static const char*	SkipWhiteSpace( const char*, TiXmlEncoding encoding );
+	inline static bool	IsWhiteSpace( char c )
+	{
+		return ( isspace( (unsigned char) c ) || c == '\n' || c == '\r' );
+	}
+
+	virtual void StreamOut (TIXML_OSTREAM *) const = 0;
+
+	#ifdef TIXML_USE_STL
+	    static bool	StreamWhiteSpace( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	    static bool StreamTo( TIXML_ISTREAM * in, int character, TIXML_STRING * tag );
+	#endif
+
+	/*	Reads an XML name into the string provided. Returns
+		a pointer just past the last character of the name,
+		or 0 if the function has an error.
+	*/
+	static const char* ReadName( const char* p, TIXML_STRING* name, TiXmlEncoding encoding );
+
+	/*	Reads text. Returns a pointer past the given end tag.
+		Wickedly complex options, but it keeps the (sensitive) code in one place.
+	*/
+	static const char* ReadText(	const char* in,				// where to start
+									TIXML_STRING* text,			// the string read
+									bool ignoreWhiteSpace,		// whether to keep the white space
+									const char* endTag,			// what ends this text
+									bool ignoreCase,			// whether to ignore case in the end tag
+									TiXmlEncoding encoding );	// the current encoding
+
+	// If an entity has been found, transform it into a character.
+	static const char* GetEntity( const char* in, char* value, int* length, TiXmlEncoding encoding );
+
+	// Get a character, while interpreting entities.
+	// The length can be from 0 to 4 bytes.
+	inline static const char* GetChar( const char* p, char* _value, int* length, TiXmlEncoding encoding )
+	{
+		assert( p );
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			*length = utf8ByteTable[ *((unsigned char*)p) ];
+			assert( *length >= 0 && *length < 5 );
+		}
+		else
+		{
+			*length = 1;
+		}
+
+		if ( *length == 1 )
+		{
+			if ( *p == '&' )
+				return GetEntity( p, _value, length, encoding );
+			*_value = *p;
+			return p+1;
+		}
+		else if ( *length )
+		{
+			strncpy( _value, p, *length );
+			return p + (*length);
+		}
+		else
+		{
+			// Not valid text.
+			return 0;
+		}
+	}
+
+	// Puts a string to a stream, expanding entities as it goes.
+	// Note this should not contian the '<', '>', etc, or they will be transformed into entities!
+	static void PutString( const TIXML_STRING& str, TIXML_OSTREAM* out );
+
+	static void PutString( const TIXML_STRING& str, TIXML_STRING* out );
+
+	// Return true if the next characters in the stream are any of the endTag sequences.
+	// Ignore case only works for english, and should only be relied on when comparing
+	// to Engilish words: StringEqual( p, "version", true ) is fine.
+	static bool StringEqual(	const char* p,
+								const char* endTag,
+								bool ignoreCase,
+								TiXmlEncoding encoding );
+
+
+	enum
+	{
+		TIXML_NO_ERROR = 0,
+		TIXML_ERROR,
+		TIXML_ERROR_OPENING_FILE,
+		TIXML_ERROR_OUT_OF_MEMORY,
+		TIXML_ERROR_PARSING_ELEMENT,
+		TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME,
+		TIXML_ERROR_READING_ELEMENT_VALUE,
+		TIXML_ERROR_READING_ATTRIBUTES,
+		TIXML_ERROR_PARSING_EMPTY,
+		TIXML_ERROR_READING_END_TAG,
+		TIXML_ERROR_PARSING_UNKNOWN,
+		TIXML_ERROR_PARSING_COMMENT,
+		TIXML_ERROR_PARSING_DECLARATION,
+		TIXML_ERROR_DOCUMENT_EMPTY,
+		TIXML_ERROR_EMBEDDED_NULL,
+
+		TIXML_ERROR_STRING_COUNT
+	};
+	static const char* errorString[ TIXML_ERROR_STRING_COUNT ];
+
+	TiXmlCursor location;
+
+    /// Field containing a generic user pointer
+	void*			userData;
+
+	// None of these methods are reliable for any language except English.
+	// Good for approximation, not great for accuracy.
+	static int IsAlpha( unsigned char anyByte, TiXmlEncoding encoding );
+	static int IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding );
+	inline static int ToLower( int v, TiXmlEncoding encoding )
+	{
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			if ( v < 128 ) return tolower( v );
+			return v;
+		}
+		else
+		{
+			return tolower( v );
+		}
+	}
+	static void ConvertUTF32ToUTF8( unsigned long input, char* output, int* length );
+
+private:
+	TiXmlBase( const TiXmlBase& );				// not implemented.
+	void operator=( const TiXmlBase& base );	// not allowed.
+
+	struct Entity
+	{
+		const char*     str;
+		unsigned int	strLength;
+		char		    chr;
+	};
+	enum
+	{
+		NUM_ENTITY = 5,
+		MAX_ENTITY_LENGTH = 6
+
+	};
+	static Entity entity[ NUM_ENTITY ];
+	static bool condenseWhiteSpace;
+};
+
+
+/** The parent class for everything in the Document Object Model.
+	(Except for attributes).
+	Nodes have siblings, a parent, and children. A node can be
+	in a document, or stand on its own. The type of a TiXmlNode
+	can be queried, and it can be cast to its more defined type.
+*/
+class TiXmlNode : public TiXmlBase
+{
+	friend class TiXmlDocument;
+	friend class TiXmlElement;
+
+public:
+	#ifdef TIXML_USE_STL
+
+	    /** An input stream operator, for every class. Tolerant of newlines and
+		    formatting, but doesn't expect them.
+	    */
+	    friend std::istream& operator >> (std::istream& in, TiXmlNode& base);
+
+	    /** An output stream operator, for every class. Note that this outputs
+		    without any newlines or formatting, as opposed to Print(), which
+		    includes tabs and new lines.
+
+		    The operator<< and operator>> are not completely symmetric. Writing
+		    a node to a stream is very well defined. You'll get a nice stream
+		    of output, without any extra whitespace or newlines.
+
+		    But reading is not as well defined. (As it always is.) If you create
+		    a TiXmlElement (for example) and read that from an input stream,
+		    the text needs to define an element or junk will result. This is
+		    true of all input streams, but it's worth keeping in mind.
+
+		    A TiXmlDocument will read nodes until it reads a root element, and
+			all the children of that root element.
+	    */
+	    friend std::ostream& operator<< (std::ostream& out, const TiXmlNode& base);
+
+		/// Appends the XML node or attribute to a std::string.
+		friend std::string& operator<< (std::string& out, const TiXmlNode& base );
+
+	#else
+	    // Used internally, not part of the public API.
+	    friend TIXML_OSTREAM& operator<< (TIXML_OSTREAM& out, const TiXmlNode& base);
+	#endif
+
+	/** The types of XML nodes supported by TinyXml. (All the
+			unsupported types are picked up by UNKNOWN.)
+	*/
+	enum NodeType
+	{
+		DOCUMENT,
+		ELEMENT,
+		COMMENT,
+		UNKNOWN,
+		TEXT,
+		DECLARATION,
+		TYPECOUNT
+	};
+
+	virtual ~TiXmlNode();
+
+	/** The meaning of 'value' changes for the specific type of
+		TiXmlNode.
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+
+		The subclasses will wrap this function.
+	*/
+	const char * Value() const { return value.c_str (); }
+
+	/** Changes the value of the node. Defined as:
+		@verbatim
+		Document:	filename of the xml file
+		Element:	name of the element
+		Comment:	the comment text
+		Unknown:	the tag contents
+		Text:		the text string
+		@endverbatim
+	*/
+	void SetValue(const char * _value) { value = _value;}
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetValue( const std::string& _value )
+	{
+		StringToBuffer buf( _value );
+		SetValue( buf.buffer ? buf.buffer : "" );
+	}
+	#endif
+
+	/// Delete all the children of this node. Does not affect 'this'.
+	void Clear();
+
+	/// One step up the DOM.
+	TiXmlNode* Parent() const					{ return parent; }
+
+	TiXmlNode* FirstChild()	const	{ return firstChild; }		///< The first child of this node. Will be null if there are no children.
+	TiXmlNode* FirstChild( const char * value ) const;			///< The first child of this node with the matching 'value'. Will be null if none found.
+
+	TiXmlNode* LastChild() const	{ return lastChild; }		/// The last child of this node. Will be null if there are no children.
+	TiXmlNode* LastChild( const char * value ) const;			/// The last child of this node matching 'value'. Will be null if there are no children.
+
+    #ifdef TIXML_USE_STL
+	TiXmlNode* FirstChild( const std::string& _value ) const	{	return FirstChild (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* LastChild( const std::string& _value ) const		{	return LastChild (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** An alternate way to walk the children of a node.
+		One way to iterate over nodes is:
+		@verbatim
+			for( child = parent->FirstChild(); child; child = child->NextSibling() )
+		@endverbatim
+
+		IterateChildren does the same thing with the syntax:
+		@verbatim
+			child = 0;
+			while( child = parent->IterateChildren( child ) )
+		@endverbatim
+
+		IterateChildren takes the previous child as input and finds
+		the next one. If the previous child is null, it returns the
+		first. IterateChildren will return null when done.
+	*/
+	TiXmlNode* IterateChildren( TiXmlNode* previous ) const;
+
+	/// This flavor of IterateChildren searches for children with a particular 'value'
+	TiXmlNode* IterateChildren( const char * value, TiXmlNode* previous ) const;
+
+    #ifdef TIXML_USE_STL
+	TiXmlNode* IterateChildren( const std::string& _value, TiXmlNode* previous ) const	{	return IterateChildren (_value.c_str (), previous);	}	///< STL std::string form.
+	#endif
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertEndChild( const TiXmlNode& addThis );
+
+
+	/** Add a new node related to this. Adds a child past the LastChild.
+
+		NOTE: the node to be added is passed by pointer, and will be
+		henceforth owned (and deleted) by tinyXml. This method is efficient
+		and avoids an extra copy, but should be used with care as it
+		uses a different memory model than the other insert functions.
+
+		@sa InsertEndChild
+	*/
+	TiXmlNode* LinkEndChild( TiXmlNode* addThis );
+
+	/** Add a new node related to this. Adds a child before the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertBeforeChild( TiXmlNode* beforeThis, const TiXmlNode& addThis );
+
+	/** Add a new node related to this. Adds a child after the specified child.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* InsertAfterChild(  TiXmlNode* afterThis, const TiXmlNode& addThis );
+
+	/** Replace a child of this node.
+		Returns a pointer to the new object or NULL if an error occured.
+	*/
+	TiXmlNode* ReplaceChild( TiXmlNode* replaceThis, const TiXmlNode& withThis );
+
+	/// Delete a child of this node.
+	bool RemoveChild( TiXmlNode* removeThis );
+
+	/// Navigate to a sibling node.
+	TiXmlNode* PreviousSibling() const			{ return prev; }
+
+	/// Navigate to a sibling node.
+	TiXmlNode* PreviousSibling( const char * ) const;
+
+    #ifdef TIXML_USE_STL
+	TiXmlNode* PreviousSibling( const std::string& _value ) const	{	return PreviousSibling (_value.c_str ());	}	///< STL std::string form.
+	TiXmlNode* NextSibling( const std::string& _value) const		{	return NextSibling (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Navigate to a sibling node.
+	TiXmlNode* NextSibling() const				{ return next; }
+
+	/// Navigate to a sibling node with the given 'value'.
+	TiXmlNode* NextSibling( const char * ) const;
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	TiXmlElement* NextSiblingElement() const;
+
+	/** Convenience function to get through elements.
+		Calls NextSibling and ToElement. Will skip all non-Element
+		nodes. Returns 0 if there is not another element.
+	*/
+	TiXmlElement* NextSiblingElement( const char * ) const;
+
+    #ifdef TIXML_USE_STL
+	TiXmlElement* NextSiblingElement( const std::string& _value) const	{	return NextSiblingElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/// Convenience function to get through elements.
+	TiXmlElement* FirstChildElement()	const;
+
+	/// Convenience function to get through elements.
+	TiXmlElement* FirstChildElement( const char * value ) const;
+
+    #ifdef TIXML_USE_STL
+	TiXmlElement* FirstChildElement( const std::string& _value ) const	{	return FirstChildElement (_value.c_str ());	}	///< STL std::string form.
+	#endif
+
+	/** Query the type (as an enumerated value, above) of this node.
+		The possible types are: DOCUMENT, ELEMENT, COMMENT,
+								UNKNOWN, TEXT, and DECLARATION.
+	*/
+	virtual int Type() const	{ return type; }
+
+	/** Return a pointer to the Document this node lives in.
+		Returns null if not in a document.
+	*/
+	TiXmlDocument* GetDocument() const;
+
+	/// Returns true if this node has no children.
+	bool NoChildren() const						{ return !firstChild; }
+
+	TiXmlDocument* ToDocument()	const		{ return ( this && type == DOCUMENT ) ? (TiXmlDocument*) this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
+	TiXmlElement*  ToElement() const		{ return ( this && type == ELEMENT  ) ? (TiXmlElement*)  this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
+	TiXmlComment*  ToComment() const		{ return ( this && type == COMMENT  ) ? (TiXmlComment*)  this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
+	TiXmlUnknown*  ToUnknown() const		{ return ( this && type == UNKNOWN  ) ? (TiXmlUnknown*)  this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
+	TiXmlText*	   ToText()    const		{ return ( this && type == TEXT     ) ? (TiXmlText*)     this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
+	TiXmlDeclaration* ToDeclaration() const	{ return ( this && type == DECLARATION ) ? (TiXmlDeclaration*) this : 0; } ///< Cast to a more defined type. Will return null not of the requested type.
+
+	/** Create an exact duplicate of this node and return it. The memory must be deleted
+		by the caller.
+	*/
+	virtual TiXmlNode* Clone() const = 0;
+
+protected:
+	TiXmlNode( NodeType _type );
+
+	// Copy to the allocated object. Shared functionality between Clone, Copy constructor,
+	// and the assignment operator.
+	void CopyTo( TiXmlNode* target ) const;
+
+	#ifdef TIXML_USE_STL
+	    // The real work of the input operator.
+	    virtual void StreamIn( TIXML_ISTREAM* in, TIXML_STRING* tag ) = 0;
+	#endif
+
+	// Figure out what is at *p, and parse it. Returns null if it is not an xml node.
+	TiXmlNode* Identify( const char* start, TiXmlEncoding encoding );
+
+	// Internal Value function returning a TIXML_STRING
+	const TIXML_STRING& SValue() const	{ return value ; }
+
+	TiXmlNode*		parent;
+	NodeType		type;
+
+	TiXmlNode*		firstChild;
+	TiXmlNode*		lastChild;
+
+	TIXML_STRING	value;
+
+	TiXmlNode*		prev;
+	TiXmlNode*		next;
+
+private:
+	TiXmlNode( const TiXmlNode& );				// not implemented.
+	void operator=( const TiXmlNode& base );	// not allowed.
+};
+
+
+/** An attribute is a name-value pair. Elements have an arbitrary
+	number of attributes, each with a unique name.
+
+	@note The attributes are not TiXmlNodes, since they are not
+		  part of the tinyXML document object model. There are other
+		  suggested ways to look at this problem.
+*/
+class TiXmlAttribute : public TiXmlBase
+{
+	friend class TiXmlAttributeSet;
+
+public:
+	/// Construct an empty attribute.
+	TiXmlAttribute() : TiXmlBase()
+	{
+		document = 0;
+		prev = next = 0;
+	}
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlAttribute( const std::string& _name, const std::string& _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+	#endif
+
+	/// Construct an attribute with a name and value.
+	TiXmlAttribute( const char * _name, const char * _value )
+	{
+		name = _name;
+		value = _value;
+		document = 0;
+		prev = next = 0;
+	}
+
+	const char*		Name()  const		{ return name.c_str (); }		///< Return the name of this attribute.
+	const char*		Value() const		{ return value.c_str (); }		///< Return the value of this attribute.
+	const int       IntValue() const;									///< Return the value of this attribute, converted to an integer.
+	const double	DoubleValue() const;								///< Return the value of this attribute, converted to a double.
+
+	/** QueryIntValue examines the value string. It is an alternative to the
+		IntValue() method with richer error checking.
+		If the value is an integer, it is stored in 'value' and
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE.
+
+		A specialized but useful call. Note that for success it returns 0,
+		which is the opposite of almost all other TinyXml calls.
+	*/
+	int QueryIntValue( int* value ) const;
+	/// QueryDoubleValue examines the value string. See QueryIntValue().
+	int QueryDoubleValue( double* value ) const;
+
+	void SetName( const char* _name )	{ name = _name; }				///< Set the name of this attribute.
+	void SetValue( const char* _value )	{ value = _value; }				///< Set the value.
+
+	void SetIntValue( int value );										///< Set the value from an integer.
+	void SetDoubleValue( double value );								///< Set the value from a double.
+
+    #ifdef TIXML_USE_STL
+	/// STL std::string form.
+	void SetName( const std::string& _name )
+	{
+		StringToBuffer buf( _name );
+		SetName ( buf.buffer ? buf.buffer : "error" );
+	}
+	/// STL std::string form.
+	void SetValue( const std::string& _value )
+	{
+		StringToBuffer buf( _value );
+		SetValue( buf.buffer ? buf.buffer : "error" );
+	}
+	#endif
+
+	/// Get the next sibling attribute in the DOM. Returns null at end.
+	TiXmlAttribute* Next() const;
+	/// Get the previous sibling attribute in the DOM. Returns null at beginning.
+	TiXmlAttribute* Previous() const;
+
+	bool operator==( const TiXmlAttribute& rhs ) const { return rhs.name == name; }
+	bool operator<( const TiXmlAttribute& rhs )	 const { return name < rhs.name; }
+	bool operator>( const TiXmlAttribute& rhs )  const { return name > rhs.name; }
+
+	/*	Attribute parsing starts: first letter of the name
+						 returns: the next char after the value end quote
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+	// Prints this Attribute to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual void StreamOut( TIXML_OSTREAM * out ) const;
+	// [internal use]
+	// Set the document pointer so the attribute can report errors.
+	void SetDocument( TiXmlDocument* doc )	{ document = doc; }
+
+private:
+	TiXmlAttribute( const TiXmlAttribute& );				// not implemented.
+	void operator=( const TiXmlAttribute& base );	// not allowed.
+
+	TiXmlDocument*	document;	// A pointer back to a document, for error reporting.
+	TIXML_STRING name;
+	TIXML_STRING value;
+	TiXmlAttribute*	prev;
+	TiXmlAttribute*	next;
+};
+
+
+/*	A class used to manage a group of attributes.
+	It is only used internally, both by the ELEMENT and the DECLARATION.
+
+	The set can be changed transparent to the Element and Declaration
+	classes that use it, but NOT transparent to the Attribute
+	which has to implement a next() and previous() method. Which makes
+	it a bit problematic and prevents the use of STL.
+
+	This version is implemented with circular lists because:
+		- I like circular lists
+		- it demonstrates some independence from the (typical) doubly linked list.
+*/
+class TiXmlAttributeSet
+{
+public:
+	TiXmlAttributeSet();
+	~TiXmlAttributeSet();
+
+	void Add( TiXmlAttribute* attribute );
+	void Remove( TiXmlAttribute* attribute );
+
+	TiXmlAttribute* First() const	{ return ( sentinel.next == &sentinel ) ? 0 : sentinel.next; }
+	TiXmlAttribute* Last()  const	{ return ( sentinel.prev == &sentinel ) ? 0 : sentinel.prev; }
+	TiXmlAttribute*	Find( const char * name ) const;
+
+private:
+	TiXmlAttribute sentinel;
+};
+
+
+/** The element is a container class. It has a value, the element name,
+	and can contain other elements, text, comments, and unknowns.
+	Elements also contain an arbitrary number of attributes.
+*/
+class TiXmlElement : public TiXmlNode
+{
+public:
+	/// Construct an element.
+	TiXmlElement (const char * in_value);
+
+	#ifdef TIXML_USE_STL
+	/// std::string constructor.
+	TiXmlElement( const std::string& _value );
+	#endif
+
+	TiXmlElement( const TiXmlElement& );
+
+	void operator=( const TiXmlElement& base );
+
+	virtual ~TiXmlElement();
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+	*/
+	const char* Attribute( const char* name ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an integer,
+		the integer value will be put in the return 'i', if 'i'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, int* i ) const;
+
+	/** Given an attribute name, Attribute() returns the value
+		for the attribute of that name, or null if none exists.
+		If the attribute exists and can be converted to an double,
+		the double value will be put in the return 'd', if 'd'
+		is non-null.
+	*/
+	const char* Attribute( const char* name, double* d ) const;
+
+	/** QueryIntAttribute examines the attribute - it is an alternative to the
+		Attribute() method with richer error checking.
+		If the attribute is an integer, it is stored in 'value' and
+		the call returns TIXML_SUCCESS. If it is not
+		an integer, it returns TIXML_WRONG_TYPE. If the attribute
+		does not exist, then TIXML_NO_ATTRIBUTE is returned.
+	*/
+	int QueryIntAttribute( const char* name, int* value ) const;
+	/// QueryDoubleAttribute examines the attribute - see QueryIntAttribute().
+	int QueryDoubleAttribute( const char* name, double* value ) const;
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char* name, const char * value );
+
+    #ifdef TIXML_USE_STL
+	const char* Attribute( const std::string& name ) const				{ return Attribute( name.c_str() ); }
+	const char* Attribute( const std::string& name, int* i ) const		{ return Attribute( name.c_str(), i ); }
+	const char* Attribute( const std::string& name, double* d ) const	{ return Attribute( name.c_str(), d ); }
+	int QueryIntAttribute( const std::string& name, int* value ) const	{ return QueryIntAttribute( name.c_str(), value ); }
+	int QueryDoubleAttribute( const std::string& name, double* value ) const { return QueryDoubleAttribute( name.c_str(), value ); }
+
+	/// STL std::string form.
+	void SetAttribute( const std::string& name, const std::string& _value )
+	{
+		StringToBuffer n( name );
+		StringToBuffer v( _value );
+		if ( n.buffer && v.buffer )
+			SetAttribute (n.buffer, v.buffer );
+	}
+	///< STL std::string form.
+	void SetAttribute( const std::string& name, int _value )
+	{
+		StringToBuffer n( name );
+		if ( n.buffer )
+			SetAttribute (n.buffer, _value);
+	}
+	#endif
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetAttribute( const char * name, int value );
+
+	/** Sets an attribute of name to a given value. The attribute
+		will be created if it does not exist, or changed if it does.
+	*/
+	void SetDoubleAttribute( const char * name, double value );
+
+	/** Deletes an attribute with the given name.
+	*/
+	void RemoveAttribute( const char * name );
+    #ifdef TIXML_USE_STL
+	void RemoveAttribute( const std::string& name )	{	RemoveAttribute (name.c_str ());	}	///< STL std::string form.
+	#endif
+
+	TiXmlAttribute* FirstAttribute() const	{ return attributeSet.First(); }		///< Access the first attribute in this element.
+	TiXmlAttribute* LastAttribute()	const 	{ return attributeSet.Last(); }		///< Access the last attribute in this element.
+
+	/// Creates a new Element and returns it - the returned element is a copy.
+	virtual TiXmlNode* Clone() const;
+	// Print the Element to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: next char past '<'
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+protected:
+
+	void CopyTo( TiXmlElement* target ) const;
+	void ClearThis();	// like clear, but initializes 'this' object as well
+
+	// Used to be public [internal use]
+	#ifdef TIXML_USE_STL
+	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	#endif
+	virtual void StreamOut( TIXML_OSTREAM * out ) const;
+
+	/*	[internal use]
+		Reads the "value" of the element -- another element, or text.
+		This should terminate with the current end tag.
+	*/
+	const char* ReadValue( const char* in, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+private:
+
+	TiXmlAttributeSet attributeSet;
+};
+
+
+/**	An XML comment.
+*/
+class TiXmlComment : public TiXmlNode
+{
+public:
+	/// Constructs an empty comment.
+	TiXmlComment() : TiXmlNode( TiXmlNode::COMMENT ) {}
+	TiXmlComment( const TiXmlComment& );
+	void operator=( const TiXmlComment& base );
+
+	virtual ~TiXmlComment()	{}
+
+	/// Returns a copy of this Comment.
+	virtual TiXmlNode* Clone() const;
+	/// Write this Comment to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	/*	Attribtue parsing starts: at the ! of the !--
+						 returns: next char past '>'
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+protected:
+	void CopyTo( TiXmlComment* target ) const;
+
+	// used to be public
+	#ifdef TIXML_USE_STL
+	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	#endif
+	virtual void StreamOut( TIXML_OSTREAM * out ) const;
+
+private:
+
+};
+
+
+/** XML text. Contained in an element.
+*/
+class TiXmlText : public TiXmlNode
+{
+	friend class TiXmlElement;
+public:
+	/// Constructor.
+	TiXmlText (const char * initValue) : TiXmlNode (TiXmlNode::TEXT)
+	{
+		SetValue( initValue );
+	}
+	virtual ~TiXmlText() {}
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlText( const std::string& initValue ) : TiXmlNode (TiXmlNode::TEXT)
+	{
+		SetValue( initValue );
+	}
+	#endif
+
+	TiXmlText( const TiXmlText& copy ) : TiXmlNode( TiXmlNode::TEXT )	{ copy.CopyTo( this ); }
+	void operator=( const TiXmlText& base )							 	{ base.CopyTo( this ); }
+
+	/// Write this text object to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+protected :
+	///  [internal use] Creates a new Element and returns it.
+	virtual TiXmlNode* Clone() const;
+	void CopyTo( TiXmlText* target ) const;
+
+	virtual void StreamOut ( TIXML_OSTREAM * out ) const;
+	bool Blank() const;	// returns true if all white space and new lines
+	// [internal use]
+	#ifdef TIXML_USE_STL
+	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	#endif
+
+private:
+};
+
+
+/** In correct XML the declaration is the first entry in the file.
+	@verbatim
+		<?xml version="1.0" standalone="yes"?>
+	@endverbatim
+
+	TinyXml will happily read or write files without a declaration,
+	however. There are 3 possible attributes to the declaration:
+	version, encoding, and standalone.
+
+	Note: In this version of the code, the attributes are
+	handled as special cases, not generic attributes, simply
+	because there can only be at most 3 and they are always the same.
+*/
+class TiXmlDeclaration : public TiXmlNode
+{
+public:
+	/// Construct an empty declaration.
+	TiXmlDeclaration()   : TiXmlNode( TiXmlNode::DECLARATION ) {}
+
+#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDeclaration(	const std::string& _version,
+						const std::string& _encoding,
+						const std::string& _standalone );
+#endif
+
+	/// Construct.
+	TiXmlDeclaration(	const char* _version,
+						const char* _encoding,
+						const char* _standalone );
+
+	TiXmlDeclaration( const TiXmlDeclaration& copy );
+	void operator=( const TiXmlDeclaration& copy );
+
+	virtual ~TiXmlDeclaration()	{}
+
+	/// Version. Will return an empty string if none was found.
+	const char *Version() const			{ return version.c_str (); }
+	/// Encoding. Will return an empty string if none was found.
+	const char *Encoding() const		{ return encoding.c_str (); }
+	/// Is this a standalone document?
+	const char *Standalone() const		{ return standalone.c_str (); }
+
+	/// Creates a copy of this Declaration and returns it.
+	virtual TiXmlNode* Clone() const;
+	/// Print this declaration to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+protected:
+	void CopyTo( TiXmlDeclaration* target ) const;
+	// used to be public
+	#ifdef TIXML_USE_STL
+	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	#endif
+	virtual void StreamOut ( TIXML_OSTREAM * out) const;
+
+private:
+
+	TIXML_STRING version;
+	TIXML_STRING encoding;
+	TIXML_STRING standalone;
+};
+
+
+/** Any tag that tinyXml doesn't recognize is saved as an
+	unknown. It is a tag of text, but should not be modified.
+	It will be written back to the XML, unchanged, when the file
+	is saved.
+
+	DTD tags get thrown into TiXmlUnknowns.
+*/
+class TiXmlUnknown : public TiXmlNode
+{
+public:
+	TiXmlUnknown() : TiXmlNode( TiXmlNode::UNKNOWN )	{}
+	virtual ~TiXmlUnknown() {}
+
+	TiXmlUnknown( const TiXmlUnknown& copy ) : TiXmlNode( TiXmlNode::UNKNOWN )		{ copy.CopyTo( this ); }
+	void operator=( const TiXmlUnknown& copy )										{ copy.CopyTo( this ); }
+
+	/// Creates a copy of this Unknown and returns it.
+	virtual TiXmlNode* Clone() const;
+	/// Print this Unknown to a FILE stream.
+	virtual void Print( FILE* cfile, int depth ) const;
+
+	virtual const char* Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding );
+
+protected:
+	void CopyTo( TiXmlUnknown* target ) const;
+
+	#ifdef TIXML_USE_STL
+	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	#endif
+	virtual void StreamOut ( TIXML_OSTREAM * out ) const;
+
+private:
+
+};
+
+
+/** Always the top level node. A document binds together all the
+	XML pieces. It can be saved, loaded, and printed to the screen.
+	The 'value' of a document node is the xml file name.
+*/
+class TiXmlDocument : public TiXmlNode
+{
+public:
+	/// Create an empty document, that has no name.
+	TiXmlDocument();
+	/// Create a document with a name. The name of the document is also the filename of the xml.
+	TiXmlDocument( const char * documentName );
+
+	#ifdef TIXML_USE_STL
+	/// Constructor.
+	TiXmlDocument( const std::string& documentName );
+	#endif
+
+	TiXmlDocument( const TiXmlDocument& copy );
+	void operator=( const TiXmlDocument& copy );
+
+	virtual ~TiXmlDocument() {}
+
+	/** Load a file using the current document value.
+		Returns true if successful. Will delete any existing
+		document data before loading.
+	*/
+	bool LoadFile( TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the current document value. Returns true if successful.
+	bool SaveFile() const;
+	/// Load a file using the given filename. Returns true if successful.
+	bool LoadFile( const char * filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+	/// Save a file using the given filename. Returns true if successful.
+	bool SaveFile( const char * filename ) const;
+
+	#ifdef TIXML_USE_STL
+	bool LoadFile( const std::string& filename, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING )			///< STL std::string version.
+	{
+		StringToBuffer f( filename );
+		return ( f.buffer && LoadFile( f.buffer, encoding ));
+	}
+	bool SaveFile( const std::string& filename ) const		///< STL std::string version.
+	{
+		StringToBuffer f( filename );
+		return ( f.buffer && SaveFile( f.buffer ));
+	}
+	#endif
+
+	/** Parse the given null terminated block of xml data. Passing in an encoding to this
+		method (either TIXML_ENCODING_LEGACY or TIXML_ENCODING_UTF8 will force TinyXml
+		to use that encoding, regardless of what TinyXml might otherwise try to detect.
+	*/
+	virtual const char* Parse( const char* p, TiXmlParsingData* data = 0, TiXmlEncoding encoding = TIXML_DEFAULT_ENCODING );
+
+	/** Get the root element -- the only top level element -- of the document.
+		In well formed XML, there should only be one. TinyXml is tolerant of
+		multiple elements at the document level.
+	*/
+	TiXmlElement* RootElement() const		{ return FirstChildElement(); }
+
+	/** If an error occurs, Error will be set to true. Also,
+		- The ErrorId() will contain the integer identifier of the error (not generally useful)
+		- The ErrorDesc() method will return the name of the error. (very useful)
+		- The ErrorRow() and ErrorCol() will return the location of the error (if known)
+	*/
+	bool Error() const						{ return error; }
+
+	/// Contains a textual (english) description of the error if one occurs.
+	const char * ErrorDesc() const	{ return errorDesc.c_str (); }
+
+	/** Generally, you probably want the error string ( ErrorDesc() ). But if you
+		prefer the ErrorId, this function will fetch it.
+	*/
+	const int ErrorId()	const				{ return errorId; }
+
+	/** Returns the location (if known) of the error. The first column is column 1,
+		and the first row is row 1. A value of 0 means the row and column wasn't applicable
+		(memory errors, for example, have no row/column) or the parser lost the error. (An
+		error in the error reporting, in that case.)
+
+		@sa SetTabSize, Row, Column
+	*/
+	int ErrorRow()	{ return errorLocation.row+1; }
+	int ErrorCol()	{ return errorLocation.col+1; }	///< The column where the error occured. See ErrorRow()
+
+	/** By calling this method, with a tab size
+		greater than 0, the row and column of each node and attribute is stored
+		when the file is loaded. Very useful for tracking the DOM back in to
+		the source file.
+
+		The tab size is required for calculating the location of nodes. If not
+		set, the default of 4 is used. The tabsize is set per document. Setting
+		the tabsize to 0 disables row/column tracking.
+
+		Note that row and column tracking is not supported when using operator>>.
+
+		The tab size needs to be enabled before the parse or load. Correct usage:
+		@verbatim
+		TiXmlDocument doc;
+		doc.SetTabSize( 8 );
+		doc.Load( "myfile.xml" );
+		@endverbatim
+
+		@sa Row, Column
+	*/
+	void SetTabSize( int _tabsize )		{ tabsize = _tabsize; }
+
+	int TabSize() const	{ return tabsize; }
+
+	/** If you have handled the error, it can be reset with this call. The error
+		state is automatically cleared if you Parse a new XML block.
+	*/
+	void ClearError()						{	error = false;
+												errorId = 0;
+												errorDesc = "";
+												errorLocation.row = errorLocation.col = 0;
+												//errorLocation.last = 0;
+											}
+
+	/** Dump the document to standard out. */
+	void Print() const						{ Print( stdout, 0 ); }
+
+	/// Print this Document to a FILE stream.
+	virtual void Print( FILE* cfile, int depth = 0 ) const;
+	// [internal use]
+	void SetError( int err, const char* errorLocation, TiXmlParsingData* prevData, TiXmlEncoding encoding );
+
+protected :
+	virtual void StreamOut ( TIXML_OSTREAM * out) const;
+	// [internal use]
+	virtual TiXmlNode* Clone() const;
+	#ifdef TIXML_USE_STL
+	    virtual void StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag );
+	#endif
+
+private:
+	void CopyTo( TiXmlDocument* target ) const;
+
+	bool error;
+	int  errorId;
+	TIXML_STRING errorDesc;
+	int tabsize;
+	TiXmlCursor errorLocation;
+};
+
+
+/**
+	A TiXmlHandle is a class that wraps a node pointer with null checks; this is
+	an incredibly useful thing. Note that TiXmlHandle is not part of the TinyXml
+	DOM structure. It is a separate utility class.
+
+	Take an example:
+	@verbatim
+	<Document>
+		<Element attributeA = "valueA">
+			<Child attributeB = "value1" />
+			<Child attributeB = "value2" />
+		</Element>
+	<Document>
+	@endverbatim
+
+	Assuming you want the value of "attributeB" in the 2nd "Child" element, it's very
+	easy to write a *lot* of code that looks like:
+
+	@verbatim
+	TiXmlElement* root = document.FirstChildElement( "Document" );
+	if ( root )
+	{
+		TiXmlElement* element = root->FirstChildElement( "Element" );
+		if ( element )
+		{
+			TiXmlElement* child = element->FirstChildElement( "Child" );
+			if ( child )
+			{
+				TiXmlElement* child2 = child->NextSiblingElement( "Child" );
+				if ( child2 )
+				{
+					// Finally do something useful.
+	@endverbatim
+
+	And that doesn't even cover "else" cases. TiXmlHandle addresses the verbosity
+	of such code. A TiXmlHandle checks for null	pointers so it is perfectly safe
+	and correct to use:
+
+	@verbatim
+	TiXmlHandle docHandle( &document );
+	TiXmlElement* child2 = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", 1 ).Element();
+	if ( child2 )
+	{
+		// do something useful
+	@endverbatim
+
+	Which is MUCH more concise and useful.
+
+	It is also safe to copy handles - internally they are nothing more than node pointers.
+	@verbatim
+	TiXmlHandle handleCopy = handle;
+	@endverbatim
+
+	What they should not be used for is iteration:
+
+	@verbatim
+	int i=0;
+	while ( true )
+	{
+		TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).Child( "Child", i ).Element();
+		if ( !child )
+			break;
+		// do something
+		++i;
+	}
+	@endverbatim
+
+	It seems reasonable, but it is in fact two embedded while loops. The Child method is
+	a linear walk to find the element, so this code would iterate much more than it needs
+	to. Instead, prefer:
+
+	@verbatim
+	TiXmlElement* child = docHandle.FirstChild( "Document" ).FirstChild( "Element" ).FirstChild( "Child" ).Element();
+
+	for( child; child; child=child->NextSiblingElement() )
+	{
+		// do something
+	}
+	@endverbatim
+*/
+class TiXmlHandle
+{
+public:
+	/// Create a handle from any node (at any depth of the tree.) This can be a null pointer.
+	TiXmlHandle( TiXmlNode* node )					{ this->node = node; }
+	/// Copy constructor
+	TiXmlHandle( const TiXmlHandle& ref )			{ this->node = ref.node; }
+	TiXmlHandle operator=( const TiXmlHandle& ref ) { this->node = ref.node; return *this; }
+
+	/// Return a handle to the first child node.
+	TiXmlHandle FirstChild() const;
+	/// Return a handle to the first child node with the given name.
+	TiXmlHandle FirstChild( const char * value ) const;
+	/// Return a handle to the first child element.
+	TiXmlHandle FirstChildElement() const;
+	/// Return a handle to the first child element with the given name.
+	TiXmlHandle FirstChildElement( const char * value ) const;
+
+	/** Return a handle to the "index" child with the given name.
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( const char* value, int index ) const;
+	/** Return a handle to the "index" child.
+		The first child is 0, the second 1, etc.
+	*/
+	TiXmlHandle Child( int index ) const;
+	/** Return a handle to the "index" child element with the given name.
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( const char* value, int index ) const;
+	/** Return a handle to the "index" child element.
+		The first child element is 0, the second 1, etc. Note that only TiXmlElements
+		are indexed: other types are not counted.
+	*/
+	TiXmlHandle ChildElement( int index ) const;
+
+	#ifdef TIXML_USE_STL
+	TiXmlHandle FirstChild( const std::string& _value ) const				{ return FirstChild( _value.c_str() ); }
+	TiXmlHandle FirstChildElement( const std::string& _value ) const		{ return FirstChildElement( _value.c_str() ); }
+
+	TiXmlHandle Child( const std::string& _value, int index ) const			{ return Child( _value.c_str(), index ); }
+	TiXmlHandle ChildElement( const std::string& _value, int index ) const	{ return ChildElement( _value.c_str(), index ); }
+	#endif
+
+	/// Return the handle as a TiXmlNode. This may return null.
+	TiXmlNode* Node() const			{ return node; }
+	/// Return the handle as a TiXmlElement. This may return null.
+	TiXmlElement* Element() const	{ return ( ( node && node->ToElement() ) ? node->ToElement() : 0 ); }
+	/// Return the handle as a TiXmlText. This may return null.
+	TiXmlText* Text() const			{ return ( ( node && node->ToText() ) ? node->ToText() : 0 ); }
+	/// Return the handle as a TiXmlUnknown. This may return null;
+	TiXmlUnknown* Unknown() const			{ return ( ( node && node->ToUnknown() ) ? node->ToUnknown() : 0 ); }
+
+private:
+	TiXmlNode* node;
+};
+
+
+#endif
Index: vdr-2.2.0/PLUGINS/src/setup/tinyxmlparser.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/tinyxmlparser.c	2015-12-24 15:16:31.700279626 +0100
@@ -0,0 +1,1492 @@
+/*
+www.sourceforge.net/projects/tinyxml
+Original code (2.0 and earlier )copyright (c) 2000-2002 Lee Thomason (www.grinninglizard.com)
+
+This software is provided 'as-is', without any express or implied
+warranty. In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you must
+not claim that you wrote the original software. If you use this
+software in a product, an acknowledgment in the product documentation
+would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source
+distribution.
+*/
+
+#include "tinyxml.h"
+#include <ctype.h>
+
+//#define DEBUG_PARSER
+
+// Note tha "PutString" hardcodes the same list. This
+// is less flexible than it appears. Changing the entries
+// or order will break putstring.
+TiXmlBase::Entity TiXmlBase::entity[ NUM_ENTITY ] =
+{
+	{ "&amp;",  5, '&' },
+	{ "&lt;",   4, '<' },
+	{ "&gt;",   4, '>' },
+	{ "&quot;", 6, '\"' },
+	{ "&apos;", 6, '\'' }
+};
+
+// Bunch of unicode info at:
+//		http://www.unicode.org/faq/utf_bom.html
+// Including the basic of this table, which determines the #bytes in the
+// sequence from the lead byte. 1 placed for invalid sequences --
+// although the result will be junk, pass it through as much as possible.
+// Beware of the non-characters in UTF-8:
+//				ef bb bf (Microsoft "lead bytes")
+//				ef bf be
+//				ef bf bf
+
+
+
+const int TiXmlBase::utf8ByteTable[256] =
+{
+	//	0	1	2	3	4	5	6	7	8	9	a	b	c	d	e	f
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x00
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x10
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x20
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x30
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x40
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x50
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x60
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x70	End of ASCII range
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x80 0x80 to 0xc1 invalid
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0x90
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xa0
+		1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	// 0xb0
+		1,	1,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xc0 0xc2 to 0xdf 2 byte
+		2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	2,	// 0xd0
+		3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	3,	// 0xe0 0xe0 to 0xef 3 byte
+		4,	4,	4,	4,	4,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1,	1	// 0xf0 0xf0 to 0xf4 4 byte, 0xf5 and higher invalid
+};
+
+
+void TiXmlBase::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )
+{
+	const unsigned long BYTE_MASK = 0xBF;
+	const unsigned long BYTE_MARK = 0x80;
+	const unsigned long FIRST_BYTE_MARK[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+	if (input < 0x80)
+		*length = 1;
+	else if ( input < 0x800 )
+		*length = 2;
+	else if ( input < 0x10000 )
+		*length = 3;
+	else if ( input < 0x200000 )
+		*length = 4;
+	else
+		{ *length = 0; return; }	// This code won't covert this correctly anyway.
+
+	output += *length;
+
+	// Scary scary fall throughs.
+	switch (*length)
+	{
+		case 4:
+			--output;
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK);
+			input >>= 6;
+		case 3:
+			--output;
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK);
+			input >>= 6;
+		case 2:
+			--output;
+			*output = (char)((input | BYTE_MARK) & BYTE_MASK);
+			input >>= 6;
+		case 1:
+			--output;
+			*output = (char)(input | FIRST_BYTE_MARK[*length]);
+	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlpha( unsigned char anyByte, TiXmlEncoding encoding )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalpha( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalpha( anyByte );
+//	}
+}
+
+
+/*static*/ int TiXmlBase::IsAlphaNum( unsigned char anyByte, TiXmlEncoding encoding )
+{
+	// This will only work for low-ascii, everything else is assumed to be a valid
+	// letter. I'm not sure this is the best approach, but it is quite tricky trying
+	// to figure out alhabetical vs. not across encoding. So take a very
+	// conservative approach.
+
+//	if ( encoding == TIXML_ENCODING_UTF8 )
+//	{
+		if ( anyByte < 127 )
+			return isalnum( anyByte );
+		else
+			return 1;	// What else to do? The unicode set is huge...get the english ones right.
+//	}
+//	else
+//	{
+//		return isalnum( anyByte );
+//	}
+}
+
+
+class TiXmlParsingData
+{
+	friend class TiXmlDocument;
+  public:
+	void Stamp( const char* now, TiXmlEncoding encoding );
+
+	const TiXmlCursor& Cursor()	{ return cursor; }
+
+  private:
+	// Only used by the document!
+	TiXmlParsingData( const char* start, int _tabsize, int row, int col )
+	{
+		assert( start );
+		stamp = start;
+		tabsize = _tabsize;
+		cursor.row = row;
+		cursor.col = col;
+	}
+
+	TiXmlCursor		cursor;
+	const char*		stamp;
+	int				tabsize;
+};
+
+
+void TiXmlParsingData::Stamp( const char* now, TiXmlEncoding encoding )
+{
+	assert( now );
+
+	// Do nothing if the tabsize is 0.
+	if ( tabsize < 1 )
+	{
+		return;
+	}
+
+	// Get the current row, column.
+	int row = cursor.row;
+	int col = cursor.col;
+	const char* p = stamp;
+	assert( p );
+
+	while ( p < now )
+	{
+		// Code contributed by Fletcher Dunn: (modified by lee)
+		switch (*p) {
+			case 0:
+				// We *should* never get here, but in case we do, don't
+				// advance past the terminating null character, ever
+				return;
+
+			case '\r':
+				// bump down to the next line
+				++row;
+				col = 0;
+				// Eat the character
+				++p;
+
+				// Check for \r\n sequence, and treat this as a single character
+				if (*p == '\n') {
+					++p;
+				}
+				break;
+
+			case '\n':
+				// bump down to the next line
+				++row;
+				col = 0;
+
+				// Eat the character
+				++p;
+
+				// Check for \n\r sequence, and treat this as a single
+				// character.  (Yes, this bizarre thing does occur still
+				// on some arcane platforms...)
+				if (*p == '\r') {
+					++p;
+				}
+				break;
+
+			case '\t':
+				// Eat the character
+				++p;
+
+				// Skip to next tab stop
+				col = (col / tabsize + 1) * tabsize;
+				break;
+
+			case (char)(0xef):
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					if ( *(p+1) && *(p+2) )
+					{
+						// In these cases, don't advance the column. These are
+						// 0-width spaces.
+						if ( *(p+1)==(char)(0xbb) && *(p+2)==(char)(0xbf) )
+							p += 3;
+						else if ( *(p+1)==(char)(0xbf) && *(p+2)==(char)(0xbe) )
+							p += 3;
+						else if ( *(p+1)==(char)(0xbf) && *(p+2)==(char)(0xbf) )
+							p += 3;
+						else
+							{ p +=3; ++col; }	// A normal character.
+					}
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+
+			default:
+				if ( encoding == TIXML_ENCODING_UTF8 )
+				{
+					// Eat the 1 to 4 byte utf8 character.
+					int step = TiXmlBase::utf8ByteTable[*((unsigned char*)p)];
+					if ( step == 0 )
+						step = 1;		// Error case from bad encoding, but handle gracefully.
+					p += step;
+
+					// Just advance one column, of course.
+					++col;
+				}
+				else
+				{
+					++p;
+					++col;
+				}
+				break;
+		}
+	}
+	cursor.row = row;
+	cursor.col = col;
+	assert( cursor.row >= -1 );
+	assert( cursor.col >= -1 );
+	stamp = p;
+	assert( stamp );
+}
+
+
+const char* TiXmlBase::SkipWhiteSpace( const char* p, TiXmlEncoding encoding )
+{
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+	if ( encoding == TIXML_ENCODING_UTF8 )
+	{
+		while ( *p )
+		{
+			// Skip the stupid Microsoft UTF-8 Byte order marks
+			if (	*(p+0)==(char) 0xef
+				 && *(p+1)==(char) 0xbb
+				 && *(p+2)==(char) 0xbf )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(p+0)==(char) 0xef
+				 && *(p+1)==(char) 0xbf
+				 && *(p+2)==(char) 0xbe )
+			{
+				p += 3;
+				continue;
+			}
+			else if(*(p+0)==(char) 0xef
+				 && *(p+1)==(char) 0xbf
+				 && *(p+2)==(char) 0xbf )
+			{
+				p += 3;
+				continue;
+			}
+
+			if ( IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )		// Still using old rules for white space.
+				++p;
+			else
+				break;
+		}
+	}
+	else
+	{
+		while ( *p && IsWhiteSpace( *p ) || *p == '\n' || *p =='\r' )
+			++p;
+	}
+
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+/*static*/ bool TiXmlBase::StreamWhiteSpace( TIXML_ISTREAM * in, TIXML_STRING * tag )
+{
+	for( ;; )
+	{
+		if ( !in->good() ) return false;
+
+		int c = in->peek();
+		// At this scope, we can't get to a document. So fail silently.
+		if ( !IsWhiteSpace( c ) || c <= 0 )
+			return true;
+
+		*tag += (char) in->get();
+	}
+}
+
+/*static*/ bool TiXmlBase::StreamTo( TIXML_ISTREAM * in, int character, TIXML_STRING * tag )
+{
+	//assert( character > 0 && character < 128 );	// else it won't work in utf-8
+	while ( in->good() )
+	{
+		int c = in->peek();
+		if ( c == character )
+			return true;
+		if ( c <= 0 )		// Silent failure: can't get document at this scope
+			return false;
+
+		in->get();
+		*tag += (char) c;
+	}
+	return false;
+}
+#endif
+
+const char* TiXmlBase::ReadName( const char* p, TIXML_STRING * name, TiXmlEncoding encoding )
+{
+	*name = "";
+	assert( p );
+
+	// Names start with letters or underscores.
+	// Of course, in unicode, tinyxml has no idea what a letter *is*. The
+	// algorithm is generous.
+	//
+	// After that, they can be letters, underscores, numbers,
+	// hyphens, or colons. (Colons are valid ony for namespaces,
+	// but tinyxml can't tell namespaces from names.)
+	if (    p && *p
+		 && ( IsAlpha( (unsigned char) *p, encoding ) || *p == '_' ) )
+	{
+		while(		p && *p
+				&&	(		IsAlphaNum( (unsigned char ) *p, encoding )
+						 || *p == '_'
+						 || *p == '-'
+						 || *p == '.'
+						 || *p == ':' ) )
+		{
+			(*name) += *p;
+			++p;
+		}
+		return p;
+	}
+	return 0;
+}
+
+const char* TiXmlBase::GetEntity( const char* p, char* value, int* length, TiXmlEncoding encoding )
+{
+	// Presume an entity, and pull it out.
+    TIXML_STRING ent;
+	int i;
+	*length = 0;
+
+	if ( *(p+1) && *(p+1) == '#' && *(p+2) )
+	{
+		unsigned long ucs = 0;
+		unsigned delta = 0;
+		unsigned mult = 1;
+
+		if ( *(p+2) == 'x' )
+		{
+			// Hexadecimal.
+			if ( !*(p+3) ) return 0;
+
+			const char* q = p+3;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != 'x' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else if ( *q >= 'a' && *q <= 'f' )
+					ucs += mult * (*q - 'a' + 10);
+				else if ( *q >= 'A' && *q <= 'F' )
+					ucs += mult * (*q - 'A' + 10 );
+				else
+					return 0;
+				mult *= 16;
+				--q;
+			}
+		}
+		else
+		{
+			// Decimal.
+			if ( !*(p+2) ) return 0;
+
+			const char* q = p+2;
+			q = strchr( q, ';' );
+
+			if ( !q || !*q ) return 0;
+
+			delta = q-p;
+			--q;
+
+			while ( *q != '#' )
+			{
+				if ( *q >= '0' && *q <= '9' )
+					ucs += mult * (*q - '0');
+				else
+					return 0;
+				mult *= 10;
+				--q;
+			}
+		}
+		if ( encoding == TIXML_ENCODING_UTF8 )
+		{
+			// convert the UCS to UTF-8
+			ConvertUTF32ToUTF8( ucs, value, length );
+		}
+		else
+		{
+			*value = (char)ucs;
+			*length = 1;
+		}
+		return p + delta + 1;
+	}
+
+	// Now try to match it.
+	for( i=0; i<NUM_ENTITY; ++i )
+	{
+		if ( strncmp( entity[i].str, p, entity[i].strLength ) == 0 )
+		{
+			assert( strlen( entity[i].str ) == entity[i].strLength );
+			*value = entity[i].chr;
+			*length = 1;
+			return ( p + entity[i].strLength );
+		}
+	}
+
+	// So it wasn't an entity, its unrecognized, or something like that.
+	*value = *p;	// Don't put back the last one, since we return it!
+	return p+1;
+}
+
+
+bool TiXmlBase::StringEqual( const char* p,
+							 const char* tag,
+							 bool ignoreCase,
+							 TiXmlEncoding encoding )
+{
+	assert( p );
+	assert( tag );
+	if ( !p || !*p )
+	{
+		assert( 0 );
+		return false;
+	}
+
+	const char* q = p;
+
+	if ( ignoreCase )
+	{
+		while ( *q && *tag && ToLower( *q, encoding ) == ToLower( *tag, encoding ) )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )
+			return true;
+	}
+	else
+	{
+		while ( *q && *tag && *q == *tag )
+		{
+			++q;
+			++tag;
+		}
+
+		if ( *tag == 0 )		// Have we found the end of the tag, and everything equal?
+			return true;
+	}
+	return false;
+}
+
+const char* TiXmlBase::ReadText(	const char* p,
+									TIXML_STRING * text,
+									bool trimWhiteSpace,
+									const char* endTag,
+									bool caseInsensitive,
+									TiXmlEncoding encoding )
+{
+    *text = "";
+	if (    !trimWhiteSpace			// certain tags always keep whitespace
+		 || !condenseWhiteSpace )	// if true, whitespace is always kept
+	{
+		// Keep all the white space.
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding )
+			  )
+		{
+			int len;
+			char cArr[4] = { 0, 0, 0, 0 };
+			p = GetChar( p, cArr, &len, encoding );
+			text->append( cArr, len );
+		}
+	}
+	else
+	{
+		bool whitespace = false;
+
+		// Remove leading white space:
+		p = SkipWhiteSpace( p, encoding );
+		while (	   p && *p
+				&& !StringEqual( p, endTag, caseInsensitive, encoding ) )
+		{
+			if ( *p == '\r' || *p == '\n' )
+			{
+				whitespace = true;
+				++p;
+			}
+			else if ( IsWhiteSpace( *p ) )
+			{
+				whitespace = true;
+				++p;
+			}
+			else
+			{
+				// If we've found whitespace, add it before the
+				// new character. Any whitespace just becomes a space.
+				if ( whitespace )
+				{
+					(*text) += ' ';
+					whitespace = false;
+				}
+				int len;
+				char cArr[4] = { 0, 0, 0, 0 };
+				p = GetChar( p, cArr, &len, encoding );
+				if ( len == 1 )
+					(*text) += cArr[0];	// more efficient
+				else
+					text->append( cArr, len );
+			}
+		}
+	}
+	return p + strlen( endTag );
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlDocument::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
+{
+	// The basic issue with a document is that we don't know what we're
+	// streaming. Read something presumed to be a tag (and hope), then
+	// identify it, and call the appropriate stream method on the tag.
+	//
+	// This "pre-streaming" will never read the closing ">" so the
+	// sub-tag can orient itself.
+
+	if ( !StreamTo( in, '<', tag ) )
+	{
+		SetError( TIXML_ERROR_PARSING_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return;
+	}
+
+	while ( in->good() )
+	{
+		int tagIndex = (int) tag->length();
+		while ( in->good() && in->peek() != '>' )
+		{
+			int c = in->get();
+			if ( c <= 0 )
+			{
+				SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+				break;
+			}
+			(*tag) += (char) c;
+		}
+
+		if ( in->good() )
+		{
+			// We now have something we presume to be a node of
+			// some sort. Identify it, and call the node to
+			// continue streaming.
+			TiXmlNode* node = Identify( tag->c_str() + tagIndex, TIXML_DEFAULT_ENCODING );
+
+			if ( node )
+			{
+				node->StreamIn( in, tag );
+				bool isElement = node->ToElement() != 0;
+				delete node;
+				node = 0;
+
+				// If this is the root element, we're done. Parsing will be
+				// done by the >> operator.
+				if ( isElement )
+				{
+					return;
+				}
+			}
+			else
+			{
+				SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+				return;
+			}
+		}
+	}
+	// We should have returned sooner.
+	SetError( TIXML_ERROR, 0, 0, TIXML_ENCODING_UNKNOWN );
+}
+
+#endif
+
+const char* TiXmlDocument::Parse( const char* p, TiXmlParsingData* prevData, TiXmlEncoding encoding )
+{
+	ClearError();
+
+	// Parse away, at the document level. Since a document
+	// contains nothing but other tags, most of what happens
+	// here is skipping white space.
+	if ( !p || !*p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	// Note that, for a document, this needs to come
+	// before the while space skip, so that parsing
+	// starts from the pointer we are given.
+	location.Clear();
+	if ( prevData )
+	{
+		location.row = prevData->cursor.row;
+		location.col = prevData->cursor.col;
+	}
+	else
+	{
+		location.row = 0;
+		location.col = 0;
+	}
+	TiXmlParsingData data( p, TabSize(), location.row, location.col );
+	location = data.Cursor();
+
+	if ( encoding == TIXML_ENCODING_UNKNOWN )
+	{
+		// Check for the Microsoft UTF-8 lead bytes.
+		if (	*(p+0) && *(p+0) == (char)(0xef)
+			 && *(p+1) && *(p+1) == (char)(0xbb)
+			 && *(p+2) && *(p+2) == (char)(0xbf) )
+		{
+			encoding = TIXML_ENCODING_UTF8;
+		}
+	}
+
+    p = SkipWhiteSpace( p, encoding );
+	if ( !p )
+	{
+		SetError( TIXML_ERROR_DOCUMENT_EMPTY, 0, 0, TIXML_ENCODING_UNKNOWN );
+		return 0;
+	}
+
+	while ( p && *p )
+	{
+		TiXmlNode* node = Identify( p, encoding );
+		if ( node )
+		{
+			p = node->Parse( p, &data, encoding );
+			LinkEndChild( node );
+		}
+		else
+		{
+			break;
+		}
+
+		// Did we get encoding info?
+		if (    encoding == TIXML_ENCODING_UNKNOWN
+			 && node->ToDeclaration() )
+		{
+			TiXmlDeclaration* dec = node->ToDeclaration();
+			const char* enc = dec->Encoding();
+			assert( enc );
+
+			if ( *enc == 0 )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF-8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;
+			else if ( StringEqual( enc, "UTF8", true, TIXML_ENCODING_UNKNOWN ) )
+				encoding = TIXML_ENCODING_UTF8;	// incorrect, but be nice
+			else
+				encoding = TIXML_ENCODING_LEGACY;
+		}
+
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	// All is well.
+	return p;
+}
+
+void TiXmlDocument::SetError( int err, const char* pError, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	// The first error in a chain is more accurate - don't set again!
+	if ( error )
+		return;
+
+	assert( err > 0 && err < TIXML_ERROR_STRING_COUNT );
+	error   = true;
+	errorId = err;
+	errorDesc = errorString[ errorId ];
+
+	errorLocation.Clear();
+	if ( pError && data )
+	{
+		//TiXmlParsingData data( pError, prevData );
+		data->Stamp( pError, encoding );
+		errorLocation = data->Cursor();
+	}
+}
+
+
+TiXmlNode* TiXmlNode::Identify( const char* p, TiXmlEncoding encoding )
+{
+	TiXmlNode* returnNode = 0;
+
+	p = SkipWhiteSpace( p, encoding );
+	if( !p || !*p || *p != '<' )
+	{
+		return 0;
+	}
+
+	TiXmlDocument* doc = GetDocument();
+	p = SkipWhiteSpace( p, encoding );
+
+	if ( !p || !*p )
+	{
+		return 0;
+	}
+
+	// What is this thing?
+	// - Elements start with a letter or underscore, but xml is reserved.
+	// - Comments: <!--
+	// - Decleration: <?xml
+	// - Everthing else is unknown to tinyxml.
+	//
+
+	const char* xmlHeader = { "<?xml" };
+	const char* commentHeader = { "<!--" };
+	const char* dtdHeader = { "<!" };
+
+	if ( StringEqual( p, xmlHeader, true, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Declaration\n" );
+		#endif
+		returnNode = new TiXmlDeclaration();
+	}
+	else if ( StringEqual( p, commentHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Comment\n" );
+		#endif
+		returnNode = new TiXmlComment();
+	}
+	else if ( StringEqual( p, dtdHeader, false, encoding ) )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(1)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+	else if (    IsAlpha( *(p+1), encoding )
+			  || *(p+1) == '_' )
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Element\n" );
+		#endif
+		returnNode = new TiXmlElement( "" );
+	}
+	else
+	{
+		#ifdef DEBUG_PARSER
+			TIXML_LOG( "XML parsing Unknown(2)\n" );
+		#endif
+		returnNode = new TiXmlUnknown();
+	}
+
+	if ( returnNode )
+	{
+		// Set the parent, so it can report errors
+		returnNode->parent = this;
+	}
+	else
+	{
+		if ( doc )
+			doc->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, TIXML_ENCODING_UNKNOWN );
+	}
+	return returnNode;
+}
+
+#ifdef TIXML_USE_STL
+
+void TiXmlElement::StreamIn (TIXML_ISTREAM * in, TIXML_STRING * tag)
+{
+	// We're called with some amount of pre-parsing. That is, some of "this"
+	// element is in "tag". Go ahead and stream to the closing ">"
+	while( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c ;
+
+		if ( c == '>' )
+			break;
+	}
+
+	if ( tag->length() < 3 ) return;
+
+	// Okay...if we are a "/>" tag, then we're done. We've read a complete tag.
+	// If not, identify and stream.
+
+	if (    tag->at( tag->length() - 1 ) == '>'
+		 && tag->at( tag->length() - 2 ) == '/' )
+	{
+		// All good!
+		return;
+	}
+	else if ( tag->at( tag->length() - 1 ) == '>' )
+	{
+		// There is more. Could be:
+		//		text
+		//		closing tag
+		//		another node.
+		for ( ;; )
+		{
+			StreamWhiteSpace( in, tag );
+
+			// Do we have text?
+			if ( in->good() && in->peek() != '<' )
+			{
+				// Yep, text.
+				TiXmlText text( "" );
+				text.StreamIn( in, tag );
+
+				// What follows text is a closing tag or another node.
+				// Go around again and figure it out.
+				continue;
+			}
+
+			// We now have either a closing tag...or another node.
+			// We should be at a "<", regardless.
+			if ( !in->good() ) return;
+			assert( in->peek() == '<' );
+			int tagIndex = tag->length();
+
+			bool closingTag = false;
+			bool firstCharFound = false;
+
+			for( ;; )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->peek();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+
+				if ( c == '>' )
+					break;
+
+				*tag += (char) c;
+				in->get();
+
+				if ( !firstCharFound && c != '<' && !IsWhiteSpace( c ) )
+				{
+					firstCharFound = true;
+					if ( c == '/' )
+						closingTag = true;
+				}
+			}
+			// If it was a closing tag, then read in the closing '>' to clean up the input stream.
+			// If it was not, the streaming will be done by the tag.
+			if ( closingTag )
+			{
+				if ( !in->good() )
+					return;
+
+				int c = in->get();
+				if ( c <= 0 )
+				{
+					TiXmlDocument* document = GetDocument();
+					if ( document )
+						document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+					return;
+				}
+				assert( c == '>' );
+				*tag += (char) c;
+
+				// We are done, once we've found our closing tag.
+				return;
+			}
+			else
+			{
+				// If not a closing tag, id it, and stream.
+				const char* tagloc = tag->c_str() + tagIndex;
+				TiXmlNode* node = Identify( tagloc, TIXML_DEFAULT_ENCODING );
+				if ( !node )
+					return;
+				node->StreamIn( in, tag );
+				delete node;
+				node = 0;
+
+				// No return: go around from the beginning: text, closing tag, or node.
+			}
+		}
+	}
+}
+#endif
+
+const char* TiXmlElement::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	TiXmlDocument* document = GetDocument();
+
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, 0, 0, encoding );
+		return 0;
+	}
+
+//	TiXmlParsingData data( p, prevData );
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+
+	if ( *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, p, data, encoding );
+		return 0;
+	}
+
+	p = SkipWhiteSpace( p+1, encoding );
+
+	// Read the name.
+	const char* pErr = p;
+
+    p = ReadName( p, &value, encoding );
+	if ( !p || !*p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_FAILED_TO_READ_ELEMENT_NAME, pErr, data, encoding );
+		return 0;
+	}
+
+    TIXML_STRING endTag ("</");
+	endTag += value;
+	endTag += ">";
+
+	// Check for and read attributes. Also look for an empty
+	// tag or an end tag.
+	while ( p && *p )
+	{
+		pErr = p;
+		p = SkipWhiteSpace( p, encoding );
+		if ( !p || !*p )
+		{
+			if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+			return 0;
+		}
+		if ( *p == '/' )
+		{
+			++p;
+			// Empty tag.
+			if ( *p  != '>' )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_EMPTY, p, data, encoding );
+				return 0;
+			}
+			return (p+1);
+		}
+		else if ( *p == '>' )
+		{
+			// Done with attributes (if there were any.)
+			// Read the value -- which can include other
+			// elements -- read the end tag, and return.
+			++p;
+			p = ReadValue( p, data, encoding );		// Note this is an Element method, and will set the error if one happens.
+			if ( !p || !*p )
+				return 0;
+
+			// We should find the end tag now
+			if ( StringEqual( p, endTag.c_str(), false, encoding ) )
+			{
+				p += endTag.length();
+				return p;
+			}
+			else
+			{
+				if ( document ) document->SetError( TIXML_ERROR_READING_END_TAG, p, data, encoding );
+				return 0;
+			}
+		}
+		else
+		{
+			// Try to read an attribute:
+			TiXmlAttribute* attrib = new TiXmlAttribute();
+			if ( !attrib )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, pErr, data, encoding );
+				return 0;
+			}
+
+			attrib->SetDocument( document );
+			const char* pErr = p;
+			p = attrib->Parse( p, data, encoding );
+
+			if ( !p || !*p )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_PARSING_ELEMENT, pErr, data, encoding );
+				delete attrib;
+				return 0;
+			}
+
+			// Handle the strange case of double attributes:
+			TiXmlAttribute* node = attributeSet.Find( attrib->Name() );
+			if ( node )
+			{
+				node->SetValue( attrib->Value() );
+				delete attrib;
+				return 0;
+			}
+
+			attributeSet.Add( attrib );
+		}
+	}
+	return p;
+}
+
+
+const char* TiXmlElement::ReadValue( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+
+	const char* pWithWhiteSpace = p;
+	// Read in text and elements in any order.
+	p = SkipWhiteSpace( p, encoding );
+	while ( p && *p )
+	{
+		if ( *p != '<' )
+		{
+			// Take what we have, make a text element.
+			TiXmlText* textNode = new TiXmlText( "" );
+
+			if ( !textNode )
+			{
+				if ( document ) document->SetError( TIXML_ERROR_OUT_OF_MEMORY, 0, 0, encoding );
+				    return 0;
+			}
+
+			if ( TiXmlBase::IsWhiteSpaceCondensed() )
+			{
+				p = textNode->Parse( p, data, encoding );
+			}
+			else
+			{
+				// Special case: we want to keep the white space
+				// so that leading spaces aren't removed.
+				p = textNode->Parse( pWithWhiteSpace, data, encoding );
+			}
+
+			if ( !textNode->Blank() )
+				LinkEndChild( textNode );
+			else
+				delete textNode;
+		}
+		else
+		{
+			// We hit a '<'
+			// Have we hit a new element or an end tag?
+			if ( StringEqual( p, "</", false, encoding ) )
+			{
+				return p;
+			}
+			else
+			{
+				TiXmlNode* node = Identify( p, encoding );
+				if ( node )
+				{
+					p = node->Parse( p, data, encoding );
+					LinkEndChild( node );
+				}
+				else
+				{
+					return 0;
+				}
+			}
+		}
+		p = SkipWhiteSpace( p, encoding );
+	}
+
+	if ( !p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ELEMENT_VALUE, 0, 0, encoding );
+	}
+	return p;
+}
+
+
+#ifdef TIXML_USE_STL
+void TiXmlUnknown::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlUnknown::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	p = SkipWhiteSpace( p, encoding );
+
+//	TiXmlParsingData data( p, prevData );
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	if ( !p || !*p || *p != '<' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_UNKNOWN, p, data, encoding );
+		return 0;
+	}
+	++p;
+    value = "";
+
+	while ( p && *p && *p != '>' )
+	{
+		value += *p;
+		++p;
+	}
+
+	if ( !p )
+	{
+		if ( document )	document->SetError( TIXML_ERROR_PARSING_UNKNOWN, 0, 0, encoding );
+	}
+	if ( *p == '>' )
+		return p+1;
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlComment::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+
+		if ( c == '>'
+			 && tag->at( tag->length() - 2 ) == '-'
+			 && tag->at( tag->length() - 3 ) == '-' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+
+const char* TiXmlComment::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	TiXmlDocument* document = GetDocument();
+	value = "";
+
+	p = SkipWhiteSpace( p, encoding );
+
+//	TiXmlParsingData data( p, prevData );
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	const char* startTag = "<!--";
+	const char* endTag   = "-->";
+
+	if ( !StringEqual( p, startTag, false, encoding ) )
+	{
+		document->SetError( TIXML_ERROR_PARSING_COMMENT, p, data, encoding );
+		return 0;
+	}
+	p += strlen( startTag );
+	p = ReadText( p, &value, false, endTag, false, encoding );
+	return p;
+}
+
+
+const char* TiXmlAttribute::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p ) return 0;
+
+	int tabsize = 4;
+	if ( document )
+		tabsize = document->TabSize();
+
+//	TiXmlParsingData data( p, prevData );
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	// Read the name, the '=' and the value.
+	const char* pErr = p;
+	p = ReadName( p, &name, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, pErr, data, encoding );
+		return 0;
+	}
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p || *p != '=' )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+
+	++p;	// skip '='
+	p = SkipWhiteSpace( p, encoding );
+	if ( !p || !*p )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_READING_ATTRIBUTES, p, data, encoding );
+		return 0;
+	}
+
+	const char* end;
+
+	if ( *p == '\'' )
+	{
+		++p;
+		end = "\'";
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else if ( *p == '"' )
+	{
+		++p;
+		end = "\"";
+		p = ReadText( p, &value, false, end, false, encoding );
+	}
+	else
+	{
+		// All attribute values should be in single or double quotes.
+		// But this is such a common error that the parser will try
+		// its best, even without them.
+		value = "";
+		while (    p && *p										// existence
+				&& !IsWhiteSpace( *p ) && *p != '\n' && *p != '\r'	// whitespace
+				&& *p != '/' && *p != '>' )						// tag end
+		{
+			value += *p;
+			++p;
+		}
+	}
+	return p;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlText::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->peek();
+		if ( c == '<' )
+			return;
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+
+		(*tag) += (char) c;
+		in->get();
+	}
+}
+#endif
+
+const char* TiXmlText::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding encoding )
+{
+	value = "";
+//	TiXmlParsingData data( p, prevData );
+	if ( data )
+	{
+		data->Stamp( p, encoding );
+		location = data->Cursor();
+	}
+	bool ignoreWhite = true;
+
+	const char* end = "<";
+	p = ReadText( p, &value, ignoreWhite, end, false, encoding );
+	if ( p )
+		return p-1;	// don't truncate the '<'
+	return 0;
+}
+
+#ifdef TIXML_USE_STL
+void TiXmlDeclaration::StreamIn( TIXML_ISTREAM * in, TIXML_STRING * tag )
+{
+	while ( in->good() )
+	{
+		int c = in->get();
+		if ( c <= 0 )
+		{
+			TiXmlDocument* document = GetDocument();
+			if ( document )
+				document->SetError( TIXML_ERROR_EMBEDDED_NULL, 0, 0, TIXML_ENCODING_UNKNOWN );
+			return;
+		}
+		(*tag) += (char) c;
+
+		if ( c == '>' )
+		{
+			// All is well.
+			return;
+		}
+	}
+}
+#endif
+
+const char* TiXmlDeclaration::Parse( const char* p, TiXmlParsingData* data, TiXmlEncoding _encoding )
+{
+	p = SkipWhiteSpace( p, _encoding );
+	// Find the beginning, find the end, and look for
+	// the stuff in-between.
+	TiXmlDocument* document = GetDocument();
+	if ( !p || !*p || !StringEqual( p, "<?xml", true, _encoding ) )
+	{
+		if ( document ) document->SetError( TIXML_ERROR_PARSING_DECLARATION, 0, 0, _encoding );
+		return 0;
+	}
+//	TiXmlParsingData data( p, prevData );
+	if ( data )
+	{
+		data->Stamp( p, _encoding );
+		location = data->Cursor();
+	}
+	p += 5;
+
+	version = "";
+	encoding = "";
+	standalone = "";
+
+	while ( p && *p )
+	{
+		if ( *p == '>' )
+		{
+			++p;
+			return p;
+		}
+
+		p = SkipWhiteSpace( p, _encoding );
+		if ( StringEqual( p, "version", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );
+			version = attrib.Value();
+		}
+		else if ( StringEqual( p, "encoding", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );
+			encoding = attrib.Value();
+		}
+		else if ( StringEqual( p, "standalone", true, _encoding ) )
+		{
+			TiXmlAttribute attrib;
+			p = attrib.Parse( p, data, _encoding );
+			standalone = attrib.Value();
+		}
+		else
+		{
+			// Read over whatever it is.
+			while( p && *p && *p != '>' && !IsWhiteSpace( *p ) )
+				++p;
+		}
+	}
+	return 0;
+}
+
+bool TiXmlText::Blank() const
+{
+	for ( unsigned i=0; i<value.length(); i++ )
+		if ( !IsWhiteSpace( value[i] ) )
+			return false;
+	return true;
+}
Index: vdr-2.2.0/PLUGINS/src/setup/util.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/util.c	2015-12-24 15:16:31.700279626 +0100
@@ -0,0 +1,302 @@
+/****************************************************************************
+ * DESCRIPTION: 
+ *             Utitility Methods
+ *
+ * $Id: util.cpp,v 1.7 2006/03/06 19:16:41 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ ****************************************************************************/
+
+
+#include <string.h>
+#include "util.h"
+#include "debug.h"
+#include "setupsetup.h"
+
+Util::Util()
+{
+}
+
+
+Util::~Util()
+{
+}
+
+static const char *undefStr = "undefined";
+static const char *boolStr = "bool";
+static const char *textStr = "text";
+static const char *numTextStr = "numtext";
+static const char *hexStr = "hex";
+static const char *ipStr = "ip";
+static const char *numberStr= "number";
+static const char *selectionStr = "selection";
+
+
+static const char *trueStr = "true";
+static const char *falseStr = "false";
+static const char *onStr = "on";
+static const char *offStr = "off";
+static const char *yesStr = "yes";
+static const char *noStr = "no";
+
+
+char *Util::Strdupnew(const char  *str)
+{
+  return (str ? strcpy(new char[strlen(str)+1],str) : 0);
+}
+
+char *Util::Strdupnew(const char  *str, int size)
+{
+  char *result = NULL;
+  if (str != NULL) {
+     result = strncpy(new char[size+1],str, size);
+     result[size] = '\0';
+     }
+
+  return (result);
+}
+
+
+char *Util::Strdupnew(const char  *prefix, const char  *str)
+{
+  char *newStr = NULL;
+  if (str != NULL && prefix != NULL) {
+     int len = strlen(prefix) +strlen(str);
+     newStr = new char[(len+1)];
+     sprintf(newStr, "%s%s", prefix, str);
+     }
+
+  return (newStr);
+}
+
+
+/**
+ * check id the given string represenst a bool value
+ * @param string string to compare for bool representation
+ * @param flag corresponding bool value
+ * @return false if error was detected
+ */
+bool Util::isBool(const char *string, bool & flag)
+{
+  bool ok=true;
+
+  if (string != NULL) {
+     if (strcmp(string, trueStr) == 0 || strcmp(string, onStr) == 0 || strcmp(string, yesStr) == 0)
+        flag = true;
+     else if (strcmp(string, falseStr) == 0 || strcmp(string, offStr) == 0 || strcmp(string, noStr) == 0)
+        flag = false;
+     else
+        ok = false;
+     }
+  else
+     ok = false;
+
+  if (!ok)
+     DEBUG3("%s: Illegal Bool value %s found\n", DBG_PREFIX, string);
+
+  return(ok);
+}
+
+bool Util::isBool(const char *string, int & flag)
+{
+  bool ok=true;
+  bool boolVal;
+
+  if (isBool(string, boolVal)) {
+     if (boolVal)
+        flag=true;
+     else
+        flag=false;
+     }
+
+  return(ok);
+}
+
+
+/**
+ * check id the given string represenst a Type value
+ *
+ * known types are "text", "bool", "number", "numtext" "ip"
+ * @param string string to compare for type representation
+ * @param typ corresponding type value
+ * @return false if error was detected
+ */
+bool Util::isType(const char *string, Util::Type & type)
+{
+  bool ok = true;
+
+  if (string != NULL) {
+     if (strcmp(string, boolStr) == 0)           type = Util::BOOL;
+     else if (strcmp(string, textStr) == 0)      type = Util::TEXT;
+     else if (strcmp(string, numTextStr) == 0)   type = Util::NUMBER_TEXT;
+     else if (strcmp(string, hexStr) == 0)       type = Util::HEX;
+     else if (strcmp(string, numberStr) == 0)    type = Util::NUMBER;
+     else if (strcmp(string, ipStr) == 0)        type = Util::IP;
+     else if (strcmp(string, selectionStr) == 0) type = Util::SELECTION;
+     else ok = false;
+     }
+  else
+    ok = false;
+
+  if (!ok)
+     DEBUG3("%s: Illegal Type value %s found\n", DBG_PREFIX, string);
+
+  return(ok);
+}
+
+
+/**
+ * 
+ * @param string 
+ * @param number 
+ * @return 
+ */
+bool Util::isNumber(const char *string, int & number)
+{
+  bool ok = true;
+  number = 0;
+
+  if (string != NULL) {
+     int len = strlen(string);
+     for (int i=0; i<len && ok==true; i++)
+        if (string[i] < '0' || string[i]>'9')
+           ok=false;
+        else
+           number = number * 10 + (string[i] - '0');
+     }
+  else
+     ok = false;
+
+  return(ok);
+}
+
+
+/**
+ * Returns the strung representation of given type
+ * @param type 
+ * @return 
+ */
+const char *Util::boolToStr(bool val)
+{
+  const char *result;
+
+  if (val == true) {
+     if (setupSetup.ReturnValue == 0)      result = trueStr;
+     else if (setupSetup.ReturnValue == 1) result = onStr;
+     else if (setupSetup.ReturnValue == 2) result = yesStr;
+     else result = onStr;
+     }
+  else {
+     if (setupSetup.ReturnValue == 0)      result = falseStr;
+     else if (setupSetup.ReturnValue == 1) result = offStr;
+     else if (setupSetup.ReturnValue == 2) result = noStr;
+     else result = offStr;
+     }
+
+  return(result);
+}
+
+
+
+/**
+ * Returns the strung representation of given type
+ * @param type 
+ * @return 
+ */
+const char *Util::typeToStr(Type type)
+{
+  const char *result = undefStr;
+  switch(type) {
+     case BOOL:         result = boolStr;
+                        break;
+     case TEXT:         result = textStr;
+                        break;
+     case NUMBER_TEXT:  result=numTextStr;
+                        break;
+     case HEX:          result=hexStr;
+                        break;
+     case NUMBER:       result =numberStr;
+                        break;
+     case IP:           result =ipStr;
+                        break;
+     case SELECTION:    result =selectionStr;
+                        break;
+     case UNDEFINED:    result=undefStr;
+                        break;
+     }
+  return(result);
+}
+
+void Util::SwitchChannelList(const char *selectedChannelList)
+{
+  char *channelDir  = NULL;
+  char *channelFile = NULL;
+  char  resolvedPath[PATH_MAX];
+  char *newChannelFile = NULL;
+
+  if (selectedChannelList == NULL)
+     return;
+
+  asprintf(&channelDir, "%s", cPlugin::ConfigDirectory());
+  char *tmp = strrchr(channelDir,'/');
+  *tmp = '\0';
+
+  asprintf(&channelFile,    "%s/channels.conf",channelDir);
+  asprintf(&channelDir,     "%s/channels",channelDir);
+  asprintf(&newChannelFile, "%s/%s.conf", channelDir, selectedChannelList);
+
+  if (realpath(channelFile, resolvedPath) == NULL)
+     DEBUG4("%s Can not resolve realpath of %s  errno=%d\n", DBG_PREFIX, channelFile, errno);
+  else {
+     if (strcmp(resolvedPath, newChannelFile)!= 0) { // channels changed !!
+        Channels.SwitchTo(1);
+        if (unlink(channelFile) == 0) {
+           if (symlink(newChannelFile, channelFile)!= 0)
+              DEBUG5("%s Can not link File %s  to %s errno=%d\n", DBG_PREFIX, tmp, channelFile, errno);
+           TimerList timers;
+           timers.SaveTimer();
+           Channels.Load(channelFile, true, false); // Read Channel-List
+           Channels.SwitchTo(1);
+           timers.RestoreTimer();
+           }
+        else
+           DEBUG4("%s Can not unlink File %s  errno=%d\n", DBG_PREFIX, channelFile, errno);
+        }
+     }
+
+  free(channelDir);
+  free(channelFile);
+  free(newChannelFile);
+}
+
+
+// Timer Save and Restore Methods
+void TimerList::SaveTimer()
+{
+  myTimers.Clear();
+  for (cTimer *t = Timers.First(); t; t= Timers.Next(t)) {
+     myTimers.Add(new TimerString(t->ToText(true)));
+     }
+  Timers.cList<cTimer>::Clear();
+}
+
+// restore Timers, delete Timers with unknown channel
+void TimerList::RestoreTimer()
+{
+  Timers.cList<cTimer>::Clear();
+
+  for (TimerString *timer = myTimers.First(); timer; timer= myTimers.Next(timer)){
+     cString t = timer->GetTimerString();
+     cTimer *tim = new cTimer();
+     tim->Parse(t);
+     if (tim->Channel() != NULL)
+        Timers.Add(tim);
+     }
+  Timers.SetModified();
+  myTimers.Clear();
+}
+
+
+
Index: vdr-2.2.0/PLUGINS/src/setup/util.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ vdr-2.2.0/PLUGINS/src/setup/util.h	2015-12-24 15:16:31.700279626 +0100
@@ -0,0 +1,58 @@
+/*********************************************************
+ * DESCRIPTION: 
+ *             Header File
+ *
+ * $Id: util.h,v 1.7 2006/03/06 19:16:41 ralf Exp $
+ *
+ * Contact:    ranga@vdrtools.de
+ *
+ * Copyright (C) 2004 by Ralf Dotzert 
+ *********************************************************/
+
+#ifndef UTIL_H
+#define UTIL_H
+#include <vdr/tools.h>
+#include <vdr/timers.h>
+
+
+/**
+@author Ralf Dotzert
+*/
+class Util{
+public:
+    Util();
+    ~Util();
+    enum Type { UNDEFINED,TEXT, NUMBER_TEXT, HEX, IP, BOOL, NUMBER, SELECTION};
+    static char * Strdupnew(const char  *str);
+    static char * Strdupnew(const char  *prefix, const char  *str);
+    static char * Strdupnew( const char  *str, int size );
+    static bool isBool(const char *string, bool &flag);
+    static bool isBool(const char *string, int  &flag);
+    static bool isType( const char * string, Util::Type & typ );
+    static bool isNumber( const char * string, int &number );
+    static const char * typeToStr(Type type);
+    static const char * boolToStr( bool val );
+    static void SwitchChannelList(const char  *selectedChannelList);
+};
+
+class TimerString : public cListObject
+{
+  private:
+    cString  _timer;
+  public:
+    TimerString (cString timer)   {_timer=timer; }
+    cString      GetTimerString() {return (_timer);}
+};
+
+class TimerList
+{
+  private:
+    cList<TimerString>  myTimers;
+  public:
+    TimerList()  {};
+    ~TimerList() {};
+    void SaveTimer();
+    void RestoreTimer();
+};
+
+#endif
